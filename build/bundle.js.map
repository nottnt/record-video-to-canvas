{"version":3,"file":"bundle.js","sources":["../../node_modules/svelte/internal/index.mjs","../../node_modules/webrtc-adapter/src/js/utils.js","../../node_modules/webrtc-adapter/src/js/chrome/getusermedia.js","../../node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js","../../node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js","../../node_modules/webrtc-adapter/src/js/firefox/getusermedia.js","../../node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js","../../node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js","../../node_modules/webrtc-adapter/src/js/safari/safari_shim.js","../../node_modules/sdp/sdp.js","../../node_modules/webrtc-adapter/src/js/common_shim.js","../../node_modules/webrtc-adapter/src/js/adapter_core.js","../../node_modules/webrtc-adapter/src/js/adapter_factory.js","../../src/RecordRTC.js","../../node_modules/webcam-easy/src/webcam-easy.js","../../src/VideoRecord.svelte","../../src/App.svelte","../../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration();\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    select.selectedIndex = -1; // no option should be selected\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, bubbles = false) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor() {\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = element(target.nodeName);\n            this.t = target;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes) {\n        super();\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction escape_attribute_value(value) {\n    return typeof value === 'string' ? escape(value) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(parent_component ? parent_component.$$.context : context || []),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = on_mount.map(run).filter(is_function);\n            if (on_destroy) {\n                on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(parent_component ? parent_component.$$.context : options.context || []),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.42.6' }, detail), true));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, identity, init, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, src_url_equal, start_hydrating, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n'use strict';\n\nlet logDisabled_ = true;\nlet deprecationWarnings_ = true;\n\n/**\n * Extract browser version out of the provided user agent string.\n *\n * @param {!string} uastring userAgent string.\n * @param {!string} expr Regular expression used as match criteria.\n * @param {!number} pos position in the version string to be returned.\n * @return {!number} browser version.\n */\nexport function extractVersion(uastring, expr, pos) {\n  const match = uastring.match(expr);\n  return match && match.length >= pos && parseInt(match[pos], 10);\n}\n\n// Wraps the peerconnection event eventNameToWrap in a function\n// which returns the modified event object (or false to prevent\n// the event).\nexport function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  const proto = window.RTCPeerConnection.prototype;\n  const nativeAddEventListener = proto.addEventListener;\n  proto.addEventListener = function(nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap) {\n      return nativeAddEventListener.apply(this, arguments);\n    }\n    const wrappedCallback = (e) => {\n      const modifiedEvent = wrapper(e);\n      if (modifiedEvent) {\n        if (cb.handleEvent) {\n          cb.handleEvent(modifiedEvent);\n        } else {\n          cb(modifiedEvent);\n        }\n      }\n    };\n    this._eventMap = this._eventMap || {};\n    if (!this._eventMap[eventNameToWrap]) {\n      this._eventMap[eventNameToWrap] = new Map();\n    }\n    this._eventMap[eventNameToWrap].set(cb, wrappedCallback);\n    return nativeAddEventListener.apply(this, [nativeEventName,\n      wrappedCallback]);\n  };\n\n  const nativeRemoveEventListener = proto.removeEventListener;\n  proto.removeEventListener = function(nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap || !this._eventMap\n        || !this._eventMap[eventNameToWrap]) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n    if (!this._eventMap[eventNameToWrap].has(cb)) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n    const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);\n    this._eventMap[eventNameToWrap].delete(cb);\n    if (this._eventMap[eventNameToWrap].size === 0) {\n      delete this._eventMap[eventNameToWrap];\n    }\n    if (Object.keys(this._eventMap).length === 0) {\n      delete this._eventMap;\n    }\n    return nativeRemoveEventListener.apply(this, [nativeEventName,\n      unwrappedCb]);\n  };\n\n  Object.defineProperty(proto, 'on' + eventNameToWrap, {\n    get() {\n      return this['_on' + eventNameToWrap];\n    },\n    set(cb) {\n      if (this['_on' + eventNameToWrap]) {\n        this.removeEventListener(eventNameToWrap,\n            this['_on' + eventNameToWrap]);\n        delete this['_on' + eventNameToWrap];\n      }\n      if (cb) {\n        this.addEventListener(eventNameToWrap,\n            this['_on' + eventNameToWrap] = cb);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n}\n\nexport function disableLog(bool) {\n  if (typeof bool !== 'boolean') {\n    return new Error('Argument type: ' + typeof bool +\n        '. Please use a boolean.');\n  }\n  logDisabled_ = bool;\n  return (bool) ? 'adapter.js logging disabled' :\n      'adapter.js logging enabled';\n}\n\n/**\n * Disable or enable deprecation warnings\n * @param {!boolean} bool set to true to disable warnings.\n */\nexport function disableWarnings(bool) {\n  if (typeof bool !== 'boolean') {\n    return new Error('Argument type: ' + typeof bool +\n        '. Please use a boolean.');\n  }\n  deprecationWarnings_ = !bool;\n  return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');\n}\n\nexport function log() {\n  if (typeof window === 'object') {\n    if (logDisabled_) {\n      return;\n    }\n    if (typeof console !== 'undefined' && typeof console.log === 'function') {\n      console.log.apply(console, arguments);\n    }\n  }\n}\n\n/**\n * Shows a deprecation warning suggesting the modern and spec-compatible API.\n */\nexport function deprecated(oldMethod, newMethod) {\n  if (!deprecationWarnings_) {\n    return;\n  }\n  console.warn(oldMethod + ' is deprecated, please use ' + newMethod +\n      ' instead.');\n}\n\n/**\n * Browser detector.\n *\n * @return {object} result containing browser and version\n *     properties.\n */\nexport function detectBrowser(window) {\n  // Returned result object.\n  const result = {browser: null, version: null};\n\n  // Fail early if it's not a browser\n  if (typeof window === 'undefined' || !window.navigator) {\n    result.browser = 'Not a browser.';\n    return result;\n  }\n\n  const {navigator} = window;\n\n  if (navigator.mozGetUserMedia) { // Firefox.\n    result.browser = 'firefox';\n    result.version = extractVersion(navigator.userAgent,\n        /Firefox\\/(\\d+)\\./, 1);\n  } else if (navigator.webkitGetUserMedia ||\n      (window.isSecureContext === false && window.webkitRTCPeerConnection &&\n       !window.RTCIceGatherer)) {\n    // Chrome, Chromium, Webview, Opera.\n    // Version matches Chrome/WebRTC version.\n    // Chrome 74 removed webkitGetUserMedia on http as well so we need the\n    // more complicated fallback to webkitRTCPeerConnection.\n    result.browser = 'chrome';\n    result.version = extractVersion(navigator.userAgent,\n        /Chrom(e|ium)\\/(\\d+)\\./, 2);\n  } else if (window.RTCPeerConnection &&\n      navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) { // Safari.\n    result.browser = 'safari';\n    result.version = extractVersion(navigator.userAgent,\n        /AppleWebKit\\/(\\d+)\\./, 1);\n    result.supportsUnifiedPlan = window.RTCRtpTransceiver &&\n        'currentDirection' in window.RTCRtpTransceiver.prototype;\n  } else { // Default fallthrough: not supported.\n    result.browser = 'Not a supported browser.';\n    return result;\n  }\n\n  return result;\n}\n\n/**\n * Checks if something is an object.\n *\n * @param {*} val The something you want to check.\n * @return true if val is an object, false otherwise.\n */\nfunction isObject(val) {\n  return Object.prototype.toString.call(val) === '[object Object]';\n}\n\n/**\n * Remove all empty objects and undefined values\n * from a nested object -- an enhanced and vanilla version\n * of Lodash's `compact`.\n */\nexport function compactObject(data) {\n  if (!isObject(data)) {\n    return data;\n  }\n\n  return Object.keys(data).reduce(function(accumulator, key) {\n    const isObj = isObject(data[key]);\n    const value = isObj ? compactObject(data[key]) : data[key];\n    const isEmptyObject = isObj && !Object.keys(value).length;\n    if (value === undefined || isEmptyObject) {\n      return accumulator;\n    }\n    return Object.assign(accumulator, {[key]: value});\n  }, {});\n}\n\n/* iterates the stats graph recursively. */\nexport function walkStats(stats, base, resultSet) {\n  if (!base || resultSet.has(base.id)) {\n    return;\n  }\n  resultSet.set(base.id, base);\n  Object.keys(base).forEach(name => {\n    if (name.endsWith('Id')) {\n      walkStats(stats, stats.get(base[name]), resultSet);\n    } else if (name.endsWith('Ids')) {\n      base[name].forEach(id => {\n        walkStats(stats, stats.get(id), resultSet);\n      });\n    }\n  });\n}\n\n/* filter getStats for a sender/receiver track. */\nexport function filterStats(result, track, outbound) {\n  const streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';\n  const filteredResult = new Map();\n  if (track === null) {\n    return filteredResult;\n  }\n  const trackStats = [];\n  result.forEach(value => {\n    if (value.type === 'track' &&\n        value.trackIdentifier === track.id) {\n      trackStats.push(value);\n    }\n  });\n  trackStats.forEach(trackStat => {\n    result.forEach(stats => {\n      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\n        walkStats(result, stats, filteredResult);\n      }\n    });\n  });\n  return filteredResult;\n}\n\n","/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\nimport * as utils from '../utils.js';\nconst logging = utils.log;\n\nexport function shimGetUserMedia(window, browserDetails) {\n  const navigator = window && window.navigator;\n\n  if (!navigator.mediaDevices) {\n    return;\n  }\n\n  const constraintsToChrome_ = function(c) {\n    if (typeof c !== 'object' || c.mandatory || c.optional) {\n      return c;\n    }\n    const cc = {};\n    Object.keys(c).forEach(key => {\n      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n        return;\n      }\n      const r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};\n      if (r.exact !== undefined && typeof r.exact === 'number') {\n        r.min = r.max = r.exact;\n      }\n      const oldname_ = function(prefix, name) {\n        if (prefix) {\n          return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n        }\n        return (name === 'deviceId') ? 'sourceId' : name;\n      };\n      if (r.ideal !== undefined) {\n        cc.optional = cc.optional || [];\n        let oc = {};\n        if (typeof r.ideal === 'number') {\n          oc[oldname_('min', key)] = r.ideal;\n          cc.optional.push(oc);\n          oc = {};\n          oc[oldname_('max', key)] = r.ideal;\n          cc.optional.push(oc);\n        } else {\n          oc[oldname_('', key)] = r.ideal;\n          cc.optional.push(oc);\n        }\n      }\n      if (r.exact !== undefined && typeof r.exact !== 'number') {\n        cc.mandatory = cc.mandatory || {};\n        cc.mandatory[oldname_('', key)] = r.exact;\n      } else {\n        ['min', 'max'].forEach(mix => {\n          if (r[mix] !== undefined) {\n            cc.mandatory = cc.mandatory || {};\n            cc.mandatory[oldname_(mix, key)] = r[mix];\n          }\n        });\n      }\n    });\n    if (c.advanced) {\n      cc.optional = (cc.optional || []).concat(c.advanced);\n    }\n    return cc;\n  };\n\n  const shimConstraints_ = function(constraints, func) {\n    if (browserDetails.version >= 61) {\n      return func(constraints);\n    }\n    constraints = JSON.parse(JSON.stringify(constraints));\n    if (constraints && typeof constraints.audio === 'object') {\n      const remap = function(obj, a, b) {\n        if (a in obj && !(b in obj)) {\n          obj[b] = obj[a];\n          delete obj[a];\n        }\n      };\n      constraints = JSON.parse(JSON.stringify(constraints));\n      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');\n      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');\n      constraints.audio = constraintsToChrome_(constraints.audio);\n    }\n    if (constraints && typeof constraints.video === 'object') {\n      // Shim facingMode for mobile & surface pro.\n      let face = constraints.video.facingMode;\n      face = face && ((typeof face === 'object') ? face : {ideal: face});\n      const getSupportedFacingModeLies = browserDetails.version < 66;\n\n      if ((face && (face.exact === 'user' || face.exact === 'environment' ||\n                    face.ideal === 'user' || face.ideal === 'environment')) &&\n          !(navigator.mediaDevices.getSupportedConstraints &&\n            navigator.mediaDevices.getSupportedConstraints().facingMode &&\n            !getSupportedFacingModeLies)) {\n        delete constraints.video.facingMode;\n        let matches;\n        if (face.exact === 'environment' || face.ideal === 'environment') {\n          matches = ['back', 'rear'];\n        } else if (face.exact === 'user' || face.ideal === 'user') {\n          matches = ['front'];\n        }\n        if (matches) {\n          // Look for matches in label, or use last cam for back (typical).\n          return navigator.mediaDevices.enumerateDevices()\n          .then(devices => {\n            devices = devices.filter(d => d.kind === 'videoinput');\n            let dev = devices.find(d => matches.some(match =>\n              d.label.toLowerCase().includes(match)));\n            if (!dev && devices.length && matches.includes('back')) {\n              dev = devices[devices.length - 1]; // more likely the back cam\n            }\n            if (dev) {\n              constraints.video.deviceId = face.exact ? {exact: dev.deviceId} :\n                                                        {ideal: dev.deviceId};\n            }\n            constraints.video = constraintsToChrome_(constraints.video);\n            logging('chrome: ' + JSON.stringify(constraints));\n            return func(constraints);\n          });\n        }\n      }\n      constraints.video = constraintsToChrome_(constraints.video);\n    }\n    logging('chrome: ' + JSON.stringify(constraints));\n    return func(constraints);\n  };\n\n  const shimError_ = function(e) {\n    if (browserDetails.version >= 64) {\n      return e;\n    }\n    return {\n      name: {\n        PermissionDeniedError: 'NotAllowedError',\n        PermissionDismissedError: 'NotAllowedError',\n        InvalidStateError: 'NotAllowedError',\n        DevicesNotFoundError: 'NotFoundError',\n        ConstraintNotSatisfiedError: 'OverconstrainedError',\n        TrackStartError: 'NotReadableError',\n        MediaDeviceFailedDueToShutdown: 'NotAllowedError',\n        MediaDeviceKillSwitchOn: 'NotAllowedError',\n        TabCaptureError: 'AbortError',\n        ScreenCaptureError: 'AbortError',\n        DeviceCaptureError: 'AbortError'\n      }[e.name] || e.name,\n      message: e.message,\n      constraint: e.constraint || e.constraintName,\n      toString() {\n        return this.name + (this.message && ': ') + this.message;\n      }\n    };\n  };\n\n  const getUserMedia_ = function(constraints, onSuccess, onError) {\n    shimConstraints_(constraints, c => {\n      navigator.webkitGetUserMedia(c, onSuccess, e => {\n        if (onError) {\n          onError(shimError_(e));\n        }\n      });\n    });\n  };\n  navigator.getUserMedia = getUserMedia_.bind(navigator);\n\n  // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\n  // function which returns a Promise, it does not accept spec-style\n  // constraints.\n  if (navigator.mediaDevices.getUserMedia) {\n    const origGetUserMedia = navigator.mediaDevices.getUserMedia.\n        bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function(cs) {\n      return shimConstraints_(cs, c => origGetUserMedia(c).then(stream => {\n        if (c.audio && !stream.getAudioTracks().length ||\n            c.video && !stream.getVideoTracks().length) {\n          stream.getTracks().forEach(track => {\n            track.stop();\n          });\n          throw new DOMException('', 'NotFoundError');\n        }\n        return stream;\n      }, e => Promise.reject(shimError_(e))));\n    };\n  }\n}\n","/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n'use strict';\nimport * as utils from '../utils.js';\n\nexport {shimGetUserMedia} from './getusermedia';\nexport {shimGetDisplayMedia} from './getdisplaymedia';\n\nexport function shimMediaStream(window) {\n  window.MediaStream = window.MediaStream || window.webkitMediaStream;\n}\n\nexport function shimOnTrack(window) {\n  if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\n      window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n      get() {\n        return this._ontrack;\n      },\n      set(f) {\n        if (this._ontrack) {\n          this.removeEventListener('track', this._ontrack);\n        }\n        this.addEventListener('track', this._ontrack = f);\n      },\n      enumerable: true,\n      configurable: true\n    });\n    const origSetRemoteDescription =\n        window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription =\n      function setRemoteDescription() {\n        if (!this._ontrackpoly) {\n          this._ontrackpoly = (e) => {\n            // onaddstream does not fire when a track is added to an existing\n            // stream. But stream.onaddtrack is implemented so we use that.\n            e.stream.addEventListener('addtrack', te => {\n              let receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = this.getReceivers()\n                  .find(r => r.track && r.track.id === te.track.id);\n              } else {\n                receiver = {track: te.track};\n              }\n\n              const event = new Event('track');\n              event.track = te.track;\n              event.receiver = receiver;\n              event.transceiver = {receiver};\n              event.streams = [e.stream];\n              this.dispatchEvent(event);\n            });\n            e.stream.getTracks().forEach(track => {\n              let receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = this.getReceivers()\n                  .find(r => r.track && r.track.id === track.id);\n              } else {\n                receiver = {track};\n              }\n              const event = new Event('track');\n              event.track = track;\n              event.receiver = receiver;\n              event.transceiver = {receiver};\n              event.streams = [e.stream];\n              this.dispatchEvent(event);\n            });\n          };\n          this.addEventListener('addstream', this._ontrackpoly);\n        }\n        return origSetRemoteDescription.apply(this, arguments);\n      };\n  } else {\n    // even if RTCRtpTransceiver is in window, it is only used and\n    // emitted in unified-plan. Unfortunately this means we need\n    // to unconditionally wrap the event.\n    utils.wrapPeerConnectionEvent(window, 'track', e => {\n      if (!e.transceiver) {\n        Object.defineProperty(e, 'transceiver',\n          {value: {receiver: e.receiver}});\n      }\n      return e;\n    });\n  }\n}\n\nexport function shimGetSendersWithDtmf(window) {\n  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n  if (typeof window === 'object' && window.RTCPeerConnection &&\n      !('getSenders' in window.RTCPeerConnection.prototype) &&\n      'createDTMFSender' in window.RTCPeerConnection.prototype) {\n    const shimSenderWithDtmf = function(pc, track) {\n      return {\n        track,\n        get dtmf() {\n          if (this._dtmf === undefined) {\n            if (track.kind === 'audio') {\n              this._dtmf = pc.createDTMFSender(track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        },\n        _pc: pc\n      };\n    };\n\n    // augment addTrack when getSenders is not available.\n    if (!window.RTCPeerConnection.prototype.getSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        this._senders = this._senders || [];\n        return this._senders.slice(); // return a copy of the internal state.\n      };\n      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n      window.RTCPeerConnection.prototype.addTrack =\n        function addTrack(track, stream) {\n          let sender = origAddTrack.apply(this, arguments);\n          if (!sender) {\n            sender = shimSenderWithDtmf(this, track);\n            this._senders.push(sender);\n          }\n          return sender;\n        };\n\n      const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n      window.RTCPeerConnection.prototype.removeTrack =\n        function removeTrack(sender) {\n          origRemoveTrack.apply(this, arguments);\n          const idx = this._senders.indexOf(sender);\n          if (idx !== -1) {\n            this._senders.splice(idx, 1);\n          }\n        };\n    }\n    const origAddStream = window.RTCPeerConnection.prototype.addStream;\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      this._senders = this._senders || [];\n      origAddStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        this._senders.push(shimSenderWithDtmf(this, track));\n      });\n    };\n\n    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n    window.RTCPeerConnection.prototype.removeStream =\n      function removeStream(stream) {\n        this._senders = this._senders || [];\n        origRemoveStream.apply(this, [stream]);\n\n        stream.getTracks().forEach(track => {\n          const sender = this._senders.find(s => s.track === track);\n          if (sender) { // remove sender\n            this._senders.splice(this._senders.indexOf(sender), 1);\n          }\n        });\n      };\n  } else if (typeof window === 'object' && window.RTCPeerConnection &&\n             'getSenders' in window.RTCPeerConnection.prototype &&\n             'createDTMFSender' in window.RTCPeerConnection.prototype &&\n             window.RTCRtpSender &&\n             !('dtmf' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n\n    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n      get() {\n        if (this._dtmf === undefined) {\n          if (this.track.kind === 'audio') {\n            this._dtmf = this._pc.createDTMFSender(this.track);\n          } else {\n            this._dtmf = null;\n          }\n        }\n        return this._dtmf;\n      }\n    });\n  }\n}\n\nexport function shimGetStats(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    const [selector, onSucc, onErr] = arguments;\n\n    // If selector is a function then we are in the old style stats so just\n    // pass back the original getStats format to avoid breaking old users.\n    if (arguments.length > 0 && typeof selector === 'function') {\n      return origGetStats.apply(this, arguments);\n    }\n\n    // When spec-style getStats is supported, return those when called with\n    // either no arguments or the selector argument is null.\n    if (origGetStats.length === 0 && (arguments.length === 0 ||\n        typeof selector !== 'function')) {\n      return origGetStats.apply(this, []);\n    }\n\n    const fixChromeStats_ = function(response) {\n      const standardReport = {};\n      const reports = response.result();\n      reports.forEach(report => {\n        const standardStats = {\n          id: report.id,\n          timestamp: report.timestamp,\n          type: {\n            localcandidate: 'local-candidate',\n            remotecandidate: 'remote-candidate'\n          }[report.type] || report.type\n        };\n        report.names().forEach(name => {\n          standardStats[name] = report.stat(name);\n        });\n        standardReport[standardStats.id] = standardStats;\n      });\n\n      return standardReport;\n    };\n\n    // shim getStats with maplike support\n    const makeMapStats = function(stats) {\n      return new Map(Object.keys(stats).map(key => [key, stats[key]]));\n    };\n\n    if (arguments.length >= 2) {\n      const successCallbackWrapper_ = function(response) {\n        onSucc(makeMapStats(fixChromeStats_(response)));\n      };\n\n      return origGetStats.apply(this, [successCallbackWrapper_,\n        selector]);\n    }\n\n    // promise-support\n    return new Promise((resolve, reject) => {\n      origGetStats.apply(this, [\n        function(response) {\n          resolve(makeMapStats(fixChromeStats_(response)));\n        }, reject]);\n    }).then(onSucc, onErr);\n  };\n}\n\nexport function shimSenderReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection &&\n      window.RTCRtpSender && window.RTCRtpReceiver)) {\n    return;\n  }\n\n  // shim sender stats.\n  if (!('getStats' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        const senders = origGetSenders.apply(this, []);\n        senders.forEach(sender => sender._pc = this);\n        return senders;\n      };\n    }\n\n    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n      window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n        const sender = origAddTrack.apply(this, arguments);\n        sender._pc = this;\n        return sender;\n      };\n    }\n    window.RTCRtpSender.prototype.getStats = function getStats() {\n      const sender = this;\n      return this._pc.getStats().then(result =>\n        /* Note: this will include stats of all senders that\n         *   send a track with the same id as sender.track as\n         *   it is not possible to identify the RTCRtpSender.\n         */\n        utils.filterStats(result, sender.track, true));\n    };\n  }\n\n  // shim receiver stats.\n  if (!('getStats' in window.RTCRtpReceiver.prototype)) {\n    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n      window.RTCPeerConnection.prototype.getReceivers =\n        function getReceivers() {\n          const receivers = origGetReceivers.apply(this, []);\n          receivers.forEach(receiver => receiver._pc = this);\n          return receivers;\n        };\n    }\n    utils.wrapPeerConnectionEvent(window, 'track', e => {\n      e.receiver._pc = e.srcElement;\n      return e;\n    });\n    window.RTCRtpReceiver.prototype.getStats = function getStats() {\n      const receiver = this;\n      return this._pc.getStats().then(result =>\n        utils.filterStats(result, receiver.track, false));\n    };\n  }\n\n  if (!('getStats' in window.RTCRtpSender.prototype &&\n      'getStats' in window.RTCRtpReceiver.prototype)) {\n    return;\n  }\n\n  // shim RTCPeerConnection.getStats(track).\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    if (arguments.length > 0 &&\n        arguments[0] instanceof window.MediaStreamTrack) {\n      const track = arguments[0];\n      let sender;\n      let receiver;\n      let err;\n      this.getSenders().forEach(s => {\n        if (s.track === track) {\n          if (sender) {\n            err = true;\n          } else {\n            sender = s;\n          }\n        }\n      });\n      this.getReceivers().forEach(r => {\n        if (r.track === track) {\n          if (receiver) {\n            err = true;\n          } else {\n            receiver = r;\n          }\n        }\n        return r.track === track;\n      });\n      if (err || (sender && receiver)) {\n        return Promise.reject(new DOMException(\n          'There are more than one sender or receiver for the track.',\n          'InvalidAccessError'));\n      } else if (sender) {\n        return sender.getStats();\n      } else if (receiver) {\n        return receiver.getStats();\n      }\n      return Promise.reject(new DOMException(\n        'There is no sender or receiver for the track.',\n        'InvalidAccessError'));\n    }\n    return origGetStats.apply(this, arguments);\n  };\n}\n\nexport function shimAddTrackRemoveTrackWithNative(window) {\n  // shim addTrack/removeTrack with native variants in order to make\n  // the interactions with legacy getLocalStreams behave as in other browsers.\n  // Keeps a mapping stream.id => [stream, rtpsenders...]\n  window.RTCPeerConnection.prototype.getLocalStreams =\n    function getLocalStreams() {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      return Object.keys(this._shimmedLocalStreams)\n        .map(streamId => this._shimmedLocalStreams[streamId][0]);\n    };\n\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n  window.RTCPeerConnection.prototype.addTrack =\n    function addTrack(track, stream) {\n      if (!stream) {\n        return origAddTrack.apply(this, arguments);\n      }\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n      const sender = origAddTrack.apply(this, arguments);\n      if (!this._shimmedLocalStreams[stream.id]) {\n        this._shimmedLocalStreams[stream.id] = [stream, sender];\n      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n        this._shimmedLocalStreams[stream.id].push(sender);\n      }\n      return sender;\n    };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n    });\n    const existingSenders = this.getSenders();\n    origAddStream.apply(this, arguments);\n    const newSenders = this.getSenders()\n      .filter(newSender => existingSenders.indexOf(newSender) === -1);\n    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream =\n    function removeStream(stream) {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      delete this._shimmedLocalStreams[stream.id];\n      return origRemoveStream.apply(this, arguments);\n    };\n\n  const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n  window.RTCPeerConnection.prototype.removeTrack =\n    function removeTrack(sender) {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      if (sender) {\n        Object.keys(this._shimmedLocalStreams).forEach(streamId => {\n          const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n          if (idx !== -1) {\n            this._shimmedLocalStreams[streamId].splice(idx, 1);\n          }\n          if (this._shimmedLocalStreams[streamId].length === 1) {\n            delete this._shimmedLocalStreams[streamId];\n          }\n        });\n      }\n      return origRemoveTrack.apply(this, arguments);\n    };\n}\n\nexport function shimAddTrackRemoveTrack(window, browserDetails) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  // shim addTrack and removeTrack.\n  if (window.RTCPeerConnection.prototype.addTrack &&\n      browserDetails.version >= 65) {\n    return shimAddTrackRemoveTrackWithNative(window);\n  }\n\n  // also shim pc.getLocalStreams when addTrack is shimmed\n  // to return the original streams.\n  const origGetLocalStreams = window.RTCPeerConnection.prototype\n      .getLocalStreams;\n  window.RTCPeerConnection.prototype.getLocalStreams =\n    function getLocalStreams() {\n      const nativeStreams = origGetLocalStreams.apply(this);\n      this._reverseStreams = this._reverseStreams || {};\n      return nativeStreams.map(stream => this._reverseStreams[stream.id]);\n    };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n    });\n    // Add identity mapping for consistency with addTrack.\n    // Unless this is being used with a stream from addTrack.\n    if (!this._reverseStreams[stream.id]) {\n      const newStream = new window.MediaStream(stream.getTracks());\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      stream = newStream;\n    }\n    origAddStream.apply(this, [stream]);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream =\n    function removeStream(stream) {\n      this._streams = this._streams || {};\n      this._reverseStreams = this._reverseStreams || {};\n\n      origRemoveStream.apply(this, [(this._streams[stream.id] || stream)]);\n      delete this._reverseStreams[(this._streams[stream.id] ?\n          this._streams[stream.id].id : stream.id)];\n      delete this._streams[stream.id];\n    };\n\n  window.RTCPeerConnection.prototype.addTrack =\n    function addTrack(track, stream) {\n      if (this.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      const streams = [].slice.call(arguments, 1);\n      if (streams.length !== 1 ||\n          !streams[0].getTracks().find(t => t === track)) {\n        // this is not fully correct but all we can manage without\n        // [[associated MediaStreams]] internal slot.\n        throw new DOMException(\n          'The adapter.js addTrack polyfill only supports a single ' +\n          ' stream which is associated with the specified track.',\n          'NotSupportedError');\n      }\n\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n\n      this._streams = this._streams || {};\n      this._reverseStreams = this._reverseStreams || {};\n      const oldStream = this._streams[stream.id];\n      if (oldStream) {\n        // this is using odd Chrome behaviour, use with caution:\n        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n        // Note: we rely on the high-level addTrack/dtmf shim to\n        // create the sender with a dtmf sender.\n        oldStream.addTrack(track);\n\n        // Trigger ONN async.\n        Promise.resolve().then(() => {\n          this.dispatchEvent(new Event('negotiationneeded'));\n        });\n      } else {\n        const newStream = new window.MediaStream([track]);\n        this._streams[stream.id] = newStream;\n        this._reverseStreams[newStream.id] = stream;\n        this.addStream(newStream);\n      }\n      return this.getSenders().find(s => s.track === track);\n    };\n\n  // replace the internal stream id with the external one and\n  // vice versa.\n  function replaceInternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(internalStream.id, 'g'),\n          externalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  function replaceExternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(externalStream.id, 'g'),\n          internalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  ['createOffer', 'createAnswer'].forEach(function(method) {\n    const nativeMethod = window.RTCPeerConnection.prototype[method];\n    const methodObj = {[method]() {\n      const args = arguments;\n      const isLegacyCall = arguments.length &&\n          typeof arguments[0] === 'function';\n      if (isLegacyCall) {\n        return nativeMethod.apply(this, [\n          (description) => {\n            const desc = replaceInternalStreamId(this, description);\n            args[0].apply(null, [desc]);\n          },\n          (err) => {\n            if (args[1]) {\n              args[1].apply(null, err);\n            }\n          }, arguments[2]\n        ]);\n      }\n      return nativeMethod.apply(this, arguments)\n      .then(description => replaceInternalStreamId(this, description));\n    }};\n    window.RTCPeerConnection.prototype[method] = methodObj[method];\n  });\n\n  const origSetLocalDescription =\n      window.RTCPeerConnection.prototype.setLocalDescription;\n  window.RTCPeerConnection.prototype.setLocalDescription =\n    function setLocalDescription() {\n      if (!arguments.length || !arguments[0].type) {\n        return origSetLocalDescription.apply(this, arguments);\n      }\n      arguments[0] = replaceExternalStreamId(this, arguments[0]);\n      return origSetLocalDescription.apply(this, arguments);\n    };\n\n  // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n\n  const origLocalDescription = Object.getOwnPropertyDescriptor(\n      window.RTCPeerConnection.prototype, 'localDescription');\n  Object.defineProperty(window.RTCPeerConnection.prototype,\n      'localDescription', {\n        get() {\n          const description = origLocalDescription.get.apply(this);\n          if (description.type === '') {\n            return description;\n          }\n          return replaceInternalStreamId(this, description);\n        }\n      });\n\n  window.RTCPeerConnection.prototype.removeTrack =\n    function removeTrack(sender) {\n      if (this.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      // We can not yet check for sender instanceof RTCRtpSender\n      // since we shim RTPSender. So we check if sender._pc is set.\n      if (!sender._pc) {\n        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +\n            'does not implement interface RTCRtpSender.', 'TypeError');\n      }\n      const isLocal = sender._pc === this;\n      if (!isLocal) {\n        throw new DOMException('Sender was not created by this connection.',\n            'InvalidAccessError');\n      }\n\n      // Search for the native stream the senders track belongs to.\n      this._streams = this._streams || {};\n      let stream;\n      Object.keys(this._streams).forEach(streamid => {\n        const hasTrack = this._streams[streamid].getTracks()\n          .find(track => sender.track === track);\n        if (hasTrack) {\n          stream = this._streams[streamid];\n        }\n      });\n\n      if (stream) {\n        if (stream.getTracks().length === 1) {\n          // if this is the last track of the stream, remove the stream. This\n          // takes care of any shimmed _senders.\n          this.removeStream(this._reverseStreams[stream.id]);\n        } else {\n          // relying on the same odd chrome behaviour as above.\n          stream.removeTrack(sender.track);\n        }\n        this.dispatchEvent(new Event('negotiationneeded'));\n      }\n    };\n}\n\nexport function shimPeerConnection(window, browserDetails) {\n  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.webkitRTCPeerConnection;\n  }\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n  if (browserDetails.version < 53) {\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n        .forEach(function(method) {\n          const nativeMethod = window.RTCPeerConnection.prototype[method];\n          const methodObj = {[method]() {\n            arguments[0] = new ((method === 'addIceCandidate') ?\n                window.RTCIceCandidate :\n                window.RTCSessionDescription)(arguments[0]);\n            return nativeMethod.apply(this, arguments);\n          }};\n          window.RTCPeerConnection.prototype[method] = methodObj[method];\n        });\n  }\n}\n\n// Attempt to fix ONN in plan-b mode.\nexport function fixNegotiationNeeded(window, browserDetails) {\n  utils.wrapPeerConnectionEvent(window, 'negotiationneeded', e => {\n    const pc = e.target;\n    if (browserDetails.version < 72 || (pc.getConfiguration &&\n        pc.getConfiguration().sdpSemantics === 'plan-b')) {\n      if (pc.signalingState !== 'stable') {\n        return;\n      }\n    }\n    return e;\n  });\n}\n","/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\nexport function shimGetDisplayMedia(window, getSourceId) {\n  if (window.navigator.mediaDevices &&\n    'getDisplayMedia' in window.navigator.mediaDevices) {\n    return;\n  }\n  if (!(window.navigator.mediaDevices)) {\n    return;\n  }\n  // getSourceId is a function that returns a promise resolving with\n  // the sourceId of the screen/window/tab to be shared.\n  if (typeof getSourceId !== 'function') {\n    console.error('shimGetDisplayMedia: getSourceId argument is not ' +\n        'a function');\n    return;\n  }\n  window.navigator.mediaDevices.getDisplayMedia =\n    function getDisplayMedia(constraints) {\n      return getSourceId(constraints)\n        .then(sourceId => {\n          const widthSpecified = constraints.video && constraints.video.width;\n          const heightSpecified = constraints.video &&\n            constraints.video.height;\n          const frameRateSpecified = constraints.video &&\n            constraints.video.frameRate;\n          constraints.video = {\n            mandatory: {\n              chromeMediaSource: 'desktop',\n              chromeMediaSourceId: sourceId,\n              maxFrameRate: frameRateSpecified || 3\n            }\n          };\n          if (widthSpecified) {\n            constraints.video.mandatory.maxWidth = widthSpecified;\n          }\n          if (heightSpecified) {\n            constraints.video.mandatory.maxHeight = heightSpecified;\n          }\n          return window.navigator.mediaDevices.getUserMedia(constraints);\n        });\n    };\n}\n","/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\n\nimport * as utils from '../utils';\n\nexport function shimGetUserMedia(window, browserDetails) {\n  const navigator = window && window.navigator;\n  const MediaStreamTrack = window && window.MediaStreamTrack;\n\n  navigator.getUserMedia = function(constraints, onSuccess, onError) {\n    // Replace Firefox 44+'s deprecation warning with unprefixed version.\n    utils.deprecated('navigator.getUserMedia',\n        'navigator.mediaDevices.getUserMedia');\n    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n  };\n\n  if (!(browserDetails.version > 55 &&\n      'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {\n    const remap = function(obj, a, b) {\n      if (a in obj && !(b in obj)) {\n        obj[b] = obj[a];\n        delete obj[a];\n      }\n    };\n\n    const nativeGetUserMedia = navigator.mediaDevices.getUserMedia.\n        bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function(c) {\n      if (typeof c === 'object' && typeof c.audio === 'object') {\n        c = JSON.parse(JSON.stringify(c));\n        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');\n        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');\n      }\n      return nativeGetUserMedia(c);\n    };\n\n    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {\n      const nativeGetSettings = MediaStreamTrack.prototype.getSettings;\n      MediaStreamTrack.prototype.getSettings = function() {\n        const obj = nativeGetSettings.apply(this, arguments);\n        remap(obj, 'mozAutoGainControl', 'autoGainControl');\n        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');\n        return obj;\n      };\n    }\n\n    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {\n      const nativeApplyConstraints =\n        MediaStreamTrack.prototype.applyConstraints;\n      MediaStreamTrack.prototype.applyConstraints = function(c) {\n        if (this.kind === 'audio' && typeof c === 'object') {\n          c = JSON.parse(JSON.stringify(c));\n          remap(c, 'autoGainControl', 'mozAutoGainControl');\n          remap(c, 'noiseSuppression', 'mozNoiseSuppression');\n        }\n        return nativeApplyConstraints.apply(this, [c]);\n      };\n    }\n  }\n}\n","/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\n\nimport * as utils from '../utils';\nexport {shimGetUserMedia} from './getusermedia';\nexport {shimGetDisplayMedia} from './getdisplaymedia';\n\nexport function shimOnTrack(window) {\n  if (typeof window === 'object' && window.RTCTrackEvent &&\n      ('receiver' in window.RTCTrackEvent.prototype) &&\n      !('transceiver' in window.RTCTrackEvent.prototype)) {\n    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n      get() {\n        return {receiver: this.receiver};\n      }\n    });\n  }\n}\n\nexport function shimPeerConnection(window, browserDetails) {\n  if (typeof window !== 'object' ||\n      !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {\n    return; // probably media.peerconnection.enabled=false in about:config\n  }\n  if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.mozRTCPeerConnection;\n  }\n\n  if (browserDetails.version < 53) {\n    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n        .forEach(function(method) {\n          const nativeMethod = window.RTCPeerConnection.prototype[method];\n          const methodObj = {[method]() {\n            arguments[0] = new ((method === 'addIceCandidate') ?\n                window.RTCIceCandidate :\n                window.RTCSessionDescription)(arguments[0]);\n            return nativeMethod.apply(this, arguments);\n          }};\n          window.RTCPeerConnection.prototype[method] = methodObj[method];\n        });\n  }\n\n  const modernStatsTypes = {\n    inboundrtp: 'inbound-rtp',\n    outboundrtp: 'outbound-rtp',\n    candidatepair: 'candidate-pair',\n    localcandidate: 'local-candidate',\n    remotecandidate: 'remote-candidate'\n  };\n\n  const nativeGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    const [selector, onSucc, onErr] = arguments;\n    return nativeGetStats.apply(this, [selector || null])\n      .then(stats => {\n        if (browserDetails.version < 53 && !onSucc) {\n          // Shim only promise getStats with spec-hyphens in type names\n          // Leave callback version alone; misc old uses of forEach before Map\n          try {\n            stats.forEach(stat => {\n              stat.type = modernStatsTypes[stat.type] || stat.type;\n            });\n          } catch (e) {\n            if (e.name !== 'TypeError') {\n              throw e;\n            }\n            // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish\n            stats.forEach((stat, i) => {\n              stats.set(i, Object.assign({}, stat, {\n                type: modernStatsTypes[stat.type] || stat.type\n              }));\n            });\n          }\n        }\n        return stats;\n      })\n      .then(onSucc, onErr);\n  };\n}\n\nexport function shimSenderGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection &&\n      window.RTCRtpSender)) {\n    return;\n  }\n  if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {\n    return;\n  }\n  const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n  if (origGetSenders) {\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n  }\n\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n  if (origAddTrack) {\n    window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n      const sender = origAddTrack.apply(this, arguments);\n      sender._pc = this;\n      return sender;\n    };\n  }\n  window.RTCRtpSender.prototype.getStats = function getStats() {\n    return this.track ? this._pc.getStats(this.track) :\n        Promise.resolve(new Map());\n  };\n}\n\nexport function shimReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection &&\n      window.RTCRtpSender)) {\n    return;\n  }\n  if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {\n    return;\n  }\n  const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n  if (origGetReceivers) {\n    window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n      const receivers = origGetReceivers.apply(this, []);\n      receivers.forEach(receiver => receiver._pc = this);\n      return receivers;\n    };\n  }\n  utils.wrapPeerConnectionEvent(window, 'track', e => {\n    e.receiver._pc = e.srcElement;\n    return e;\n  });\n  window.RTCRtpReceiver.prototype.getStats = function getStats() {\n    return this._pc.getStats(this.track);\n  };\n}\n\nexport function shimRemoveStream(window) {\n  if (!window.RTCPeerConnection ||\n      'removeStream' in window.RTCPeerConnection.prototype) {\n    return;\n  }\n  window.RTCPeerConnection.prototype.removeStream =\n    function removeStream(stream) {\n      utils.deprecated('removeStream', 'removeTrack');\n      this.getSenders().forEach(sender => {\n        if (sender.track && stream.getTracks().includes(sender.track)) {\n          this.removeTrack(sender);\n        }\n      });\n    };\n}\n\nexport function shimRTCDataChannel(window) {\n  // rename DataChannel to RTCDataChannel (native fix in FF60):\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851\n  if (window.DataChannel && !window.RTCDataChannel) {\n    window.RTCDataChannel = window.DataChannel;\n  }\n}\n\nexport function shimAddTransceiver(window) {\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\n    return;\n  }\n  const origAddTransceiver = window.RTCPeerConnection.prototype.addTransceiver;\n  if (origAddTransceiver) {\n    window.RTCPeerConnection.prototype.addTransceiver =\n      function addTransceiver() {\n        this.setParametersPromises = [];\n        const initParameters = arguments[1];\n        const shouldPerformCheck = initParameters &&\n                                  'sendEncodings' in initParameters;\n        if (shouldPerformCheck) {\n          // If sendEncodings params are provided, validate grammar\n          initParameters.sendEncodings.forEach((encodingParam) => {\n            if ('rid' in encodingParam) {\n              const ridRegex = /^[a-z0-9]{0,16}$/i;\n              if (!ridRegex.test(encodingParam.rid)) {\n                throw new TypeError('Invalid RID value provided.');\n              }\n            }\n            if ('scaleResolutionDownBy' in encodingParam) {\n              if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {\n                throw new RangeError('scale_resolution_down_by must be >= 1.0');\n              }\n            }\n            if ('maxFramerate' in encodingParam) {\n              if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {\n                throw new RangeError('max_framerate must be >= 0.0');\n              }\n            }\n          });\n        }\n        const transceiver = origAddTransceiver.apply(this, arguments);\n        if (shouldPerformCheck) {\n          // Check if the init options were applied. If not we do this in an\n          // asynchronous way and save the promise reference in a global object.\n          // This is an ugly hack, but at the same time is way more robust than\n          // checking the sender parameters before and after the createOffer\n          // Also note that after the createoffer we are not 100% sure that\n          // the params were asynchronously applied so we might miss the\n          // opportunity to recreate offer.\n          const {sender} = transceiver;\n          const params = sender.getParameters();\n          if (!('encodings' in params) ||\n              // Avoid being fooled by patched getParameters() below.\n              (params.encodings.length === 1 &&\n               Object.keys(params.encodings[0]).length === 0)) {\n            params.encodings = initParameters.sendEncodings;\n            sender.sendEncodings = initParameters.sendEncodings;\n            this.setParametersPromises.push(sender.setParameters(params)\n              .then(() => {\n                delete sender.sendEncodings;\n              }).catch(() => {\n                delete sender.sendEncodings;\n              })\n            );\n          }\n        }\n        return transceiver;\n      };\n  }\n}\n\nexport function shimGetParameters(window) {\n  if (!(typeof window === 'object' && window.RTCRtpSender)) {\n    return;\n  }\n  const origGetParameters = window.RTCRtpSender.prototype.getParameters;\n  if (origGetParameters) {\n    window.RTCRtpSender.prototype.getParameters =\n      function getParameters() {\n        const params = origGetParameters.apply(this, arguments);\n        if (!('encodings' in params)) {\n          params.encodings = [].concat(this.sendEncodings || [{}]);\n        }\n        return params;\n      };\n  }\n}\n\nexport function shimCreateOffer(window) {\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\n    return;\n  }\n  const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\n  window.RTCPeerConnection.prototype.createOffer = function createOffer() {\n    if (this.setParametersPromises && this.setParametersPromises.length) {\n      return Promise.all(this.setParametersPromises)\n      .then(() => {\n        return origCreateOffer.apply(this, arguments);\n      })\n      .finally(() => {\n        this.setParametersPromises = [];\n      });\n    }\n    return origCreateOffer.apply(this, arguments);\n  };\n}\n\nexport function shimCreateAnswer(window) {\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\n    return;\n  }\n  const origCreateAnswer = window.RTCPeerConnection.prototype.createAnswer;\n  window.RTCPeerConnection.prototype.createAnswer = function createAnswer() {\n    if (this.setParametersPromises && this.setParametersPromises.length) {\n      return Promise.all(this.setParametersPromises)\n      .then(() => {\n        return origCreateAnswer.apply(this, arguments);\n      })\n      .finally(() => {\n        this.setParametersPromises = [];\n      });\n    }\n    return origCreateAnswer.apply(this, arguments);\n  };\n}\n","/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\n\nexport function shimGetDisplayMedia(window, preferredMediaSource) {\n  if (window.navigator.mediaDevices &&\n    'getDisplayMedia' in window.navigator.mediaDevices) {\n    return;\n  }\n  if (!(window.navigator.mediaDevices)) {\n    return;\n  }\n  window.navigator.mediaDevices.getDisplayMedia =\n    function getDisplayMedia(constraints) {\n      if (!(constraints && constraints.video)) {\n        const err = new DOMException('getDisplayMedia without video ' +\n            'constraints is undefined');\n        err.name = 'NotFoundError';\n        // from https://heycam.github.io/webidl/#idl-DOMException-error-names\n        err.code = 8;\n        return Promise.reject(err);\n      }\n      if (constraints.video === true) {\n        constraints.video = {mediaSource: preferredMediaSource};\n      } else {\n        constraints.video.mediaSource = preferredMediaSource;\n      }\n      return window.navigator.mediaDevices.getUserMedia(constraints);\n    };\n}\n","/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n'use strict';\nimport * as utils from '../utils';\n\nexport function shimLocalStreamsAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.getLocalStreams =\n      function getLocalStreams() {\n        if (!this._localStreams) {\n          this._localStreams = [];\n        }\n        return this._localStreams;\n      };\n  }\n  if (!('addStream' in window.RTCPeerConnection.prototype)) {\n    const _addTrack = window.RTCPeerConnection.prototype.addTrack;\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n      if (!this._localStreams.includes(stream)) {\n        this._localStreams.push(stream);\n      }\n      // Try to emulate Chrome's behaviour of adding in audio-video order.\n      // Safari orders by track id.\n      stream.getAudioTracks().forEach(track => _addTrack.call(this, track,\n        stream));\n      stream.getVideoTracks().forEach(track => _addTrack.call(this, track,\n        stream));\n    };\n\n    window.RTCPeerConnection.prototype.addTrack =\n      function addTrack(track, ...streams) {\n        if (streams) {\n          streams.forEach((stream) => {\n            if (!this._localStreams) {\n              this._localStreams = [stream];\n            } else if (!this._localStreams.includes(stream)) {\n              this._localStreams.push(stream);\n            }\n          });\n        }\n        return _addTrack.apply(this, arguments);\n      };\n  }\n  if (!('removeStream' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.removeStream =\n      function removeStream(stream) {\n        if (!this._localStreams) {\n          this._localStreams = [];\n        }\n        const index = this._localStreams.indexOf(stream);\n        if (index === -1) {\n          return;\n        }\n        this._localStreams.splice(index, 1);\n        const tracks = stream.getTracks();\n        this.getSenders().forEach(sender => {\n          if (tracks.includes(sender.track)) {\n            this.removeTrack(sender);\n          }\n        });\n      };\n  }\n}\n\nexport function shimRemoteStreamsAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.getRemoteStreams =\n      function getRemoteStreams() {\n        return this._remoteStreams ? this._remoteStreams : [];\n      };\n  }\n  if (!('onaddstream' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {\n      get() {\n        return this._onaddstream;\n      },\n      set(f) {\n        if (this._onaddstream) {\n          this.removeEventListener('addstream', this._onaddstream);\n          this.removeEventListener('track', this._onaddstreampoly);\n        }\n        this.addEventListener('addstream', this._onaddstream = f);\n        this.addEventListener('track', this._onaddstreampoly = (e) => {\n          e.streams.forEach(stream => {\n            if (!this._remoteStreams) {\n              this._remoteStreams = [];\n            }\n            if (this._remoteStreams.includes(stream)) {\n              return;\n            }\n            this._remoteStreams.push(stream);\n            const event = new Event('addstream');\n            event.stream = stream;\n            this.dispatchEvent(event);\n          });\n        });\n      }\n    });\n    const origSetRemoteDescription =\n      window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription =\n      function setRemoteDescription() {\n        const pc = this;\n        if (!this._onaddstreampoly) {\n          this.addEventListener('track', this._onaddstreampoly = function(e) {\n            e.streams.forEach(stream => {\n              if (!pc._remoteStreams) {\n                pc._remoteStreams = [];\n              }\n              if (pc._remoteStreams.indexOf(stream) >= 0) {\n                return;\n              }\n              pc._remoteStreams.push(stream);\n              const event = new Event('addstream');\n              event.stream = stream;\n              pc.dispatchEvent(event);\n            });\n          });\n        }\n        return origSetRemoteDescription.apply(pc, arguments);\n      };\n  }\n}\n\nexport function shimCallbacksAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  const prototype = window.RTCPeerConnection.prototype;\n  const origCreateOffer = prototype.createOffer;\n  const origCreateAnswer = prototype.createAnswer;\n  const setLocalDescription = prototype.setLocalDescription;\n  const setRemoteDescription = prototype.setRemoteDescription;\n  const addIceCandidate = prototype.addIceCandidate;\n\n  prototype.createOffer =\n    function createOffer(successCallback, failureCallback) {\n      const options = (arguments.length >= 2) ? arguments[2] : arguments[0];\n      const promise = origCreateOffer.apply(this, [options]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n\n  prototype.createAnswer =\n    function createAnswer(successCallback, failureCallback) {\n      const options = (arguments.length >= 2) ? arguments[2] : arguments[0];\n      const promise = origCreateAnswer.apply(this, [options]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n\n  let withCallback = function(description, successCallback, failureCallback) {\n    const promise = setLocalDescription.apply(this, [description]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.setLocalDescription = withCallback;\n\n  withCallback = function(description, successCallback, failureCallback) {\n    const promise = setRemoteDescription.apply(this, [description]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.setRemoteDescription = withCallback;\n\n  withCallback = function(candidate, successCallback, failureCallback) {\n    const promise = addIceCandidate.apply(this, [candidate]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.addIceCandidate = withCallback;\n}\n\nexport function shimGetUserMedia(window) {\n  const navigator = window && window.navigator;\n\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    // shim not needed in Safari 12.1\n    const mediaDevices = navigator.mediaDevices;\n    const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);\n    navigator.mediaDevices.getUserMedia = (constraints) => {\n      return _getUserMedia(shimConstraints(constraints));\n    };\n  }\n\n  if (!navigator.getUserMedia && navigator.mediaDevices &&\n    navigator.mediaDevices.getUserMedia) {\n    navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {\n      navigator.mediaDevices.getUserMedia(constraints)\n      .then(cb, errcb);\n    }.bind(navigator);\n  }\n}\n\nexport function shimConstraints(constraints) {\n  if (constraints && constraints.video !== undefined) {\n    return Object.assign({},\n      constraints,\n      {video: utils.compactObject(constraints.video)}\n    );\n  }\n\n  return constraints;\n}\n\nexport function shimRTCIceServerUrls(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n  const OrigPeerConnection = window.RTCPeerConnection;\n  window.RTCPeerConnection =\n    function RTCPeerConnection(pcConfig, pcConstraints) {\n      if (pcConfig && pcConfig.iceServers) {\n        const newIceServers = [];\n        for (let i = 0; i < pcConfig.iceServers.length; i++) {\n          let server = pcConfig.iceServers[i];\n          if (!server.hasOwnProperty('urls') &&\n              server.hasOwnProperty('url')) {\n            utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');\n            server = JSON.parse(JSON.stringify(server));\n            server.urls = server.url;\n            delete server.url;\n            newIceServers.push(server);\n          } else {\n            newIceServers.push(pcConfig.iceServers[i]);\n          }\n        }\n        pcConfig.iceServers = newIceServers;\n      }\n      return new OrigPeerConnection(pcConfig, pcConstraints);\n    };\n  window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n  // wrap static methods. Currently just generateCertificate.\n  if ('generateCertificate' in OrigPeerConnection) {\n    Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n      get() {\n        return OrigPeerConnection.generateCertificate;\n      }\n    });\n  }\n}\n\nexport function shimTrackEventTransceiver(window) {\n  // Add event.transceiver member over deprecated event.receiver\n  if (typeof window === 'object' && window.RTCTrackEvent &&\n      'receiver' in window.RTCTrackEvent.prototype &&\n      !('transceiver' in window.RTCTrackEvent.prototype)) {\n    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n      get() {\n        return {receiver: this.receiver};\n      }\n    });\n  }\n}\n\nexport function shimCreateOfferLegacy(window) {\n  const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\n  window.RTCPeerConnection.prototype.createOffer =\n    function createOffer(offerOptions) {\n      if (offerOptions) {\n        if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {\n          // support bit values\n          offerOptions.offerToReceiveAudio =\n            !!offerOptions.offerToReceiveAudio;\n        }\n        const audioTransceiver = this.getTransceivers().find(transceiver =>\n          transceiver.receiver.track.kind === 'audio');\n        if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\n          if (audioTransceiver.direction === 'sendrecv') {\n            if (audioTransceiver.setDirection) {\n              audioTransceiver.setDirection('sendonly');\n            } else {\n              audioTransceiver.direction = 'sendonly';\n            }\n          } else if (audioTransceiver.direction === 'recvonly') {\n            if (audioTransceiver.setDirection) {\n              audioTransceiver.setDirection('inactive');\n            } else {\n              audioTransceiver.direction = 'inactive';\n            }\n          }\n        } else if (offerOptions.offerToReceiveAudio === true &&\n            !audioTransceiver) {\n          this.addTransceiver('audio');\n        }\n\n        if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {\n          // support bit values\n          offerOptions.offerToReceiveVideo =\n            !!offerOptions.offerToReceiveVideo;\n        }\n        const videoTransceiver = this.getTransceivers().find(transceiver =>\n          transceiver.receiver.track.kind === 'video');\n        if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\n          if (videoTransceiver.direction === 'sendrecv') {\n            if (videoTransceiver.setDirection) {\n              videoTransceiver.setDirection('sendonly');\n            } else {\n              videoTransceiver.direction = 'sendonly';\n            }\n          } else if (videoTransceiver.direction === 'recvonly') {\n            if (videoTransceiver.setDirection) {\n              videoTransceiver.setDirection('inactive');\n            } else {\n              videoTransceiver.direction = 'inactive';\n            }\n          }\n        } else if (offerOptions.offerToReceiveVideo === true &&\n            !videoTransceiver) {\n          this.addTransceiver('video');\n        }\n      }\n      return origCreateOffer.apply(this, arguments);\n    };\n}\n\nexport function shimAudioContext(window) {\n  if (typeof window !== 'object' || window.AudioContext) {\n    return;\n  }\n  window.AudioContext = window.webkitAudioContext;\n}\n\n","/* eslint-env node */\n'use strict';\n\n// SDP helpers.\nconst SDPUtils = {};\n\n// Generate an alphanumeric identifier for cname or mids.\n// TODO: use UUIDs instead? https://gist.github.com/jed/982883\nSDPUtils.generateIdentifier = function() {\n  return Math.random().toString(36).substr(2, 10);\n};\n\n// The RTCP CNAME used by all peerconnections from the same JS.\nSDPUtils.localCName = SDPUtils.generateIdentifier();\n\n// Splits SDP into lines, dealing with both CRLF and LF.\nSDPUtils.splitLines = function(blob) {\n  return blob.trim().split('\\n').map(line => line.trim());\n};\n// Splits SDP into sessionpart and mediasections. Ensures CRLF.\nSDPUtils.splitSections = function(blob) {\n  const parts = blob.split('\\nm=');\n  return parts.map((part, index) => (index > 0 ?\n    'm=' + part : part).trim() + '\\r\\n');\n};\n\n// Returns the session description.\nSDPUtils.getDescription = function(blob) {\n  const sections = SDPUtils.splitSections(blob);\n  return sections && sections[0];\n};\n\n// Returns the individual media sections.\nSDPUtils.getMediaSections = function(blob) {\n  const sections = SDPUtils.splitSections(blob);\n  sections.shift();\n  return sections;\n};\n\n// Returns lines that start with a certain prefix.\nSDPUtils.matchPrefix = function(blob, prefix) {\n  return SDPUtils.splitLines(blob).filter(line => line.indexOf(prefix) === 0);\n};\n\n// Parses an ICE candidate line. Sample input:\n// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n// rport 55996\"\n// Input can be prefixed with a=.\nSDPUtils.parseCandidate = function(line) {\n  let parts;\n  // Parse both variants.\n  if (line.indexOf('a=candidate:') === 0) {\n    parts = line.substring(12).split(' ');\n  } else {\n    parts = line.substring(10).split(' ');\n  }\n\n  const candidate = {\n    foundation: parts[0],\n    component: {1: 'rtp', 2: 'rtcp'}[parts[1]] || parts[1],\n    protocol: parts[2].toLowerCase(),\n    priority: parseInt(parts[3], 10),\n    ip: parts[4],\n    address: parts[4], // address is an alias for ip.\n    port: parseInt(parts[5], 10),\n    // skip parts[6] == 'typ'\n    type: parts[7],\n  };\n\n  for (let i = 8; i < parts.length; i += 2) {\n    switch (parts[i]) {\n      case 'raddr':\n        candidate.relatedAddress = parts[i + 1];\n        break;\n      case 'rport':\n        candidate.relatedPort = parseInt(parts[i + 1], 10);\n        break;\n      case 'tcptype':\n        candidate.tcpType = parts[i + 1];\n        break;\n      case 'ufrag':\n        candidate.ufrag = parts[i + 1]; // for backward compatibility.\n        candidate.usernameFragment = parts[i + 1];\n        break;\n      default: // extension handling, in particular ufrag. Don't overwrite.\n        if (candidate[parts[i]] === undefined) {\n          candidate[parts[i]] = parts[i + 1];\n        }\n        break;\n    }\n  }\n  return candidate;\n};\n\n// Translates a candidate object into SDP candidate attribute.\n// This does not include the a= prefix!\nSDPUtils.writeCandidate = function(candidate) {\n  const sdp = [];\n  sdp.push(candidate.foundation);\n\n  const component = candidate.component;\n  if (component === 'rtp') {\n    sdp.push(1);\n  } else if (component === 'rtcp') {\n    sdp.push(2);\n  } else {\n    sdp.push(component);\n  }\n  sdp.push(candidate.protocol.toUpperCase());\n  sdp.push(candidate.priority);\n  sdp.push(candidate.address || candidate.ip);\n  sdp.push(candidate.port);\n\n  const type = candidate.type;\n  sdp.push('typ');\n  sdp.push(type);\n  if (type !== 'host' && candidate.relatedAddress &&\n      candidate.relatedPort) {\n    sdp.push('raddr');\n    sdp.push(candidate.relatedAddress);\n    sdp.push('rport');\n    sdp.push(candidate.relatedPort);\n  }\n  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n    sdp.push('tcptype');\n    sdp.push(candidate.tcpType);\n  }\n  if (candidate.usernameFragment || candidate.ufrag) {\n    sdp.push('ufrag');\n    sdp.push(candidate.usernameFragment || candidate.ufrag);\n  }\n  return 'candidate:' + sdp.join(' ');\n};\n\n// Parses an ice-options line, returns an array of option tags.\n// Sample input:\n// a=ice-options:foo bar\nSDPUtils.parseIceOptions = function(line) {\n  return line.substr(14).split(' ');\n};\n\n// Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n// a=rtpmap:111 opus/48000/2\nSDPUtils.parseRtpMap = function(line) {\n  let parts = line.substr(9).split(' ');\n  const parsed = {\n    payloadType: parseInt(parts.shift(), 10), // was: id\n  };\n\n  parts = parts[0].split('/');\n\n  parsed.name = parts[0];\n  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n  // legacy alias, got renamed back to channels in ORTC.\n  parsed.numChannels = parsed.channels;\n  return parsed;\n};\n\n// Generates a rtpmap line from RTCRtpCodecCapability or\n// RTCRtpCodecParameters.\nSDPUtils.writeRtpMap = function(codec) {\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  const channels = codec.channels || codec.numChannels || 1;\n  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +\n      (channels !== 1 ? '/' + channels : '') + '\\r\\n';\n};\n\n// Parses a extmap line (headerextension from RFC 5285). Sample input:\n// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\nSDPUtils.parseExtmap = function(line) {\n  const parts = line.substr(9).split(' ');\n  return {\n    id: parseInt(parts[0], 10),\n    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\n    uri: parts[1],\n  };\n};\n\n// Generates an extmap line from RTCRtpHeaderExtensionParameters or\n// RTCRtpHeaderExtension.\nSDPUtils.writeExtmap = function(headerExtension) {\n  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +\n      (headerExtension.direction && headerExtension.direction !== 'sendrecv'\n        ? '/' + headerExtension.direction\n        : '') +\n      ' ' + headerExtension.uri + '\\r\\n';\n};\n\n// Parses a fmtp line, returns dictionary. Sample input:\n// a=fmtp:96 vbr=on;cng=on\n// Also deals with vbr=on; cng=on\nSDPUtils.parseFmtp = function(line) {\n  const parsed = {};\n  let kv;\n  const parts = line.substr(line.indexOf(' ') + 1).split(';');\n  for (let j = 0; j < parts.length; j++) {\n    kv = parts[j].trim().split('=');\n    parsed[kv[0].trim()] = kv[1];\n  }\n  return parsed;\n};\n\n// Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeFmtp = function(codec) {\n  let line = '';\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.parameters && Object.keys(codec.parameters).length) {\n    const params = [];\n    Object.keys(codec.parameters).forEach(param => {\n      if (codec.parameters[param] !== undefined) {\n        params.push(param + '=' + codec.parameters[param]);\n      } else {\n        params.push(param);\n      }\n    });\n    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n  }\n  return line;\n};\n\n// Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n// a=rtcp-fb:98 nack rpsi\nSDPUtils.parseRtcpFb = function(line) {\n  const parts = line.substr(line.indexOf(' ') + 1).split(' ');\n  return {\n    type: parts.shift(),\n    parameter: parts.join(' '),\n  };\n};\n\n// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeRtcpFb = function(codec) {\n  let lines = '';\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n    // FIXME: special handling for trr-int?\n    codec.rtcpFeedback.forEach(fb => {\n      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +\n      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +\n          '\\r\\n';\n    });\n  }\n  return lines;\n};\n\n// Parses a RFC 5576 ssrc media attribute. Sample input:\n// a=ssrc:3735928559 cname:something\nSDPUtils.parseSsrcMedia = function(line) {\n  const sp = line.indexOf(' ');\n  const parts = {\n    ssrc: parseInt(line.substr(7, sp - 7), 10),\n  };\n  const colon = line.indexOf(':', sp);\n  if (colon > -1) {\n    parts.attribute = line.substr(sp + 1, colon - sp - 1);\n    parts.value = line.substr(colon + 1);\n  } else {\n    parts.attribute = line.substr(sp + 1);\n  }\n  return parts;\n};\n\n// Parse a ssrc-group line (see RFC 5576). Sample input:\n// a=ssrc-group:semantics 12 34\nSDPUtils.parseSsrcGroup = function(line) {\n  const parts = line.substr(13).split(' ');\n  return {\n    semantics: parts.shift(),\n    ssrcs: parts.map(ssrc => parseInt(ssrc, 10)),\n  };\n};\n\n// Extracts the MID (RFC 5888) from a media section.\n// Returns the MID or undefined if no mid line was found.\nSDPUtils.getMid = function(mediaSection) {\n  const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\n  if (mid) {\n    return mid.substr(6);\n  }\n};\n\n// Parses a fingerprint line for DTLS-SRTP.\nSDPUtils.parseFingerprint = function(line) {\n  const parts = line.substr(14).split(' ');\n  return {\n    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.\n    value: parts[1].toUpperCase(), // the definition is upper-case in RFC 4572.\n  };\n};\n\n// Extracts DTLS parameters from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the fingerprint line as input. See also getIceParameters.\nSDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\n  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=fingerprint:');\n  // Note: a=setup line is ignored since we use the 'auto' role in Edge.\n  return {\n    role: 'auto',\n    fingerprints: lines.map(SDPUtils.parseFingerprint),\n  };\n};\n\n// Serializes DTLS parameters to SDP.\nSDPUtils.writeDtlsParameters = function(params, setupType) {\n  let sdp = 'a=setup:' + setupType + '\\r\\n';\n  params.fingerprints.forEach(fp => {\n    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n  });\n  return sdp;\n};\n\n// Parses a=crypto lines into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members\nSDPUtils.parseCryptoLine = function(line) {\n  const parts = line.substr(9).split(' ');\n  return {\n    tag: parseInt(parts[0], 10),\n    cryptoSuite: parts[1],\n    keyParams: parts[2],\n    sessionParams: parts.slice(3),\n  };\n};\n\nSDPUtils.writeCryptoLine = function(parameters) {\n  return 'a=crypto:' + parameters.tag + ' ' +\n    parameters.cryptoSuite + ' ' +\n    (typeof parameters.keyParams === 'object'\n      ? SDPUtils.writeCryptoKeyParams(parameters.keyParams)\n      : parameters.keyParams) +\n    (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') +\n    '\\r\\n';\n};\n\n// Parses the crypto key parameters into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*\nSDPUtils.parseCryptoKeyParams = function(keyParams) {\n  if (keyParams.indexOf('inline:') !== 0) {\n    return null;\n  }\n  const parts = keyParams.substr(7).split('|');\n  return {\n    keyMethod: 'inline',\n    keySalt: parts[0],\n    lifeTime: parts[1],\n    mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,\n    mkiLength: parts[2] ? parts[2].split(':')[1] : undefined,\n  };\n};\n\nSDPUtils.writeCryptoKeyParams = function(keyParams) {\n  return keyParams.keyMethod + ':'\n    + keyParams.keySalt +\n    (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') +\n    (keyParams.mkiValue && keyParams.mkiLength\n      ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength\n      : '');\n};\n\n// Extracts all SDES parameters.\nSDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {\n  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=crypto:');\n  return lines.map(SDPUtils.parseCryptoLine);\n};\n\n// Parses ICE information from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the ice-ufrag and ice-pwd lines as input.\nSDPUtils.getIceParameters = function(mediaSection, sessionpart) {\n  const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=ice-ufrag:')[0];\n  const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=ice-pwd:')[0];\n  if (!(ufrag && pwd)) {\n    return null;\n  }\n  return {\n    usernameFragment: ufrag.substr(12),\n    password: pwd.substr(10),\n  };\n};\n\n// Serializes ICE parameters to SDP.\nSDPUtils.writeIceParameters = function(params) {\n  let sdp = 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' +\n      'a=ice-pwd:' + params.password + '\\r\\n';\n  if (params.iceLite) {\n    sdp += 'a=ice-lite\\r\\n';\n  }\n  return sdp;\n};\n\n// Parses the SDP media section and returns RTCRtpParameters.\nSDPUtils.parseRtpParameters = function(mediaSection) {\n  const description = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: [],\n    rtcp: [],\n  };\n  const lines = SDPUtils.splitLines(mediaSection);\n  const mline = lines[0].split(' ');\n  for (let i = 3; i < mline.length; i++) { // find all codecs from mline[3..]\n    const pt = mline[i];\n    const rtpmapline = SDPUtils.matchPrefix(\n      mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n    if (rtpmapline) {\n      const codec = SDPUtils.parseRtpMap(rtpmapline);\n      const fmtps = SDPUtils.matchPrefix(\n        mediaSection, 'a=fmtp:' + pt + ' ');\n      // Only the first a=fmtp:<pt> is considered.\n      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n      codec.rtcpFeedback = SDPUtils.matchPrefix(\n        mediaSection, 'a=rtcp-fb:' + pt + ' ')\n        .map(SDPUtils.parseRtcpFb);\n      description.codecs.push(codec);\n      // parse FEC mechanisms from rtpmap lines.\n      switch (codec.name.toUpperCase()) {\n        case 'RED':\n        case 'ULPFEC':\n          description.fecMechanisms.push(codec.name.toUpperCase());\n          break;\n        default: // only RED and ULPFEC are recognized as FEC mechanisms.\n          break;\n      }\n    }\n  }\n  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(line => {\n    description.headerExtensions.push(SDPUtils.parseExtmap(line));\n  });\n  // FIXME: parse rtcp.\n  return description;\n};\n\n// Generates parts of the SDP media section describing the capabilities /\n// parameters.\nSDPUtils.writeRtpDescription = function(kind, caps) {\n  let sdp = '';\n\n  // Build the mline.\n  sdp += 'm=' + kind + ' ';\n  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n  sdp += ' UDP/TLS/RTP/SAVPF ';\n  sdp += caps.codecs.map(codec => {\n    if (codec.preferredPayloadType !== undefined) {\n      return codec.preferredPayloadType;\n    }\n    return codec.payloadType;\n  }).join(' ') + '\\r\\n';\n\n  sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\n\n  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n  caps.codecs.forEach(codec => {\n    sdp += SDPUtils.writeRtpMap(codec);\n    sdp += SDPUtils.writeFmtp(codec);\n    sdp += SDPUtils.writeRtcpFb(codec);\n  });\n  let maxptime = 0;\n  caps.codecs.forEach(codec => {\n    if (codec.maxptime > maxptime) {\n      maxptime = codec.maxptime;\n    }\n  });\n  if (maxptime > 0) {\n    sdp += 'a=maxptime:' + maxptime + '\\r\\n';\n  }\n\n  if (caps.headerExtensions) {\n    caps.headerExtensions.forEach(extension => {\n      sdp += SDPUtils.writeExtmap(extension);\n    });\n  }\n  // FIXME: write fecMechanisms.\n  return sdp;\n};\n\n// Parses the SDP media section and returns an array of\n// RTCRtpEncodingParameters.\nSDPUtils.parseRtpEncodingParameters = function(mediaSection) {\n  const encodingParameters = [];\n  const description = SDPUtils.parseRtpParameters(mediaSection);\n  const hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n  const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\n\n  // filter a=ssrc:... cname:, ignore PlanB-msid\n  const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(line => SDPUtils.parseSsrcMedia(line))\n    .filter(parts => parts.attribute === 'cname');\n  const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n  let secondarySsrc;\n\n  const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')\n    .map(line => {\n      const parts = line.substr(17).split(' ');\n      return parts.map(part => parseInt(part, 10));\n    });\n  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n    secondarySsrc = flows[0][1];\n  }\n\n  description.codecs.forEach(codec => {\n    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n      let encParam = {\n        ssrc: primarySsrc,\n        codecPayloadType: parseInt(codec.parameters.apt, 10),\n      };\n      if (primarySsrc && secondarySsrc) {\n        encParam.rtx = {ssrc: secondarySsrc};\n      }\n      encodingParameters.push(encParam);\n      if (hasRed) {\n        encParam = JSON.parse(JSON.stringify(encParam));\n        encParam.fec = {\n          ssrc: primarySsrc,\n          mechanism: hasUlpfec ? 'red+ulpfec' : 'red',\n        };\n        encodingParameters.push(encParam);\n      }\n    }\n  });\n  if (encodingParameters.length === 0 && primarySsrc) {\n    encodingParameters.push({\n      ssrc: primarySsrc,\n    });\n  }\n\n  // we support both b=AS and b=TIAS but interpret AS as TIAS.\n  let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n  if (bandwidth.length) {\n    if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n      bandwidth = parseInt(bandwidth[0].substr(7), 10);\n    } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n      // use formula from JSEP to convert b=AS to TIAS value.\n      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95\n          - (50 * 40 * 8);\n    } else {\n      bandwidth = undefined;\n    }\n    encodingParameters.forEach(params => {\n      params.maxBitrate = bandwidth;\n    });\n  }\n  return encodingParameters;\n};\n\n// parses http://draft.ortc.org/#rtcrtcpparameters*\nSDPUtils.parseRtcpParameters = function(mediaSection) {\n  const rtcpParameters = {};\n\n  // Gets the first SSRC. Note that with RTX there might be multiple\n  // SSRCs.\n  const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(line => SDPUtils.parseSsrcMedia(line))\n    .filter(obj => obj.attribute === 'cname')[0];\n  if (remoteSsrc) {\n    rtcpParameters.cname = remoteSsrc.value;\n    rtcpParameters.ssrc = remoteSsrc.ssrc;\n  }\n\n  // Edge uses the compound attribute instead of reducedSize\n  // compound is !reducedSize\n  const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\n  rtcpParameters.reducedSize = rsize.length > 0;\n  rtcpParameters.compound = rsize.length === 0;\n\n  // parses the rtcp-mux attrіbute.\n  // Note that Edge does not support unmuxed RTCP.\n  const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\n  rtcpParameters.mux = mux.length > 0;\n\n  return rtcpParameters;\n};\n\nSDPUtils.writeRtcpParameters = function(rtcpParameters) {\n  let sdp = '';\n  if (rtcpParameters.reducedSize) {\n    sdp += 'a=rtcp-rsize\\r\\n';\n  }\n  if (rtcpParameters.mux) {\n    sdp += 'a=rtcp-mux\\r\\n';\n  }\n  if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {\n    sdp += 'a=ssrc:' + rtcpParameters.ssrc +\n      ' cname:' + rtcpParameters.cname + '\\r\\n';\n  }\n  return sdp;\n};\n\n\n// parses either a=msid: or a=ssrc:... msid lines and returns\n// the id of the MediaStream and MediaStreamTrack.\nSDPUtils.parseMsid = function(mediaSection) {\n  let parts;\n  const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\n  if (spec.length === 1) {\n    parts = spec[0].substr(7).split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n  const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(line => SDPUtils.parseSsrcMedia(line))\n    .filter(msidParts => msidParts.attribute === 'msid');\n  if (planB.length > 0) {\n    parts = planB[0].value.split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n};\n\n// SCTP\n// parses draft-ietf-mmusic-sctp-sdp-26 first and falls back\n// to draft-ietf-mmusic-sctp-sdp-05\nSDPUtils.parseSctpDescription = function(mediaSection) {\n  const mline = SDPUtils.parseMLine(mediaSection);\n  const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');\n  let maxMessageSize;\n  if (maxSizeLine.length > 0) {\n    maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);\n  }\n  if (isNaN(maxMessageSize)) {\n    maxMessageSize = 65536;\n  }\n  const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');\n  if (sctpPort.length > 0) {\n    return {\n      port: parseInt(sctpPort[0].substr(12), 10),\n      protocol: mline.fmt,\n      maxMessageSize,\n    };\n  }\n  const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');\n  if (sctpMapLines.length > 0) {\n    const parts = sctpMapLines[0]\n      .substr(10)\n      .split(' ');\n    return {\n      port: parseInt(parts[0], 10),\n      protocol: parts[1],\n      maxMessageSize,\n    };\n  }\n};\n\n// SCTP\n// outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers\n// support by now receiving in this format, unless we originally parsed\n// as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line\n// protocol of DTLS/SCTP -- without UDP/ or TCP/)\nSDPUtils.writeSctpDescription = function(media, sctp) {\n  let output = [];\n  if (media.protocol !== 'DTLS/SCTP') {\n    output = [\n      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\\r\\n',\n      'c=IN IP4 0.0.0.0\\r\\n',\n      'a=sctp-port:' + sctp.port + '\\r\\n',\n    ];\n  } else {\n    output = [\n      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\\r\\n',\n      'c=IN IP4 0.0.0.0\\r\\n',\n      'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\\r\\n',\n    ];\n  }\n  if (sctp.maxMessageSize !== undefined) {\n    output.push('a=max-message-size:' + sctp.maxMessageSize + '\\r\\n');\n  }\n  return output.join('');\n};\n\n// Generate a session ID for SDP.\n// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n// recommends using a cryptographically random +ve 64-bit value\n// but right now this should be acceptable and within the right range\nSDPUtils.generateSessionId = function() {\n  return Math.random().toString().substr(2, 21);\n};\n\n// Write boiler plate for start of SDP\n// sessId argument is optional - if not supplied it will\n// be generated randomly\n// sessVersion is optional and defaults to 2\n// sessUser is optional and defaults to 'thisisadapterortc'\nSDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {\n  let sessionId;\n  const version = sessVer !== undefined ? sessVer : 2;\n  if (sessId) {\n    sessionId = sessId;\n  } else {\n    sessionId = SDPUtils.generateSessionId();\n  }\n  const user = sessUser || 'thisisadapterortc';\n  // FIXME: sess-id should be an NTP timestamp.\n  return 'v=0\\r\\n' +\n      'o=' + user + ' ' + sessionId + ' ' + version +\n        ' IN IP4 127.0.0.1\\r\\n' +\n      's=-\\r\\n' +\n      't=0 0\\r\\n';\n};\n\n// Gets the direction from the mediaSection or the sessionpart.\nSDPUtils.getDirection = function(mediaSection, sessionpart) {\n  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n  const lines = SDPUtils.splitLines(mediaSection);\n  for (let i = 0; i < lines.length; i++) {\n    switch (lines[i]) {\n      case 'a=sendrecv':\n      case 'a=sendonly':\n      case 'a=recvonly':\n      case 'a=inactive':\n        return lines[i].substr(2);\n      default:\n        // FIXME: What should happen here?\n    }\n  }\n  if (sessionpart) {\n    return SDPUtils.getDirection(sessionpart);\n  }\n  return 'sendrecv';\n};\n\nSDPUtils.getKind = function(mediaSection) {\n  const lines = SDPUtils.splitLines(mediaSection);\n  const mline = lines[0].split(' ');\n  return mline[0].substr(2);\n};\n\nSDPUtils.isRejected = function(mediaSection) {\n  return mediaSection.split(' ', 2)[1] === '0';\n};\n\nSDPUtils.parseMLine = function(mediaSection) {\n  const lines = SDPUtils.splitLines(mediaSection);\n  const parts = lines[0].substr(2).split(' ');\n  return {\n    kind: parts[0],\n    port: parseInt(parts[1], 10),\n    protocol: parts[2],\n    fmt: parts.slice(3).join(' '),\n  };\n};\n\nSDPUtils.parseOLine = function(mediaSection) {\n  const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\n  const parts = line.substr(2).split(' ');\n  return {\n    username: parts[0],\n    sessionId: parts[1],\n    sessionVersion: parseInt(parts[2], 10),\n    netType: parts[3],\n    addressType: parts[4],\n    address: parts[5],\n  };\n};\n\n// a very naive interpretation of a valid SDP.\nSDPUtils.isValidSDP = function(blob) {\n  if (typeof blob !== 'string' || blob.length === 0) {\n    return false;\n  }\n  const lines = SDPUtils.splitLines(blob);\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {\n      return false;\n    }\n    // TODO: check the modifier a bit more.\n  }\n  return true;\n};\n\n// Expose public methods.\nif (typeof module === 'object') {\n  module.exports = SDPUtils;\n}\n","/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\n\nimport SDPUtils from 'sdp';\nimport * as utils from './utils';\n\nexport function shimRTCIceCandidate(window) {\n  // foundation is arbitrarily chosen as an indicator for full support for\n  // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface\n  if (!window.RTCIceCandidate || (window.RTCIceCandidate && 'foundation' in\n      window.RTCIceCandidate.prototype)) {\n    return;\n  }\n\n  const NativeRTCIceCandidate = window.RTCIceCandidate;\n  window.RTCIceCandidate = function RTCIceCandidate(args) {\n    // Remove the a= which shouldn't be part of the candidate string.\n    if (typeof args === 'object' && args.candidate &&\n        args.candidate.indexOf('a=') === 0) {\n      args = JSON.parse(JSON.stringify(args));\n      args.candidate = args.candidate.substr(2);\n    }\n\n    if (args.candidate && args.candidate.length) {\n      // Augment the native candidate with the parsed fields.\n      const nativeCandidate = new NativeRTCIceCandidate(args);\n      const parsedCandidate = SDPUtils.parseCandidate(args.candidate);\n      const augmentedCandidate = Object.assign(nativeCandidate,\n          parsedCandidate);\n\n      // Add a serializer that does not serialize the extra attributes.\n      augmentedCandidate.toJSON = function toJSON() {\n        return {\n          candidate: augmentedCandidate.candidate,\n          sdpMid: augmentedCandidate.sdpMid,\n          sdpMLineIndex: augmentedCandidate.sdpMLineIndex,\n          usernameFragment: augmentedCandidate.usernameFragment,\n        };\n      };\n      return augmentedCandidate;\n    }\n    return new NativeRTCIceCandidate(args);\n  };\n  window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;\n\n  // Hook up the augmented candidate in onicecandidate and\n  // addEventListener('icecandidate', ...)\n  utils.wrapPeerConnectionEvent(window, 'icecandidate', e => {\n    if (e.candidate) {\n      Object.defineProperty(e, 'candidate', {\n        value: new window.RTCIceCandidate(e.candidate),\n        writable: 'false'\n      });\n    }\n    return e;\n  });\n}\n\nexport function shimMaxMessageSize(window, browserDetails) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  if (!('sctp' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {\n      get() {\n        return typeof this._sctp === 'undefined' ? null : this._sctp;\n      }\n    });\n  }\n\n  const sctpInDescription = function(description) {\n    if (!description || !description.sdp) {\n      return false;\n    }\n    const sections = SDPUtils.splitSections(description.sdp);\n    sections.shift();\n    return sections.some(mediaSection => {\n      const mLine = SDPUtils.parseMLine(mediaSection);\n      return mLine && mLine.kind === 'application'\n          && mLine.protocol.indexOf('SCTP') !== -1;\n    });\n  };\n\n  const getRemoteFirefoxVersion = function(description) {\n    // TODO: Is there a better solution for detecting Firefox?\n    const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n    if (match === null || match.length < 2) {\n      return -1;\n    }\n    const version = parseInt(match[1], 10);\n    // Test for NaN (yes, this is ugly)\n    return version !== version ? -1 : version;\n  };\n\n  const getCanSendMaxMessageSize = function(remoteIsFirefox) {\n    // Every implementation we know can send at least 64 KiB.\n    // Note: Although Chrome is technically able to send up to 256 KiB, the\n    //       data does not reach the other peer reliably.\n    //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419\n    let canSendMaxMessageSize = 65536;\n    if (browserDetails.browser === 'firefox') {\n      if (browserDetails.version < 57) {\n        if (remoteIsFirefox === -1) {\n          // FF < 57 will send in 16 KiB chunks using the deprecated PPID\n          // fragmentation.\n          canSendMaxMessageSize = 16384;\n        } else {\n          // However, other FF (and RAWRTC) can reassemble PPID-fragmented\n          // messages. Thus, supporting ~2 GiB when sending.\n          canSendMaxMessageSize = 2147483637;\n        }\n      } else if (browserDetails.version < 60) {\n        // Currently, all FF >= 57 will reset the remote maximum message size\n        // to the default value when a data channel is created at a later\n        // stage. :(\n        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n        canSendMaxMessageSize =\n          browserDetails.version === 57 ? 65535 : 65536;\n      } else {\n        // FF >= 60 supports sending ~2 GiB\n        canSendMaxMessageSize = 2147483637;\n      }\n    }\n    return canSendMaxMessageSize;\n  };\n\n  const getMaxMessageSize = function(description, remoteIsFirefox) {\n    // Note: 65536 bytes is the default value from the SDP spec. Also,\n    //       every implementation we know supports receiving 65536 bytes.\n    let maxMessageSize = 65536;\n\n    // FF 57 has a slightly incorrect default remote max message size, so\n    // we need to adjust it here to avoid a failure when sending.\n    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697\n    if (browserDetails.browser === 'firefox'\n         && browserDetails.version === 57) {\n      maxMessageSize = 65535;\n    }\n\n    const match = SDPUtils.matchPrefix(description.sdp,\n      'a=max-message-size:');\n    if (match.length > 0) {\n      maxMessageSize = parseInt(match[0].substr(19), 10);\n    } else if (browserDetails.browser === 'firefox' &&\n                remoteIsFirefox !== -1) {\n      // If the maximum message size is not present in the remote SDP and\n      // both local and remote are Firefox, the remote peer can receive\n      // ~2 GiB.\n      maxMessageSize = 2147483637;\n    }\n    return maxMessageSize;\n  };\n\n  const origSetRemoteDescription =\n      window.RTCPeerConnection.prototype.setRemoteDescription;\n  window.RTCPeerConnection.prototype.setRemoteDescription =\n    function setRemoteDescription() {\n      this._sctp = null;\n      // Chrome decided to not expose .sctp in plan-b mode.\n      // As usual, adapter.js has to do an 'ugly worakaround'\n      // to cover up the mess.\n      if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {\n        const {sdpSemantics} = this.getConfiguration();\n        if (sdpSemantics === 'plan-b') {\n          Object.defineProperty(this, 'sctp', {\n            get() {\n              return typeof this._sctp === 'undefined' ? null : this._sctp;\n            },\n            enumerable: true,\n            configurable: true,\n          });\n        }\n      }\n\n      if (sctpInDescription(arguments[0])) {\n        // Check if the remote is FF.\n        const isFirefox = getRemoteFirefoxVersion(arguments[0]);\n\n        // Get the maximum message size the local peer is capable of sending\n        const canSendMMS = getCanSendMaxMessageSize(isFirefox);\n\n        // Get the maximum message size of the remote peer.\n        const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);\n\n        // Determine final maximum message size\n        let maxMessageSize;\n        if (canSendMMS === 0 && remoteMMS === 0) {\n          maxMessageSize = Number.POSITIVE_INFINITY;\n        } else if (canSendMMS === 0 || remoteMMS === 0) {\n          maxMessageSize = Math.max(canSendMMS, remoteMMS);\n        } else {\n          maxMessageSize = Math.min(canSendMMS, remoteMMS);\n        }\n\n        // Create a dummy RTCSctpTransport object and the 'maxMessageSize'\n        // attribute.\n        const sctp = {};\n        Object.defineProperty(sctp, 'maxMessageSize', {\n          get() {\n            return maxMessageSize;\n          }\n        });\n        this._sctp = sctp;\n      }\n\n      return origSetRemoteDescription.apply(this, arguments);\n    };\n}\n\nexport function shimSendThrowTypeError(window) {\n  if (!(window.RTCPeerConnection &&\n      'createDataChannel' in window.RTCPeerConnection.prototype)) {\n    return;\n  }\n\n  // Note: Although Firefox >= 57 has a native implementation, the maximum\n  //       message size can be reset for all data channels at a later stage.\n  //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n\n  function wrapDcSend(dc, pc) {\n    const origDataChannelSend = dc.send;\n    dc.send = function send() {\n      const data = arguments[0];\n      const length = data.length || data.size || data.byteLength;\n      if (dc.readyState === 'open' &&\n          pc.sctp && length > pc.sctp.maxMessageSize) {\n        throw new TypeError('Message too large (can send a maximum of ' +\n          pc.sctp.maxMessageSize + ' bytes)');\n      }\n      return origDataChannelSend.apply(dc, arguments);\n    };\n  }\n  const origCreateDataChannel =\n    window.RTCPeerConnection.prototype.createDataChannel;\n  window.RTCPeerConnection.prototype.createDataChannel =\n    function createDataChannel() {\n      const dataChannel = origCreateDataChannel.apply(this, arguments);\n      wrapDcSend(dataChannel, this);\n      return dataChannel;\n    };\n  utils.wrapPeerConnectionEvent(window, 'datachannel', e => {\n    wrapDcSend(e.channel, e.target);\n    return e;\n  });\n}\n\n\n/* shims RTCConnectionState by pretending it is the same as iceConnectionState.\n * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12\n * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect\n * since DTLS failures would be hidden. See\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827\n * for the Firefox tracking bug.\n */\nexport function shimConnectionState(window) {\n  if (!window.RTCPeerConnection ||\n      'connectionState' in window.RTCPeerConnection.prototype) {\n    return;\n  }\n  const proto = window.RTCPeerConnection.prototype;\n  Object.defineProperty(proto, 'connectionState', {\n    get() {\n      return {\n        completed: 'connected',\n        checking: 'connecting'\n      }[this.iceConnectionState] || this.iceConnectionState;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(proto, 'onconnectionstatechange', {\n    get() {\n      return this._onconnectionstatechange || null;\n    },\n    set(cb) {\n      if (this._onconnectionstatechange) {\n        this.removeEventListener('connectionstatechange',\n            this._onconnectionstatechange);\n        delete this._onconnectionstatechange;\n      }\n      if (cb) {\n        this.addEventListener('connectionstatechange',\n            this._onconnectionstatechange = cb);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ['setLocalDescription', 'setRemoteDescription'].forEach((method) => {\n    const origMethod = proto[method];\n    proto[method] = function() {\n      if (!this._connectionstatechangepoly) {\n        this._connectionstatechangepoly = e => {\n          const pc = e.target;\n          if (pc._lastConnectionState !== pc.connectionState) {\n            pc._lastConnectionState = pc.connectionState;\n            const newEvent = new Event('connectionstatechange', e);\n            pc.dispatchEvent(newEvent);\n          }\n          return e;\n        };\n        this.addEventListener('iceconnectionstatechange',\n          this._connectionstatechangepoly);\n      }\n      return origMethod.apply(this, arguments);\n    };\n  });\n}\n\nexport function removeExtmapAllowMixed(window, browserDetails) {\n  /* remove a=extmap-allow-mixed for webrtc.org < M71 */\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {\n    return;\n  }\n  if (browserDetails.browser === 'safari' && browserDetails.version >= 605) {\n    return;\n  }\n  const nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;\n  window.RTCPeerConnection.prototype.setRemoteDescription =\n  function setRemoteDescription(desc) {\n    if (desc && desc.sdp && desc.sdp.indexOf('\\na=extmap-allow-mixed') !== -1) {\n      const sdp = desc.sdp.split('\\n').filter((line) => {\n        return line.trim() !== 'a=extmap-allow-mixed';\n      }).join('\\n');\n      // Safari enforces read-only-ness of RTCSessionDescription fields.\n      if (window.RTCSessionDescription &&\n          desc instanceof window.RTCSessionDescription) {\n        arguments[0] = new window.RTCSessionDescription({\n          type: desc.type,\n          sdp,\n        });\n      } else {\n        desc.sdp = sdp;\n      }\n    }\n    return nativeSRD.apply(this, arguments);\n  };\n}\n\nexport function shimAddIceCandidateNullOrEmpty(window, browserDetails) {\n  // Support for addIceCandidate(null or undefined)\n  // as well as addIceCandidate({candidate: \"\", ...})\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=978582\n  // Note: must be called before other polyfills which change the signature.\n  if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {\n    return;\n  }\n  const nativeAddIceCandidate =\n      window.RTCPeerConnection.prototype.addIceCandidate;\n  if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {\n    return;\n  }\n  window.RTCPeerConnection.prototype.addIceCandidate =\n    function addIceCandidate() {\n      if (!arguments[0]) {\n        if (arguments[1]) {\n          arguments[1].apply(null);\n        }\n        return Promise.resolve();\n      }\n      // Firefox 68+ emits and processes {candidate: \"\", ...}, ignore\n      // in older versions.\n      // Native support for ignoring exists for Chrome M77+.\n      // Safari ignores as well, exact version unknown but works in the same\n      // version that also ignores addIceCandidate(null).\n      if (((browserDetails.browser === 'chrome' && browserDetails.version < 78)\n           || (browserDetails.browser === 'firefox'\n               && browserDetails.version < 68)\n           || (browserDetails.browser === 'safari'))\n          && arguments[0] && arguments[0].candidate === '') {\n        return Promise.resolve();\n      }\n      return nativeAddIceCandidate.apply(this, arguments);\n    };\n}\n\n// Note: Make sure to call this ahead of APIs that modify\n// setLocalDescription.length\nexport function shimParameterlessSetLocalDescription(window, browserDetails) {\n  if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {\n    return;\n  }\n  const nativeSetLocalDescription =\n      window.RTCPeerConnection.prototype.setLocalDescription;\n  if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {\n    return;\n  }\n  window.RTCPeerConnection.prototype.setLocalDescription =\n    function setLocalDescription() {\n      let desc = arguments[0] || {};\n      if (typeof desc !== 'object' || (desc.type && desc.sdp)) {\n        return nativeSetLocalDescription.apply(this, arguments);\n      }\n      // The remaining steps should technically happen when SLD comes off the\n      // RTCPeerConnection's operations chain (not ahead of going on it), but\n      // this is too difficult to shim. Instead, this shim only covers the\n      // common case where the operations chain is empty. This is imperfect, but\n      // should cover many cases. Rationale: Even if we can't reduce the glare\n      // window to zero on imperfect implementations, there's value in tapping\n      // into the perfect negotiation pattern that several browsers support.\n      desc = {type: desc.type, sdp: desc.sdp};\n      if (!desc.type) {\n        switch (this.signalingState) {\n          case 'stable':\n          case 'have-local-offer':\n          case 'have-remote-pranswer':\n            desc.type = 'offer';\n            break;\n          default:\n            desc.type = 'answer';\n            break;\n        }\n      }\n      if (desc.sdp || (desc.type !== 'offer' && desc.type !== 'answer')) {\n        return nativeSetLocalDescription.apply(this, [desc]);\n      }\n      const func = desc.type === 'offer' ? this.createOffer : this.createAnswer;\n      return func.apply(this)\n        .then(d => nativeSetLocalDescription.apply(this, [d]));\n    };\n}\n","/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n'use strict';\n\nimport {adapterFactory} from './adapter_factory.js';\n\nconst adapter =\n  adapterFactory({window: typeof window === 'undefined' ? undefined : window});\nexport default adapter;\n","/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\nimport * as utils from './utils';\n\n  // Browser shims.\nimport * as chromeShim from './chrome/chrome_shim';\nimport * as firefoxShim from './firefox/firefox_shim';\nimport * as safariShim from './safari/safari_shim';\nimport * as commonShim from './common_shim';\nimport * as sdp from 'sdp';\n\n// Shimming starts here.\nexport function adapterFactory({window} = {}, options = {\n  shimChrome: true,\n  shimFirefox: true,\n  shimSafari: true,\n}) {\n  // Utils.\n  const logging = utils.log;\n  const browserDetails = utils.detectBrowser(window);\n\n  const adapter = {\n    browserDetails,\n    commonShim,\n    extractVersion: utils.extractVersion,\n    disableLog: utils.disableLog,\n    disableWarnings: utils.disableWarnings,\n    // Expose sdp as a convenience. For production apps include directly.\n    sdp,\n  };\n\n  // Shim browser if found.\n  switch (browserDetails.browser) {\n    case 'chrome':\n      if (!chromeShim || !chromeShim.shimPeerConnection ||\n          !options.shimChrome) {\n        logging('Chrome shim is not included in this adapter release.');\n        return adapter;\n      }\n      if (browserDetails.version === null) {\n        logging('Chrome shim can not determine version, not shimming.');\n        return adapter;\n      }\n      logging('adapter.js shimming chrome.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = chromeShim;\n\n      // Must be called before shimPeerConnection.\n      commonShim.shimAddIceCandidateNullOrEmpty(window, browserDetails);\n      commonShim.shimParameterlessSetLocalDescription(window, browserDetails);\n\n      chromeShim.shimGetUserMedia(window, browserDetails);\n      chromeShim.shimMediaStream(window, browserDetails);\n      chromeShim.shimPeerConnection(window, browserDetails);\n      chromeShim.shimOnTrack(window, browserDetails);\n      chromeShim.shimAddTrackRemoveTrack(window, browserDetails);\n      chromeShim.shimGetSendersWithDtmf(window, browserDetails);\n      chromeShim.shimGetStats(window, browserDetails);\n      chromeShim.shimSenderReceiverGetStats(window, browserDetails);\n      chromeShim.fixNegotiationNeeded(window, browserDetails);\n\n      commonShim.shimRTCIceCandidate(window, browserDetails);\n      commonShim.shimConnectionState(window, browserDetails);\n      commonShim.shimMaxMessageSize(window, browserDetails);\n      commonShim.shimSendThrowTypeError(window, browserDetails);\n      commonShim.removeExtmapAllowMixed(window, browserDetails);\n      break;\n    case 'firefox':\n      if (!firefoxShim || !firefoxShim.shimPeerConnection ||\n          !options.shimFirefox) {\n        logging('Firefox shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming firefox.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = firefoxShim;\n\n      // Must be called before shimPeerConnection.\n      commonShim.shimAddIceCandidateNullOrEmpty(window, browserDetails);\n      commonShim.shimParameterlessSetLocalDescription(window, browserDetails);\n\n      firefoxShim.shimGetUserMedia(window, browserDetails);\n      firefoxShim.shimPeerConnection(window, browserDetails);\n      firefoxShim.shimOnTrack(window, browserDetails);\n      firefoxShim.shimRemoveStream(window, browserDetails);\n      firefoxShim.shimSenderGetStats(window, browserDetails);\n      firefoxShim.shimReceiverGetStats(window, browserDetails);\n      firefoxShim.shimRTCDataChannel(window, browserDetails);\n      firefoxShim.shimAddTransceiver(window, browserDetails);\n      firefoxShim.shimGetParameters(window, browserDetails);\n      firefoxShim.shimCreateOffer(window, browserDetails);\n      firefoxShim.shimCreateAnswer(window, browserDetails);\n\n      commonShim.shimRTCIceCandidate(window, browserDetails);\n      commonShim.shimConnectionState(window, browserDetails);\n      commonShim.shimMaxMessageSize(window, browserDetails);\n      commonShim.shimSendThrowTypeError(window, browserDetails);\n      break;\n    case 'safari':\n      if (!safariShim || !options.shimSafari) {\n        logging('Safari shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming safari.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = safariShim;\n\n      // Must be called before shimCallbackAPI.\n      commonShim.shimAddIceCandidateNullOrEmpty(window, browserDetails);\n      commonShim.shimParameterlessSetLocalDescription(window, browserDetails);\n\n      safariShim.shimRTCIceServerUrls(window, browserDetails);\n      safariShim.shimCreateOfferLegacy(window, browserDetails);\n      safariShim.shimCallbacksAPI(window, browserDetails);\n      safariShim.shimLocalStreamsAPI(window, browserDetails);\n      safariShim.shimRemoteStreamsAPI(window, browserDetails);\n      safariShim.shimTrackEventTransceiver(window, browserDetails);\n      safariShim.shimGetUserMedia(window, browserDetails);\n      safariShim.shimAudioContext(window, browserDetails);\n\n      commonShim.shimRTCIceCandidate(window, browserDetails);\n      commonShim.shimMaxMessageSize(window, browserDetails);\n      commonShim.shimSendThrowTypeError(window, browserDetails);\n      commonShim.removeExtmapAllowMixed(window, browserDetails);\n      break;\n    default:\n      logging('Unsupported browser!');\n      break;\n  }\n\n  return adapter;\n}\n","'use strict';\n\n// Last time updated: 2021-03-09 3:20:22 AM UTC\n\n// ________________\n// RecordRTC v5.6.2\n\n// Open-Sourced: https://github.com/muaz-khan/RecordRTC\n\n// --------------------------------------------------\n// Muaz Khan     - www.MuazKhan.com\n// MIT License   - www.WebRTC-Experiment.com/licence\n// --------------------------------------------------\n\n// ____________\n// RecordRTC.js\n\n/**\n * {@link https://github.com/muaz-khan/RecordRTC|RecordRTC} is a WebRTC JavaScript library for audio/video as well as screen activity recording. It supports Chrome, Firefox, Opera, Android, and Microsoft Edge. Platforms: Linux, Mac and Windows. \n * @summary Record audio, video or screen inside the browser.\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @typedef RecordRTC\n * @class\n * @example\n * var recorder = RecordRTC(mediaStream or [arrayOfMediaStream], {\n *     type: 'video', // audio or video or gif or canvas\n *     recorderType: MediaStreamRecorder || CanvasRecorder || StereoAudioRecorder || Etc\n * });\n * recorder.startRecording();\n * @see For further information:\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n * @param {MediaStream} mediaStream - Single media-stream object, array of media-streams, html-canvas-element, etc.\n * @param {object} config - {type:\"video\", recorderType: MediaStreamRecorder, disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, desiredSampRate: 16000, video: HTMLVideoElement, etc.}\n */\n\nfunction RecordRTC(mediaStream, config) {\n    if (!mediaStream) {\n        throw 'First parameter is required.';\n    }\n\n    config = config || {\n        type: 'video'\n    };\n\n    config = new RecordRTCConfiguration(mediaStream, config);\n\n    // a reference to user's recordRTC object\n    var self = this;\n\n    function startRecording(config2) {\n        if (!config.disableLogs) {\n            console.log('RecordRTC version: ', self.version);\n        }\n\n        if (!!config2) {\n            // allow users to set options using startRecording method\n            // config2 is similar to main \"config\" object (second parameter over RecordRTC constructor)\n            config = new RecordRTCConfiguration(mediaStream, config2);\n        }\n\n        if (!config.disableLogs) {\n            console.log('started recording ' + config.type + ' stream.');\n        }\n\n        if (mediaRecorder) {\n            mediaRecorder.clearRecordedData();\n            mediaRecorder.record();\n\n            setState('recording');\n\n            if (self.recordingDuration) {\n                handleRecordingDuration();\n            }\n            return self;\n        }\n\n        initRecorder(function() {\n            if (self.recordingDuration) {\n                handleRecordingDuration();\n            }\n        });\n\n        return self;\n    }\n\n    function initRecorder(initCallback) {\n        if (initCallback) {\n            config.initCallback = function() {\n                initCallback();\n                initCallback = config.initCallback = null; // recorder.initRecorder should be call-backed once.\n            };\n        }\n\n        var Recorder = new GetRecorderType(mediaStream, config);\n\n        mediaRecorder = new Recorder(mediaStream, config);\n        mediaRecorder.record();\n\n        setState('recording');\n\n        if (!config.disableLogs) {\n            console.log('Initialized recorderType:', mediaRecorder.constructor.name, 'for output-type:', config.type);\n        }\n    }\n\n    function stopRecording(callback) {\n        callback = callback || function() {};\n\n        if (!mediaRecorder) {\n            warningLog();\n            return;\n        }\n\n        if (self.state === 'paused') {\n            self.resumeRecording();\n\n            setTimeout(function() {\n                stopRecording(callback);\n            }, 1);\n            return;\n        }\n\n        if (self.state !== 'recording' && !config.disableLogs) {\n            console.warn('Recording state should be: \"recording\", however current state is: ', self.state);\n        }\n\n        if (!config.disableLogs) {\n            console.log('Stopped recording ' + config.type + ' stream.');\n        }\n\n        if (config.type !== 'gif') {\n            mediaRecorder.stop(_callback);\n        } else {\n            mediaRecorder.stop();\n            _callback();\n        }\n\n        setState('stopped');\n\n        function _callback(__blob) {\n            if (!mediaRecorder) {\n                if (typeof callback.call === 'function') {\n                    callback.call(self, '');\n                } else {\n                    callback('');\n                }\n                return;\n            }\n\n            Object.keys(mediaRecorder).forEach(function(key) {\n                if (typeof mediaRecorder[key] === 'function') {\n                    return;\n                }\n\n                self[key] = mediaRecorder[key];\n            });\n\n            var blob = mediaRecorder.blob;\n\n            if (!blob) {\n                if (__blob) {\n                    mediaRecorder.blob = blob = __blob;\n                } else {\n                    throw 'Recording failed.';\n                }\n            }\n\n            if (blob && !config.disableLogs) {\n                console.log(blob.type, '->', bytesToSize(blob.size));\n            }\n\n            if (callback) {\n                var url;\n\n                try {\n                    url = URL.createObjectURL(blob);\n                } catch (e) {}\n\n                if (typeof callback.call === 'function') {\n                    callback.call(self, url);\n                } else {\n                    callback(url);\n                }\n            }\n\n            if (!config.autoWriteToDisk) {\n                return;\n            }\n\n            getDataURL(function(dataURL) {\n                var parameter = {};\n                parameter[config.type + 'Blob'] = dataURL;\n                DiskStorage.Store(parameter);\n            });\n        }\n    }\n\n    function pauseRecording() {\n        if (!mediaRecorder) {\n            warningLog();\n            return;\n        }\n\n        if (self.state !== 'recording') {\n            if (!config.disableLogs) {\n                console.warn('Unable to pause the recording. Recording state: ', self.state);\n            }\n            return;\n        }\n\n        setState('paused');\n\n        mediaRecorder.pause();\n\n        if (!config.disableLogs) {\n            console.log('Paused recording.');\n        }\n    }\n\n    function resumeRecording() {\n        if (!mediaRecorder) {\n            warningLog();\n            return;\n        }\n\n        if (self.state !== 'paused') {\n            if (!config.disableLogs) {\n                console.warn('Unable to resume the recording. Recording state: ', self.state);\n            }\n            return;\n        }\n\n        setState('recording');\n\n        // not all libs have this method yet\n        mediaRecorder.resume();\n\n        if (!config.disableLogs) {\n            console.log('Resumed recording.');\n        }\n    }\n\n    function readFile(_blob) {\n        postMessage(new FileReaderSync().readAsDataURL(_blob));\n    }\n\n    function getDataURL(callback, _mediaRecorder) {\n        if (!callback) {\n            throw 'Pass a callback function over getDataURL.';\n        }\n\n        var blob = _mediaRecorder ? _mediaRecorder.blob : (mediaRecorder || {}).blob;\n\n        if (!blob) {\n            if (!config.disableLogs) {\n                console.warn('Blob encoder did not finish its job yet.');\n            }\n\n            setTimeout(function() {\n                getDataURL(callback, _mediaRecorder);\n            }, 1000);\n            return;\n        }\n\n        if (typeof Worker !== 'undefined' && !navigator.mozGetUserMedia) {\n            var webWorker = processInWebWorker(readFile);\n\n            webWorker.onmessage = function(event) {\n                callback(event.data);\n            };\n\n            webWorker.postMessage(blob);\n        } else {\n            var reader = new FileReader();\n            reader.readAsDataURL(blob);\n            reader.onload = function(event) {\n                callback(event.target.result);\n            };\n        }\n\n        function processInWebWorker(_function) {\n            try {\n                var blob = URL.createObjectURL(new Blob([_function.toString(),\n                    'this.onmessage =  function (eee) {' + _function.name + '(eee.data);}'\n                ], {\n                    type: 'application/javascript'\n                }));\n\n                var worker = new Worker(blob);\n                URL.revokeObjectURL(blob);\n                return worker;\n            } catch (e) {}\n        }\n    }\n\n    function handleRecordingDuration(counter) {\n        counter = counter || 0;\n\n        if (self.state === 'paused') {\n            setTimeout(function() {\n                handleRecordingDuration(counter);\n            }, 1000);\n            return;\n        }\n\n        if (self.state === 'stopped') {\n            return;\n        }\n\n        if (counter >= self.recordingDuration) {\n            stopRecording(self.onRecordingStopped);\n            return;\n        }\n\n        counter += 1000; // 1-second\n\n        setTimeout(function() {\n            handleRecordingDuration(counter);\n        }, 1000);\n    }\n\n    function setState(state) {\n        if (!self) {\n            return;\n        }\n\n        self.state = state;\n\n        if (typeof self.onStateChanged.call === 'function') {\n            self.onStateChanged.call(self, state);\n        } else {\n            self.onStateChanged(state);\n        }\n    }\n\n    var WARNING = 'It seems that recorder is destroyed or \"startRecording\" is not invoked for ' + config.type + ' recorder.';\n\n    function warningLog() {\n        if (config.disableLogs === true) {\n            return;\n        }\n\n        console.warn(WARNING);\n    }\n\n    var mediaRecorder;\n\n    var returnObject = {\n        /**\n         * This method starts the recording.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @example\n         * var recorder = RecordRTC(mediaStream, {\n         *     type: 'video'\n         * });\n         * recorder.startRecording();\n         */\n        startRecording: startRecording,\n\n        /**\n         * This method stops the recording. It is strongly recommended to get \"blob\" or \"URI\" inside the callback to make sure all recorders finished their job.\n         * @param {function} callback - Callback to get the recorded blob.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @example\n         * recorder.stopRecording(function() {\n         *     // use either \"this\" or \"recorder\" object; both are identical\n         *     video.src = this.toURL();\n         *     var blob = this.getBlob();\n         * });\n         */\n        stopRecording: stopRecording,\n\n        /**\n         * This method pauses the recording. You can resume recording using \"resumeRecording\" method.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @todo Firefox is unable to pause the recording. Fix it.\n         * @example\n         * recorder.pauseRecording();  // pause the recording\n         * recorder.resumeRecording(); // resume again\n         */\n        pauseRecording: pauseRecording,\n\n        /**\n         * This method resumes the recording.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @example\n         * recorder.pauseRecording();  // first of all, pause the recording\n         * recorder.resumeRecording(); // now resume it\n         */\n        resumeRecording: resumeRecording,\n\n        /**\n         * This method initializes the recording.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @todo This method should be deprecated.\n         * @example\n         * recorder.initRecorder();\n         */\n        initRecorder: initRecorder,\n\n        /**\n         * Ask RecordRTC to auto-stop the recording after 5 minutes.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @example\n         * var fiveMinutes = 5 * 1000 * 60;\n         * recorder.setRecordingDuration(fiveMinutes, function() {\n         *    var blob = this.getBlob();\n         *    video.src = this.toURL();\n         * });\n         * \n         * // or otherwise\n         * recorder.setRecordingDuration(fiveMinutes).onRecordingStopped(function() {\n         *    var blob = this.getBlob();\n         *    video.src = this.toURL();\n         * });\n         */\n        setRecordingDuration: function(recordingDuration, callback) {\n            if (typeof recordingDuration === 'undefined') {\n                throw 'recordingDuration is required.';\n            }\n\n            if (typeof recordingDuration !== 'number') {\n                throw 'recordingDuration must be a number.';\n            }\n\n            self.recordingDuration = recordingDuration;\n            self.onRecordingStopped = callback || function() {};\n\n            return {\n                onRecordingStopped: function(callback) {\n                    self.onRecordingStopped = callback;\n                }\n            };\n        },\n\n        /**\n         * This method can be used to clear/reset all the recorded data.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @todo Figure out the difference between \"reset\" and \"clearRecordedData\" methods.\n         * @example\n         * recorder.clearRecordedData();\n         */\n        clearRecordedData: function() {\n            if (!mediaRecorder) {\n                warningLog();\n                return;\n            }\n\n            mediaRecorder.clearRecordedData();\n\n            if (!config.disableLogs) {\n                console.log('Cleared old recorded data.');\n            }\n        },\n\n        /**\n         * Get the recorded blob. Use this method inside the \"stopRecording\" callback.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @example\n         * recorder.stopRecording(function() {\n         *     var blob = this.getBlob();\n         *\n         *     var file = new File([blob], 'filename.webm', {\n         *         type: 'video/webm'\n         *     });\n         *\n         *     var formData = new FormData();\n         *     formData.append('file', file); // upload \"File\" object rather than a \"Blob\"\n         *     uploadToServer(formData);\n         * });\n         * @returns {Blob} Returns recorded data as \"Blob\" object.\n         */\n        getBlob: function() {\n            if (!mediaRecorder) {\n                warningLog();\n                return;\n            }\n\n            return mediaRecorder.blob;\n        },\n\n        /**\n         * Get data-URI instead of Blob.\n         * @param {function} callback - Callback to get the Data-URI.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @example\n         * recorder.stopRecording(function() {\n         *     recorder.getDataURL(function(dataURI) {\n         *         video.src = dataURI;\n         *     });\n         * });\n         */\n        getDataURL: getDataURL,\n\n        /**\n         * Get virtual/temporary URL. Usage of this URL is limited to current tab.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @example\n         * recorder.stopRecording(function() {\n         *     video.src = this.toURL();\n         * });\n         * @returns {String} Returns a virtual/temporary URL for the recorded \"Blob\".\n         */\n        toURL: function() {\n            if (!mediaRecorder) {\n                warningLog();\n                return;\n            }\n\n            return URL.createObjectURL(mediaRecorder.blob);\n        },\n\n        /**\n         * Get internal recording object (i.e. internal module) e.g. MutliStreamRecorder, MediaStreamRecorder, StereoAudioRecorder or WhammyRecorder etc.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @example\n         * var internalRecorder = recorder.getInternalRecorder();\n         * if(internalRecorder instanceof MultiStreamRecorder) {\n         *     internalRecorder.addStreams([newAudioStream]);\n         *     internalRecorder.resetVideoStreams([screenStream]);\n         * }\n         * @returns {Object} Returns internal recording object.\n         */\n        getInternalRecorder: function() {\n            return mediaRecorder;\n        },\n\n        /**\n         * Invoke save-as dialog to save the recorded blob into your disk.\n         * @param {string} fileName - Set your own file name.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @example\n         * recorder.stopRecording(function() {\n         *     this.save('file-name');\n         *\n         *     // or manually:\n         *     invokeSaveAsDialog(this.getBlob(), 'filename.webm');\n         * });\n         */\n        save: function(fileName) {\n            if (!mediaRecorder) {\n                warningLog();\n                return;\n            }\n\n            invokeSaveAsDialog(mediaRecorder.blob, fileName);\n        },\n\n        /**\n         * This method gets a blob from indexed-DB storage.\n         * @param {function} callback - Callback to get the recorded blob.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @example\n         * recorder.getFromDisk(function(dataURL) {\n         *     video.src = dataURL;\n         * });\n         */\n        getFromDisk: function(callback) {\n            if (!mediaRecorder) {\n                warningLog();\n                return;\n            }\n\n            RecordRTC.getFromDisk(config.type, callback);\n        },\n\n        /**\n         * This method appends an array of webp images to the recorded video-blob. It takes an \"array\" object.\n         * @type {Array.<Array>}\n         * @param {Array} arrayOfWebPImages - Array of webp images.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @todo This method should be deprecated.\n         * @example\n         * var arrayOfWebPImages = [];\n         * arrayOfWebPImages.push({\n         *     duration: index,\n         *     image: 'data:image/webp;base64,...'\n         * });\n         * recorder.setAdvertisementArray(arrayOfWebPImages);\n         */\n        setAdvertisementArray: function(arrayOfWebPImages) {\n            config.advertisement = [];\n\n            var length = arrayOfWebPImages.length;\n            for (var i = 0; i < length; i++) {\n                config.advertisement.push({\n                    duration: i,\n                    image: arrayOfWebPImages[i]\n                });\n            }\n        },\n\n        /**\n         * It is equivalent to <code class=\"str\">\"recorder.getBlob()\"</code> method. Usage of \"getBlob\" is recommended, though.\n         * @property {Blob} blob - Recorded Blob can be accessed using this property.\n         * @memberof RecordRTC\n         * @instance\n         * @readonly\n         * @example\n         * recorder.stopRecording(function() {\n         *     var blob = this.blob;\n         *\n         *     // below one is recommended\n         *     var blob = this.getBlob();\n         * });\n         */\n        blob: null,\n\n        /**\n         * This works only with {recorderType:StereoAudioRecorder}. Use this property on \"stopRecording\" to verify the encoder's sample-rates.\n         * @property {number} bufferSize - Buffer-size used to encode the WAV container\n         * @memberof RecordRTC\n         * @instance\n         * @readonly\n         * @example\n         * recorder.stopRecording(function() {\n         *     alert('Recorder used this buffer-size: ' + this.bufferSize);\n         * });\n         */\n        bufferSize: 0,\n\n        /**\n         * This works only with {recorderType:StereoAudioRecorder}. Use this property on \"stopRecording\" to verify the encoder's sample-rates.\n         * @property {number} sampleRate - Sample-rates used to encode the WAV container\n         * @memberof RecordRTC\n         * @instance\n         * @readonly\n         * @example\n         * recorder.stopRecording(function() {\n         *     alert('Recorder used these sample-rates: ' + this.sampleRate);\n         * });\n         */\n        sampleRate: 0,\n\n        /**\n         * {recorderType:StereoAudioRecorder} returns ArrayBuffer object.\n         * @property {ArrayBuffer} buffer - Audio ArrayBuffer, supported only in Chrome.\n         * @memberof RecordRTC\n         * @instance\n         * @readonly\n         * @example\n         * recorder.stopRecording(function() {\n         *     var arrayBuffer = this.buffer;\n         *     alert(arrayBuffer.byteLength);\n         * });\n         */\n        buffer: null,\n\n        /**\n         * This method resets the recorder. So that you can reuse single recorder instance many times.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @example\n         * recorder.reset();\n         * recorder.startRecording();\n         */\n        reset: function() {\n            if (self.state === 'recording' && !config.disableLogs) {\n                console.warn('Stop an active recorder.');\n            }\n\n            if (mediaRecorder && typeof mediaRecorder.clearRecordedData === 'function') {\n                mediaRecorder.clearRecordedData();\n            }\n            mediaRecorder = null;\n            setState('inactive');\n            self.blob = null;\n        },\n\n        /**\n         * This method is called whenever recorder's state changes. Use this as an \"event\".\n         * @property {String} state - A recorder's state can be: recording, paused, stopped or inactive.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @example\n         * recorder.onStateChanged = function(state) {\n         *     console.log('Recorder state: ', state);\n         * };\n         */\n        onStateChanged: function(state) {\n            if (!config.disableLogs) {\n                console.log('Recorder state changed:', state);\n            }\n        },\n\n        /**\n         * A recorder can have inactive, recording, paused or stopped states.\n         * @property {String} state - A recorder's state can be: recording, paused, stopped or inactive.\n         * @memberof RecordRTC\n         * @static\n         * @readonly\n         * @example\n         * // this looper function will keep you updated about the recorder's states.\n         * (function looper() {\n         *     document.querySelector('h1').innerHTML = 'Recorder\\'s state is: ' + recorder.state;\n         *     if(recorder.state === 'stopped') return; // ignore+stop\n         *     setTimeout(looper, 1000); // update after every 3-seconds\n         * })();\n         * recorder.startRecording();\n         */\n        state: 'inactive',\n\n        /**\n         * Get recorder's readonly state.\n         * @method\n         * @memberof RecordRTC\n         * @example\n         * var state = recorder.getState();\n         * @returns {String} Returns recording state.\n         */\n        getState: function() {\n            return self.state;\n        },\n\n        /**\n         * Destroy RecordRTC instance. Clear all recorders and objects.\n         * @method\n         * @memberof RecordRTC\n         * @example\n         * recorder.destroy();\n         */\n        destroy: function() {\n            var disableLogsCache = config.disableLogs;\n\n            config = {\n                disableLogs: true\n            };\n            self.reset();\n            setState('destroyed');\n            returnObject = self = null;\n\n            if (Storage.AudioContextConstructor) {\n                Storage.AudioContextConstructor.close();\n                Storage.AudioContextConstructor = null;\n            }\n\n            config.disableLogs = disableLogsCache;\n\n            if (!config.disableLogs) {\n                console.log('RecordRTC is destroyed.');\n            }\n        },\n\n        /**\n         * RecordRTC version number\n         * @property {String} version - Release version number.\n         * @memberof RecordRTC\n         * @static\n         * @readonly\n         * @example\n         * alert(recorder.version);\n         */\n        version: '5.6.2'\n    };\n\n    if (!this) {\n        self = returnObject;\n        return returnObject;\n    }\n\n    // if someone wants to use RecordRTC with the \"new\" keyword.\n    for (var prop in returnObject) {\n        this[prop] = returnObject[prop];\n    }\n\n    self = this;\n\n    return returnObject;\n}\n\nRecordRTC.version = '5.6.2';\n\nif (typeof module !== 'undefined' /* && !!module.exports*/ ) {\n    module.exports = RecordRTC;\n}\n\nif (typeof define === 'function' && define.amd) {\n    define('RecordRTC', [], function() {\n        return RecordRTC;\n    });\n}\n\nRecordRTC.getFromDisk = function(type, callback) {\n    if (!callback) {\n        throw 'callback is mandatory.';\n    }\n\n    console.log('Getting recorded ' + (type === 'all' ? 'blobs' : type + ' blob ') + ' from disk!');\n    DiskStorage.Fetch(function(dataURL, _type) {\n        if (type !== 'all' && _type === type + 'Blob' && callback) {\n            callback(dataURL);\n        }\n\n        if (type === 'all' && callback) {\n            callback(dataURL, _type.replace('Blob', ''));\n        }\n    });\n};\n\n/**\n * This method can be used to store recorded blobs into IndexedDB storage.\n * @param {object} options - {audio: Blob, video: Blob, gif: Blob}\n * @method\n * @memberof RecordRTC\n * @example\n * RecordRTC.writeToDisk({\n *     audio: audioBlob,\n *     video: videoBlob,\n *     gif  : gifBlob\n * });\n */\nRecordRTC.writeToDisk = function(options) {\n    console.log('Writing recorded blob(s) to disk!');\n    options = options || {};\n    if (options.audio && options.video && options.gif) {\n        options.audio.getDataURL(function(audioDataURL) {\n            options.video.getDataURL(function(videoDataURL) {\n                options.gif.getDataURL(function(gifDataURL) {\n                    DiskStorage.Store({\n                        audioBlob: audioDataURL,\n                        videoBlob: videoDataURL,\n                        gifBlob: gifDataURL\n                    });\n                });\n            });\n        });\n    } else if (options.audio && options.video) {\n        options.audio.getDataURL(function(audioDataURL) {\n            options.video.getDataURL(function(videoDataURL) {\n                DiskStorage.Store({\n                    audioBlob: audioDataURL,\n                    videoBlob: videoDataURL\n                });\n            });\n        });\n    } else if (options.audio && options.gif) {\n        options.audio.getDataURL(function(audioDataURL) {\n            options.gif.getDataURL(function(gifDataURL) {\n                DiskStorage.Store({\n                    audioBlob: audioDataURL,\n                    gifBlob: gifDataURL\n                });\n            });\n        });\n    } else if (options.video && options.gif) {\n        options.video.getDataURL(function(videoDataURL) {\n            options.gif.getDataURL(function(gifDataURL) {\n                DiskStorage.Store({\n                    videoBlob: videoDataURL,\n                    gifBlob: gifDataURL\n                });\n            });\n        });\n    } else if (options.audio) {\n        options.audio.getDataURL(function(audioDataURL) {\n            DiskStorage.Store({\n                audioBlob: audioDataURL\n            });\n        });\n    } else if (options.video) {\n        options.video.getDataURL(function(videoDataURL) {\n            DiskStorage.Store({\n                videoBlob: videoDataURL\n            });\n        });\n    } else if (options.gif) {\n        options.gif.getDataURL(function(gifDataURL) {\n            DiskStorage.Store({\n                gifBlob: gifDataURL\n            });\n        });\n    }\n};\n\n// __________________________\n// RecordRTC-Configuration.js\n\n/**\n * {@link RecordRTCConfiguration} is an inner/private helper for {@link RecordRTC}.\n * @summary It configures the 2nd parameter passed over {@link RecordRTC} and returns a valid \"config\" object.\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @typedef RecordRTCConfiguration\n * @class\n * @example\n * var options = RecordRTCConfiguration(mediaStream, options);\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\n * @param {object} config - {type:\"video\", disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, getNativeBlob:true, etc.}\n */\n\nfunction RecordRTCConfiguration(mediaStream, config) {\n    if (!config.recorderType && !config.type) {\n        if (!!config.audio && !!config.video) {\n            config.type = 'video';\n        } else if (!!config.audio && !config.video) {\n            config.type = 'audio';\n        }\n    }\n\n    if (config.recorderType && !config.type) {\n        if (config.recorderType === WhammyRecorder || config.recorderType === CanvasRecorder || (typeof WebAssemblyRecorder !== 'undefined' && config.recorderType === WebAssemblyRecorder)) {\n            config.type = 'video';\n        } else if (config.recorderType === GifRecorder) {\n            config.type = 'gif';\n        } else if (config.recorderType === StereoAudioRecorder) {\n            config.type = 'audio';\n        } else if (config.recorderType === MediaStreamRecorder) {\n            if (getTracks(mediaStream, 'audio').length && getTracks(mediaStream, 'video').length) {\n                config.type = 'video';\n            } else if (!getTracks(mediaStream, 'audio').length && getTracks(mediaStream, 'video').length) {\n                config.type = 'video';\n            } else if (getTracks(mediaStream, 'audio').length && !getTracks(mediaStream, 'video').length) {\n                config.type = 'audio';\n            } else {\n                // config.type = 'UnKnown';\n            }\n        }\n    }\n\n    if (typeof MediaStreamRecorder !== 'undefined' && typeof MediaRecorder !== 'undefined' && 'requestData' in MediaRecorder.prototype) {\n        if (!config.mimeType) {\n            config.mimeType = 'video/webm';\n        }\n\n        if (!config.type) {\n            config.type = config.mimeType.split('/')[0];\n        }\n\n        if (!config.bitsPerSecond) {\n            // config.bitsPerSecond = 128000;\n        }\n    }\n\n    // consider default type=audio\n    if (!config.type) {\n        if (config.mimeType) {\n            config.type = config.mimeType.split('/')[0];\n        }\n        if (!config.type) {\n            config.type = 'audio';\n        }\n    }\n\n    return config;\n}\n\n// __________________\n// GetRecorderType.js\n\n/**\n * {@link GetRecorderType} is an inner/private helper for {@link RecordRTC}.\n * @summary It returns best recorder-type available for your browser.\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @typedef GetRecorderType\n * @class\n * @example\n * var RecorderType = GetRecorderType(options);\n * var recorder = new RecorderType(options);\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\n * @param {object} config - {type:\"video\", disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, etc.}\n */\n\nfunction GetRecorderType(mediaStream, config) {\n    var recorder;\n\n    // StereoAudioRecorder can work with all three: Edge, Firefox and Chrome\n    // todo: detect if it is Edge, then auto use: StereoAudioRecorder\n    if (isChrome || isEdge || isOpera) {\n        // Media Stream Recording API has not been implemented in chrome yet;\n        // That's why using WebAudio API to record stereo audio in WAV format\n        recorder = StereoAudioRecorder;\n    }\n\n    if (typeof MediaRecorder !== 'undefined' && 'requestData' in MediaRecorder.prototype && !isChrome) {\n        recorder = MediaStreamRecorder;\n    }\n\n    // video recorder (in WebM format)\n    if (config.type === 'video' && (isChrome || isOpera)) {\n        recorder = WhammyRecorder;\n\n        if (typeof WebAssemblyRecorder !== 'undefined' && typeof ReadableStream !== 'undefined') {\n            recorder = WebAssemblyRecorder;\n        }\n    }\n\n    // video recorder (in Gif format)\n    if (config.type === 'gif') {\n        recorder = GifRecorder;\n    }\n\n    // html2canvas recording!\n    if (config.type === 'canvas') {\n        recorder = CanvasRecorder;\n    }\n\n    if (isMediaRecorderCompatible() && recorder !== CanvasRecorder && recorder !== GifRecorder && typeof MediaRecorder !== 'undefined' && 'requestData' in MediaRecorder.prototype) {\n        if (getTracks(mediaStream, 'video').length || getTracks(mediaStream, 'audio').length) {\n            // audio-only recording\n            if (config.type === 'audio') {\n                if (typeof MediaRecorder.isTypeSupported === 'function' && MediaRecorder.isTypeSupported('audio/webm')) {\n                    recorder = MediaStreamRecorder;\n                }\n                // else recorder = StereoAudioRecorder;\n            } else {\n                // video or screen tracks\n                if (typeof MediaRecorder.isTypeSupported === 'function' && MediaRecorder.isTypeSupported('video/webm')) {\n                    recorder = MediaStreamRecorder;\n                }\n            }\n        }\n    }\n\n    if (mediaStream instanceof Array && mediaStream.length) {\n        recorder = MultiStreamRecorder;\n    }\n\n    if (config.recorderType) {\n        recorder = config.recorderType;\n    }\n\n    if (!config.disableLogs && !!recorder && !!recorder.name) {\n        console.log('Using recorderType:', recorder.name || recorder.constructor.name);\n    }\n\n    if (!recorder && isSafari) {\n        recorder = MediaStreamRecorder;\n    }\n\n    return recorder;\n}\n\n// _____________\n// MRecordRTC.js\n\n/**\n * MRecordRTC runs on top of {@link RecordRTC} to bring multiple recordings in a single place, by providing simple API.\n * @summary MRecordRTC stands for \"Multiple-RecordRTC\".\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @typedef MRecordRTC\n * @class\n * @example\n * var recorder = new MRecordRTC();\n * recorder.addStream(MediaStream);\n * recorder.mediaType = {\n *     audio: true, // or StereoAudioRecorder or MediaStreamRecorder\n *     video: true, // or WhammyRecorder or MediaStreamRecorder or WebAssemblyRecorder or CanvasRecorder\n *     gif: true    // or GifRecorder\n * };\n * // mimeType is optional and should be set only in advance cases.\n * recorder.mimeType = {\n *     audio: 'audio/wav',\n *     video: 'video/webm',\n *     gif:   'image/gif'\n * };\n * recorder.startRecording();\n * @see For further information:\n * @see {@link https://github.com/muaz-khan/RecordRTC/tree/master/MRecordRTC|MRecordRTC Source Code}\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\n * @requires {@link RecordRTC}\n */\n\nfunction MRecordRTC(mediaStream) {\n\n    /**\n     * This method attaches MediaStream object to {@link MRecordRTC}.\n     * @param {MediaStream} mediaStream - A MediaStream object, either fetched using getUserMedia API, or generated using captureStreamUntilEnded or WebAudio API.\n     * @method\n     * @memberof MRecordRTC\n     * @example\n     * recorder.addStream(MediaStream);\n     */\n    this.addStream = function(_mediaStream) {\n        if (_mediaStream) {\n            mediaStream = _mediaStream;\n        }\n    };\n\n    /**\n     * This property can be used to set the recording type e.g. audio, or video, or gif, or canvas.\n     * @property {object} mediaType - {audio: true, video: true, gif: true}\n     * @memberof MRecordRTC\n     * @example\n     * var recorder = new MRecordRTC();\n     * recorder.mediaType = {\n     *     audio: true, // TRUE or StereoAudioRecorder or MediaStreamRecorder\n     *     video: true, // TRUE or WhammyRecorder or MediaStreamRecorder or WebAssemblyRecorder or CanvasRecorder\n     *     gif  : true  // TRUE or GifRecorder\n     * };\n     */\n    this.mediaType = {\n        audio: true,\n        video: true\n    };\n\n    /**\n     * This method starts recording.\n     * @method\n     * @memberof MRecordRTC\n     * @example\n     * recorder.startRecording();\n     */\n    this.startRecording = function() {\n        var mediaType = this.mediaType;\n        var recorderType;\n        var mimeType = this.mimeType || {\n            audio: null,\n            video: null,\n            gif: null\n        };\n\n        if (typeof mediaType.audio !== 'function' && isMediaRecorderCompatible() && !getTracks(mediaStream, 'audio').length) {\n            mediaType.audio = false;\n        }\n\n        if (typeof mediaType.video !== 'function' && isMediaRecorderCompatible() && !getTracks(mediaStream, 'video').length) {\n            mediaType.video = false;\n        }\n\n        if (typeof mediaType.gif !== 'function' && isMediaRecorderCompatible() && !getTracks(mediaStream, 'video').length) {\n            mediaType.gif = false;\n        }\n\n        if (!mediaType.audio && !mediaType.video && !mediaType.gif) {\n            throw 'MediaStream must have either audio or video tracks.';\n        }\n\n        if (!!mediaType.audio) {\n            recorderType = null;\n            if (typeof mediaType.audio === 'function') {\n                recorderType = mediaType.audio;\n            }\n\n            this.audioRecorder = new RecordRTC(mediaStream, {\n                type: 'audio',\n                bufferSize: this.bufferSize,\n                sampleRate: this.sampleRate,\n                numberOfAudioChannels: this.numberOfAudioChannels || 2,\n                disableLogs: this.disableLogs,\n                recorderType: recorderType,\n                mimeType: mimeType.audio,\n                timeSlice: this.timeSlice,\n                onTimeStamp: this.onTimeStamp\n            });\n\n            if (!mediaType.video) {\n                this.audioRecorder.startRecording();\n            }\n        }\n\n        if (!!mediaType.video) {\n            recorderType = null;\n            if (typeof mediaType.video === 'function') {\n                recorderType = mediaType.video;\n            }\n\n            var newStream = mediaStream;\n\n            if (isMediaRecorderCompatible() && !!mediaType.audio && typeof mediaType.audio === 'function') {\n                var videoTrack = getTracks(mediaStream, 'video')[0];\n\n                if (isFirefox) {\n                    newStream = new MediaStream();\n                    newStream.addTrack(videoTrack);\n\n                    if (recorderType && recorderType === WhammyRecorder) {\n                        // Firefox does NOT supports webp-encoding yet\n                        // But Firefox do supports WebAssemblyRecorder\n                        recorderType = MediaStreamRecorder;\n                    }\n                } else {\n                    newStream = new MediaStream();\n                    newStream.addTrack(videoTrack);\n                }\n            }\n\n            this.videoRecorder = new RecordRTC(newStream, {\n                type: 'video',\n                video: this.video,\n                canvas: this.canvas,\n                frameInterval: this.frameInterval || 10,\n                disableLogs: this.disableLogs,\n                recorderType: recorderType,\n                mimeType: mimeType.video,\n                timeSlice: this.timeSlice,\n                onTimeStamp: this.onTimeStamp,\n                workerPath: this.workerPath,\n                webAssemblyPath: this.webAssemblyPath,\n                frameRate: this.frameRate, // used by WebAssemblyRecorder; values: usually 30; accepts any.\n                bitrate: this.bitrate // used by WebAssemblyRecorder; values: 0 to 1000+\n            });\n\n            if (!mediaType.audio) {\n                this.videoRecorder.startRecording();\n            }\n        }\n\n        if (!!mediaType.audio && !!mediaType.video) {\n            var self = this;\n\n            var isSingleRecorder = isMediaRecorderCompatible() === true;\n\n            if (mediaType.audio instanceof StereoAudioRecorder && !!mediaType.video) {\n                isSingleRecorder = false;\n            } else if (mediaType.audio !== true && mediaType.video !== true && mediaType.audio !== mediaType.video) {\n                isSingleRecorder = false;\n            }\n\n            if (isSingleRecorder === true) {\n                self.audioRecorder = null;\n                self.videoRecorder.startRecording();\n            } else {\n                self.videoRecorder.initRecorder(function() {\n                    self.audioRecorder.initRecorder(function() {\n                        // Both recorders are ready to record things accurately\n                        self.videoRecorder.startRecording();\n                        self.audioRecorder.startRecording();\n                    });\n                });\n            }\n        }\n\n        if (!!mediaType.gif) {\n            recorderType = null;\n            if (typeof mediaType.gif === 'function') {\n                recorderType = mediaType.gif;\n            }\n            this.gifRecorder = new RecordRTC(mediaStream, {\n                type: 'gif',\n                frameRate: this.frameRate || 200,\n                quality: this.quality || 10,\n                disableLogs: this.disableLogs,\n                recorderType: recorderType,\n                mimeType: mimeType.gif\n            });\n            this.gifRecorder.startRecording();\n        }\n    };\n\n    /**\n     * This method stops recording.\n     * @param {function} callback - Callback function is invoked when all encoders finished their jobs.\n     * @method\n     * @memberof MRecordRTC\n     * @example\n     * recorder.stopRecording(function(recording){\n     *     var audioBlob = recording.audio;\n     *     var videoBlob = recording.video;\n     *     var gifBlob   = recording.gif;\n     * });\n     */\n    this.stopRecording = function(callback) {\n        callback = callback || function() {};\n\n        if (this.audioRecorder) {\n            this.audioRecorder.stopRecording(function(blobURL) {\n                callback(blobURL, 'audio');\n            });\n        }\n\n        if (this.videoRecorder) {\n            this.videoRecorder.stopRecording(function(blobURL) {\n                callback(blobURL, 'video');\n            });\n        }\n\n        if (this.gifRecorder) {\n            this.gifRecorder.stopRecording(function(blobURL) {\n                callback(blobURL, 'gif');\n            });\n        }\n    };\n\n    /**\n     * This method pauses recording.\n     * @method\n     * @memberof MRecordRTC\n     * @example\n     * recorder.pauseRecording();\n     */\n    this.pauseRecording = function() {\n        if (this.audioRecorder) {\n            this.audioRecorder.pauseRecording();\n        }\n\n        if (this.videoRecorder) {\n            this.videoRecorder.pauseRecording();\n        }\n\n        if (this.gifRecorder) {\n            this.gifRecorder.pauseRecording();\n        }\n    };\n\n    /**\n     * This method resumes recording.\n     * @method\n     * @memberof MRecordRTC\n     * @example\n     * recorder.resumeRecording();\n     */\n    this.resumeRecording = function() {\n        if (this.audioRecorder) {\n            this.audioRecorder.resumeRecording();\n        }\n\n        if (this.videoRecorder) {\n            this.videoRecorder.resumeRecording();\n        }\n\n        if (this.gifRecorder) {\n            this.gifRecorder.resumeRecording();\n        }\n    };\n\n    /**\n     * This method can be used to manually get all recorded blobs.\n     * @param {function} callback - All recorded blobs are passed back to the \"callback\" function.\n     * @method\n     * @memberof MRecordRTC\n     * @example\n     * recorder.getBlob(function(recording){\n     *     var audioBlob = recording.audio;\n     *     var videoBlob = recording.video;\n     *     var gifBlob   = recording.gif;\n     * });\n     * // or\n     * var audioBlob = recorder.getBlob().audio;\n     * var videoBlob = recorder.getBlob().video;\n     */\n    this.getBlob = function(callback) {\n        var output = {};\n\n        if (this.audioRecorder) {\n            output.audio = this.audioRecorder.getBlob();\n        }\n\n        if (this.videoRecorder) {\n            output.video = this.videoRecorder.getBlob();\n        }\n\n        if (this.gifRecorder) {\n            output.gif = this.gifRecorder.getBlob();\n        }\n\n        if (callback) {\n            callback(output);\n        }\n\n        return output;\n    };\n\n    /**\n     * Destroy all recorder instances.\n     * @method\n     * @memberof MRecordRTC\n     * @example\n     * recorder.destroy();\n     */\n    this.destroy = function() {\n        if (this.audioRecorder) {\n            this.audioRecorder.destroy();\n            this.audioRecorder = null;\n        }\n\n        if (this.videoRecorder) {\n            this.videoRecorder.destroy();\n            this.videoRecorder = null;\n        }\n\n        if (this.gifRecorder) {\n            this.gifRecorder.destroy();\n            this.gifRecorder = null;\n        }\n    };\n\n    /**\n     * This method can be used to manually get all recorded blobs' DataURLs.\n     * @param {function} callback - All recorded blobs' DataURLs are passed back to the \"callback\" function.\n     * @method\n     * @memberof MRecordRTC\n     * @example\n     * recorder.getDataURL(function(recording){\n     *     var audioDataURL = recording.audio;\n     *     var videoDataURL = recording.video;\n     *     var gifDataURL   = recording.gif;\n     * });\n     */\n    this.getDataURL = function(callback) {\n        this.getBlob(function(blob) {\n            if (blob.audio && blob.video) {\n                getDataURL(blob.audio, function(_audioDataURL) {\n                    getDataURL(blob.video, function(_videoDataURL) {\n                        callback({\n                            audio: _audioDataURL,\n                            video: _videoDataURL\n                        });\n                    });\n                });\n            } else if (blob.audio) {\n                getDataURL(blob.audio, function(_audioDataURL) {\n                    callback({\n                        audio: _audioDataURL\n                    });\n                });\n            } else if (blob.video) {\n                getDataURL(blob.video, function(_videoDataURL) {\n                    callback({\n                        video: _videoDataURL\n                    });\n                });\n            }\n        });\n\n        function getDataURL(blob, callback00) {\n            if (typeof Worker !== 'undefined') {\n                var webWorker = processInWebWorker(function readFile(_blob) {\n                    postMessage(new FileReaderSync().readAsDataURL(_blob));\n                });\n\n                webWorker.onmessage = function(event) {\n                    callback00(event.data);\n                };\n\n                webWorker.postMessage(blob);\n            } else {\n                var reader = new FileReader();\n                reader.readAsDataURL(blob);\n                reader.onload = function(event) {\n                    callback00(event.target.result);\n                };\n            }\n        }\n\n        function processInWebWorker(_function) {\n            var blob = URL.createObjectURL(new Blob([_function.toString(),\n                'this.onmessage =  function (eee) {' + _function.name + '(eee.data);}'\n            ], {\n                type: 'application/javascript'\n            }));\n\n            var worker = new Worker(blob);\n            var url;\n            if (typeof URL !== 'undefined') {\n                url = URL;\n            } else if (typeof webkitURL !== 'undefined') {\n                url = webkitURL;\n            } else {\n                throw 'Neither URL nor webkitURL detected.';\n            }\n            url.revokeObjectURL(blob);\n            return worker;\n        }\n    };\n\n    /**\n     * This method can be used to ask {@link MRecordRTC} to write all recorded blobs into IndexedDB storage.\n     * @method\n     * @memberof MRecordRTC\n     * @example\n     * recorder.writeToDisk();\n     */\n    this.writeToDisk = function() {\n        RecordRTC.writeToDisk({\n            audio: this.audioRecorder,\n            video: this.videoRecorder,\n            gif: this.gifRecorder\n        });\n    };\n\n    /**\n     * This method can be used to invoke a save-as dialog for all recorded blobs.\n     * @param {object} args - {audio: 'audio-name', video: 'video-name', gif: 'gif-name'}\n     * @method\n     * @memberof MRecordRTC\n     * @example\n     * recorder.save({\n     *     audio: 'audio-file-name',\n     *     video: 'video-file-name',\n     *     gif  : 'gif-file-name'\n     * });\n     */\n    this.save = function(args) {\n        args = args || {\n            audio: true,\n            video: true,\n            gif: true\n        };\n\n        if (!!args.audio && this.audioRecorder) {\n            this.audioRecorder.save(typeof args.audio === 'string' ? args.audio : '');\n        }\n\n        if (!!args.video && this.videoRecorder) {\n            this.videoRecorder.save(typeof args.video === 'string' ? args.video : '');\n        }\n        if (!!args.gif && this.gifRecorder) {\n            this.gifRecorder.save(typeof args.gif === 'string' ? args.gif : '');\n        }\n    };\n}\n\n/**\n * This method can be used to get all recorded blobs from IndexedDB storage.\n * @param {string} type - 'all' or 'audio' or 'video' or 'gif'\n * @param {function} callback - Callback function to get all stored blobs.\n * @method\n * @memberof MRecordRTC\n * @example\n * MRecordRTC.getFromDisk('all', function(dataURL, type){\n *     if(type === 'audio') { }\n *     if(type === 'video') { }\n *     if(type === 'gif')   { }\n * });\n */\nMRecordRTC.getFromDisk = RecordRTC.getFromDisk;\n\n/**\n * This method can be used to store recorded blobs into IndexedDB storage.\n * @param {object} options - {audio: Blob, video: Blob, gif: Blob}\n * @method\n * @memberof MRecordRTC\n * @example\n * MRecordRTC.writeToDisk({\n *     audio: audioBlob,\n *     video: videoBlob,\n *     gif  : gifBlob\n * });\n */\nMRecordRTC.writeToDisk = RecordRTC.writeToDisk;\n\nif (typeof RecordRTC !== 'undefined') {\n    RecordRTC.MRecordRTC = MRecordRTC;\n}\n\nvar browserFakeUserAgent = 'Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45';\n\n(function(that) {\n    if (!that) {\n        return;\n    }\n\n    if (typeof window !== 'undefined') {\n        return;\n    }\n\n    if (typeof global === 'undefined') {\n        return;\n    }\n\n    global.navigator = {\n        userAgent: browserFakeUserAgent,\n        getUserMedia: function() {}\n    };\n\n    if (!global.console) {\n        global.console = {};\n    }\n\n    if (typeof global.console.log === 'undefined' || typeof global.console.error === 'undefined') {\n        global.console.error = global.console.log = global.console.log || function() {\n            console.log(arguments);\n        };\n    }\n\n    if (typeof document === 'undefined') {\n        /*global document:true */\n        that.document = {\n            documentElement: {\n                appendChild: function() {\n                    return '';\n                }\n            }\n        };\n\n        document.createElement = document.captureStream = document.mozCaptureStream = function() {\n            var obj = {\n                getContext: function() {\n                    return obj;\n                },\n                play: function() {},\n                pause: function() {},\n                drawImage: function() {},\n                toDataURL: function() {\n                    return '';\n                },\n                style: {}\n            };\n            return obj;\n        };\n\n        that.HTMLVideoElement = function() {};\n    }\n\n    if (typeof location === 'undefined') {\n        /*global location:true */\n        that.location = {\n            protocol: 'file:',\n            href: '',\n            hash: ''\n        };\n    }\n\n    if (typeof screen === 'undefined') {\n        /*global screen:true */\n        that.screen = {\n            width: 0,\n            height: 0\n        };\n    }\n\n    if (typeof URL === 'undefined') {\n        /*global screen:true */\n        that.URL = {\n            createObjectURL: function() {\n                return '';\n            },\n            revokeObjectURL: function() {\n                return '';\n            }\n        };\n    }\n\n    /*global window:true */\n    that.window = global;\n})(typeof global !== 'undefined' ? global : null);\n\n// _____________________________\n// Cross-Browser-Declarations.js\n\n// animation-frame used in WebM recording\n\n/*jshint -W079 */\nvar requestAnimationFrame = window.requestAnimationFrame;\nif (typeof requestAnimationFrame === 'undefined') {\n    if (typeof webkitRequestAnimationFrame !== 'undefined') {\n        /*global requestAnimationFrame:true */\n        requestAnimationFrame = webkitRequestAnimationFrame;\n    } else if (typeof mozRequestAnimationFrame !== 'undefined') {\n        /*global requestAnimationFrame:true */\n        requestAnimationFrame = mozRequestAnimationFrame;\n    } else if (typeof msRequestAnimationFrame !== 'undefined') {\n        /*global requestAnimationFrame:true */\n        requestAnimationFrame = msRequestAnimationFrame;\n    } else if (typeof requestAnimationFrame === 'undefined') {\n        // via: https://gist.github.com/paulirish/1579671\n        var lastTime = 0;\n\n        /*global requestAnimationFrame:true */\n        requestAnimationFrame = function(callback, element) {\n            var currTime = new Date().getTime();\n            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n            var id = setTimeout(function() {\n                callback(currTime + timeToCall);\n            }, timeToCall);\n            lastTime = currTime + timeToCall;\n            return id;\n        };\n    }\n}\n\n/*jshint -W079 */\nvar cancelAnimationFrame = window.cancelAnimationFrame;\nif (typeof cancelAnimationFrame === 'undefined') {\n    if (typeof webkitCancelAnimationFrame !== 'undefined') {\n        /*global cancelAnimationFrame:true */\n        cancelAnimationFrame = webkitCancelAnimationFrame;\n    } else if (typeof mozCancelAnimationFrame !== 'undefined') {\n        /*global cancelAnimationFrame:true */\n        cancelAnimationFrame = mozCancelAnimationFrame;\n    } else if (typeof msCancelAnimationFrame !== 'undefined') {\n        /*global cancelAnimationFrame:true */\n        cancelAnimationFrame = msCancelAnimationFrame;\n    } else if (typeof cancelAnimationFrame === 'undefined') {\n        /*global cancelAnimationFrame:true */\n        cancelAnimationFrame = function(id) {\n            clearTimeout(id);\n        };\n    }\n}\n\n// WebAudio API representer\nvar AudioContext = window.AudioContext;\n\nif (typeof AudioContext === 'undefined') {\n    if (typeof webkitAudioContext !== 'undefined') {\n        /*global AudioContext:true */\n        AudioContext = webkitAudioContext;\n    }\n\n    if (typeof mozAudioContext !== 'undefined') {\n        /*global AudioContext:true */\n        AudioContext = mozAudioContext;\n    }\n}\n\n/*jshint -W079 */\nvar URL = window.URL;\n\nif (typeof URL === 'undefined' && typeof webkitURL !== 'undefined') {\n    /*global URL:true */\n    URL = webkitURL;\n}\n\nif (typeof navigator !== 'undefined' && typeof navigator.getUserMedia === 'undefined') { // maybe window.navigator?\n    if (typeof navigator.webkitGetUserMedia !== 'undefined') {\n        navigator.getUserMedia = navigator.webkitGetUserMedia;\n    }\n\n    if (typeof navigator.mozGetUserMedia !== 'undefined') {\n        navigator.getUserMedia = navigator.mozGetUserMedia;\n    }\n}\n\nvar isEdge = navigator.userAgent.indexOf('Edge') !== -1 && (!!navigator.msSaveBlob || !!navigator.msSaveOrOpenBlob);\nvar isOpera = !!window.opera || navigator.userAgent.indexOf('OPR/') !== -1;\nvar isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1 && ('netscape' in window) && / rv:/.test(navigator.userAgent);\nvar isChrome = (!isOpera && !isEdge && !!navigator.webkitGetUserMedia) || isElectron() || navigator.userAgent.toLowerCase().indexOf('chrome/') !== -1;\n\nvar isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n\nif (isSafari && !isChrome && navigator.userAgent.indexOf('CriOS') !== -1) {\n    isSafari = false;\n    isChrome = true;\n}\n\nvar MediaStream = window.MediaStream;\n\nif (typeof MediaStream === 'undefined' && typeof webkitMediaStream !== 'undefined') {\n    MediaStream = webkitMediaStream;\n}\n\n/*global MediaStream:true */\nif (typeof MediaStream !== 'undefined') {\n    // override \"stop\" method for all browsers\n    if (typeof MediaStream.prototype.stop === 'undefined') {\n        MediaStream.prototype.stop = function() {\n            this.getTracks().forEach(function(track) {\n                track.stop();\n            });\n        };\n    }\n}\n\n// below function via: http://goo.gl/B3ae8c\n/**\n * Return human-readable file size.\n * @param {number} bytes - Pass bytes and get formatted string.\n * @returns {string} - formatted string\n * @example\n * bytesToSize(1024*1024*5) === '5 GB'\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n */\nfunction bytesToSize(bytes) {\n    var k = 1000;\n    var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n    if (bytes === 0) {\n        return '0 Bytes';\n    }\n    var i = parseInt(Math.floor(Math.log(bytes) / Math.log(k)), 10);\n    return (bytes / Math.pow(k, i)).toPrecision(3) + ' ' + sizes[i];\n}\n\n/**\n * @param {Blob} file - File or Blob object. This parameter is required.\n * @param {string} fileName - Optional file name e.g. \"Recorded-Video.webm\"\n * @example\n * invokeSaveAsDialog(blob or file, [optional] fileName);\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n */\nfunction invokeSaveAsDialog(file, fileName) {\n    if (!file) {\n        throw 'Blob object is required.';\n    }\n\n    if (!file.type) {\n        try {\n            file.type = 'video/webm';\n        } catch (e) {}\n    }\n\n    var fileExtension = (file.type || 'video/webm').split('/')[1];\n    if (fileExtension.indexOf(';') !== -1) {\n        // extended mimetype, e.g. 'video/webm;codecs=vp8,opus'\n        fileExtension = fileExtension.split(';')[0];\n    }\n    if (fileName && fileName.indexOf('.') !== -1) {\n        var splitted = fileName.split('.');\n        fileName = splitted[0];\n        fileExtension = splitted[1];\n    }\n\n    var fileFullName = (fileName || (Math.round(Math.random() * 9999999999) + 888888888)) + '.' + fileExtension;\n\n    if (typeof navigator.msSaveOrOpenBlob !== 'undefined') {\n        return navigator.msSaveOrOpenBlob(file, fileFullName);\n    } else if (typeof navigator.msSaveBlob !== 'undefined') {\n        return navigator.msSaveBlob(file, fileFullName);\n    }\n\n    var hyperlink = document.createElement('a');\n    hyperlink.href = URL.createObjectURL(file);\n    hyperlink.download = fileFullName;\n\n    hyperlink.style = 'display:none;opacity:0;color:transparent;';\n    (document.body || document.documentElement).appendChild(hyperlink);\n\n    if (typeof hyperlink.click === 'function') {\n        hyperlink.click();\n    } else {\n        hyperlink.target = '_blank';\n        hyperlink.dispatchEvent(new MouseEvent('click', {\n            view: window,\n            bubbles: true,\n            cancelable: true\n        }));\n    }\n\n    URL.revokeObjectURL(hyperlink.href);\n}\n\n/**\n * from: https://github.com/cheton/is-electron/blob/master/index.js\n **/\nfunction isElectron() {\n    // Renderer process\n    if (typeof window !== 'undefined' && typeof window.process === 'object' && window.process.type === 'renderer') {\n        return true;\n    }\n\n    // Main process\n    if (typeof process !== 'undefined' && typeof process.versions === 'object' && !!process.versions.electron) {\n        return true;\n    }\n\n    // Detect the user agent when the `nodeIntegration` option is set to true\n    if (typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent.indexOf('Electron') >= 0) {\n        return true;\n    }\n\n    return false;\n}\n\nfunction getTracks(stream, kind) {\n    if (!stream || !stream.getTracks) {\n        return [];\n    }\n\n    return stream.getTracks().filter(function(t) {\n        return t.kind === (kind || 'audio');\n    });\n}\n\nfunction setSrcObject(stream, element) {\n    if ('srcObject' in element) {\n        element.srcObject = stream;\n    } else if ('mozSrcObject' in element) {\n        element.mozSrcObject = stream;\n    } else {\n        element.srcObject = stream;\n    }\n}\n\n/**\n * @param {Blob} file - File or Blob object.\n * @param {function} callback - Callback function.\n * @example\n * getSeekableBlob(blob or file, callback);\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n */\nfunction getSeekableBlob(inputBlob, callback) {\n    // EBML.js copyrights goes to: https://github.com/legokichi/ts-ebml\n    if (typeof EBML === 'undefined') {\n        throw new Error('Please link: https://www.webrtc-experiment.com/EBML.js');\n    }\n\n    var reader = new EBML.Reader();\n    var decoder = new EBML.Decoder();\n    var tools = EBML.tools;\n\n    var fileReader = new FileReader();\n    fileReader.onload = function(e) {\n        var ebmlElms = decoder.decode(this.result);\n        ebmlElms.forEach(function(element) {\n            reader.read(element);\n        });\n        reader.stop();\n        var refinedMetadataBuf = tools.makeMetadataSeekable(reader.metadatas, reader.duration, reader.cues);\n        var body = this.result.slice(reader.metadataSize);\n        var newBlob = new Blob([refinedMetadataBuf, body], {\n            type: 'video/webm'\n        });\n\n        callback(newBlob);\n    };\n    fileReader.readAsArrayBuffer(inputBlob);\n}\n\nif (typeof RecordRTC !== 'undefined') {\n    RecordRTC.invokeSaveAsDialog = invokeSaveAsDialog;\n    RecordRTC.getTracks = getTracks;\n    RecordRTC.getSeekableBlob = getSeekableBlob;\n    RecordRTC.bytesToSize = bytesToSize;\n    RecordRTC.isElectron = isElectron;\n}\n\n// __________ (used to handle stuff like http://goo.gl/xmE5eg) issue #129\n// Storage.js\n\n/**\n * Storage is a standalone object used by {@link RecordRTC} to store reusable objects e.g. \"new AudioContext\".\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @example\n * Storage.AudioContext === webkitAudioContext\n * @property {webkitAudioContext} AudioContext - Keeps a reference to AudioContext object.\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n */\n\nvar Storage = {};\n\nif (typeof AudioContext !== 'undefined') {\n    Storage.AudioContext = AudioContext;\n} else if (typeof webkitAudioContext !== 'undefined') {\n    Storage.AudioContext = webkitAudioContext;\n}\n\nif (typeof RecordRTC !== 'undefined') {\n    RecordRTC.Storage = Storage;\n}\n\nfunction isMediaRecorderCompatible() {\n    if (isFirefox || isSafari || isEdge) {\n        return true;\n    }\n\n    var nVer = navigator.appVersion;\n    var nAgt = navigator.userAgent;\n    var fullVersion = '' + parseFloat(navigator.appVersion);\n    var majorVersion = parseInt(navigator.appVersion, 10);\n    var nameOffset, verOffset, ix;\n\n    if (isChrome || isOpera) {\n        verOffset = nAgt.indexOf('Chrome');\n        fullVersion = nAgt.substring(verOffset + 7);\n    }\n\n    // trim the fullVersion string at semicolon/space if present\n    if ((ix = fullVersion.indexOf(';')) !== -1) {\n        fullVersion = fullVersion.substring(0, ix);\n    }\n\n    if ((ix = fullVersion.indexOf(' ')) !== -1) {\n        fullVersion = fullVersion.substring(0, ix);\n    }\n\n    majorVersion = parseInt('' + fullVersion, 10);\n\n    if (isNaN(majorVersion)) {\n        fullVersion = '' + parseFloat(navigator.appVersion);\n        majorVersion = parseInt(navigator.appVersion, 10);\n    }\n\n    return majorVersion >= 49;\n}\n\n// ______________________\n// MediaStreamRecorder.js\n\n/**\n * MediaStreamRecorder is an abstraction layer for {@link https://w3c.github.io/mediacapture-record/MediaRecorder.html|MediaRecorder API}. It is used by {@link RecordRTC} to record MediaStream(s) in both Chrome and Firefox.\n * @summary Runs top over {@link https://w3c.github.io/mediacapture-record/MediaRecorder.html|MediaRecorder API}.\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://github.com/muaz-khan|Muaz Khan}\n * @typedef MediaStreamRecorder\n * @class\n * @example\n * var config = {\n *     mimeType: 'video/webm', // vp8, vp9, h264, mkv, opus/vorbis\n *     audioBitsPerSecond : 256 * 8 * 1024,\n *     videoBitsPerSecond : 256 * 8 * 1024,\n *     bitsPerSecond: 256 * 8 * 1024,  // if this is provided, skip above two\n *     checkForInactiveTracks: true,\n *     timeSlice: 1000, // concatenate intervals based blobs\n *     ondataavailable: function() {} // get intervals based blobs\n * }\n * var recorder = new MediaStreamRecorder(mediaStream, config);\n * recorder.record();\n * recorder.stop(function(blob) {\n *     video.src = URL.createObjectURL(blob);\n *\n *     // or\n *     var blob = recorder.blob;\n * });\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\n * @param {object} config - {disableLogs:true, initCallback: function, mimeType: \"video/webm\", timeSlice: 1000}\n * @throws Will throw an error if first argument \"MediaStream\" is missing. Also throws error if \"MediaRecorder API\" are not supported by the browser.\n */\n\nfunction MediaStreamRecorder(mediaStream, config) {\n    var self = this;\n\n    if (typeof mediaStream === 'undefined') {\n        throw 'First argument \"MediaStream\" is required.';\n    }\n\n    if (typeof MediaRecorder === 'undefined') {\n        throw 'Your browser does not support the Media Recorder API. Please try other modules e.g. WhammyRecorder or StereoAudioRecorder.';\n    }\n\n    config = config || {\n        // bitsPerSecond: 256 * 8 * 1024,\n        mimeType: 'video/webm'\n    };\n\n    if (config.type === 'audio') {\n        if (getTracks(mediaStream, 'video').length && getTracks(mediaStream, 'audio').length) {\n            var stream;\n            if (!!navigator.mozGetUserMedia) {\n                stream = new MediaStream();\n                stream.addTrack(getTracks(mediaStream, 'audio')[0]);\n            } else {\n                // webkitMediaStream\n                stream = new MediaStream(getTracks(mediaStream, 'audio'));\n            }\n            mediaStream = stream;\n        }\n\n        if (!config.mimeType || config.mimeType.toString().toLowerCase().indexOf('audio') === -1) {\n            config.mimeType = isChrome ? 'audio/webm' : 'audio/ogg';\n        }\n\n        if (config.mimeType && config.mimeType.toString().toLowerCase() !== 'audio/ogg' && !!navigator.mozGetUserMedia) {\n            // forcing better codecs on Firefox (via #166)\n            config.mimeType = 'audio/ogg';\n        }\n    }\n\n    var arrayOfBlobs = [];\n\n    /**\n     * This method returns array of blobs. Use only with \"timeSlice\". Its useful to preview recording anytime, without using the \"stop\" method.\n     * @method\n     * @memberof MediaStreamRecorder\n     * @example\n     * var arrayOfBlobs = recorder.getArrayOfBlobs();\n     * @returns {Array} Returns array of recorded blobs.\n     */\n    this.getArrayOfBlobs = function() {\n        return arrayOfBlobs;\n    };\n\n    /**\n     * This method records MediaStream.\n     * @method\n     * @memberof MediaStreamRecorder\n     * @example\n     * recorder.record();\n     */\n    this.record = function() {\n        // set defaults\n        self.blob = null;\n        self.clearRecordedData();\n        self.timestamps = [];\n        allStates = [];\n        arrayOfBlobs = [];\n\n        var recorderHints = config;\n\n        if (!config.disableLogs) {\n            console.log('Passing following config over MediaRecorder API.', recorderHints);\n        }\n\n        if (mediaRecorder) {\n            // mandatory to make sure Firefox doesn't fails to record streams 3-4 times without reloading the page.\n            mediaRecorder = null;\n        }\n\n        if (isChrome && !isMediaRecorderCompatible()) {\n            // to support video-only recording on stable\n            recorderHints = 'video/vp8';\n        }\n\n        if (typeof MediaRecorder.isTypeSupported === 'function' && recorderHints.mimeType) {\n            if (!MediaRecorder.isTypeSupported(recorderHints.mimeType)) {\n                if (!config.disableLogs) {\n                    console.warn('MediaRecorder API seems unable to record mimeType:', recorderHints.mimeType);\n                }\n\n                recorderHints.mimeType = config.type === 'audio' ? 'audio/webm' : 'video/webm';\n            }\n        }\n\n        // using MediaRecorder API here\n        try {\n            mediaRecorder = new MediaRecorder(mediaStream, recorderHints);\n\n            // reset\n            config.mimeType = recorderHints.mimeType;\n        } catch (e) {\n            // chrome-based fallback\n            mediaRecorder = new MediaRecorder(mediaStream);\n        }\n\n        // old hack?\n        if (recorderHints.mimeType && !MediaRecorder.isTypeSupported && 'canRecordMimeType' in mediaRecorder && mediaRecorder.canRecordMimeType(recorderHints.mimeType) === false) {\n            if (!config.disableLogs) {\n                console.warn('MediaRecorder API seems unable to record mimeType:', recorderHints.mimeType);\n            }\n        }\n\n        // Dispatching OnDataAvailable Handler\n        mediaRecorder.ondataavailable = function(e) {\n            if (e.data) {\n                allStates.push('ondataavailable: ' + bytesToSize(e.data.size));\n            }\n\n            if (typeof config.timeSlice === 'number') {\n                if (e.data && e.data.size) {\n                    arrayOfBlobs.push(e.data);\n                    updateTimeStamp();\n\n                    if (typeof config.ondataavailable === 'function') {\n                        // intervals based blobs\n                        var blob = config.getNativeBlob ? e.data : new Blob([e.data], {\n                            type: getMimeType(recorderHints)\n                        });\n                        config.ondataavailable(blob);\n                    }\n                }\n                return;\n            }\n\n            if (!e.data || !e.data.size || e.data.size < 100 || self.blob) {\n                // make sure that stopRecording always getting fired\n                // even if there is invalid data\n                if (self.recordingCallback) {\n                    self.recordingCallback(new Blob([], {\n                        type: getMimeType(recorderHints)\n                    }));\n                    self.recordingCallback = null;\n                }\n                return;\n            }\n\n            self.blob = config.getNativeBlob ? e.data : new Blob([e.data], {\n                type: getMimeType(recorderHints)\n            });\n\n            if (self.recordingCallback) {\n                self.recordingCallback(self.blob);\n                self.recordingCallback = null;\n            }\n        };\n\n        mediaRecorder.onstart = function() {\n            allStates.push('started');\n        };\n\n        mediaRecorder.onpause = function() {\n            allStates.push('paused');\n        };\n\n        mediaRecorder.onresume = function() {\n            allStates.push('resumed');\n        };\n\n        mediaRecorder.onstop = function() {\n            allStates.push('stopped');\n        };\n\n        mediaRecorder.onerror = function(error) {\n            if (!error) {\n                return;\n            }\n\n            if (!error.name) {\n                error.name = 'UnknownError';\n            }\n\n            allStates.push('error: ' + error);\n\n            if (!config.disableLogs) {\n                // via: https://w3c.github.io/mediacapture-record/MediaRecorder.html#exception-summary\n                if (error.name.toString().toLowerCase().indexOf('invalidstate') !== -1) {\n                    console.error('The MediaRecorder is not in a state in which the proposed operation is allowed to be executed.', error);\n                } else if (error.name.toString().toLowerCase().indexOf('notsupported') !== -1) {\n                    console.error('MIME type (', recorderHints.mimeType, ') is not supported.', error);\n                } else if (error.name.toString().toLowerCase().indexOf('security') !== -1) {\n                    console.error('MediaRecorder security error', error);\n                }\n\n                // older code below\n                else if (error.name === 'OutOfMemory') {\n                    console.error('The UA has exhaused the available memory. User agents SHOULD provide as much additional information as possible in the message attribute.', error);\n                } else if (error.name === 'IllegalStreamModification') {\n                    console.error('A modification to the stream has occurred that makes it impossible to continue recording. An example would be the addition of a Track while recording is occurring. User agents SHOULD provide as much additional information as possible in the message attribute.', error);\n                } else if (error.name === 'OtherRecordingError') {\n                    console.error('Used for an fatal error other than those listed above. User agents SHOULD provide as much additional information as possible in the message attribute.', error);\n                } else if (error.name === 'GenericError') {\n                    console.error('The UA cannot provide the codec or recording option that has been requested.', error);\n                } else {\n                    console.error('MediaRecorder Error', error);\n                }\n            }\n\n            (function(looper) {\n                if (!self.manuallyStopped && mediaRecorder && mediaRecorder.state === 'inactive') {\n                    delete config.timeslice;\n\n                    // 10 minutes, enough?\n                    mediaRecorder.start(10 * 60 * 1000);\n                    return;\n                }\n\n                setTimeout(looper, 1000);\n            })();\n\n            if (mediaRecorder.state !== 'inactive' && mediaRecorder.state !== 'stopped') {\n                mediaRecorder.stop();\n            }\n        };\n\n        if (typeof config.timeSlice === 'number') {\n            updateTimeStamp();\n            mediaRecorder.start(config.timeSlice);\n        } else {\n            // default is 60 minutes; enough?\n            // use config => {timeSlice: 1000} otherwise\n\n            mediaRecorder.start(3.6e+6);\n        }\n\n        if (config.initCallback) {\n            config.initCallback(); // old code\n        }\n    };\n\n    /**\n     * @property {Array} timestamps - Array of time stamps\n     * @memberof MediaStreamRecorder\n     * @example\n     * console.log(recorder.timestamps);\n     */\n    this.timestamps = [];\n\n    function updateTimeStamp() {\n        self.timestamps.push(new Date().getTime());\n\n        if (typeof config.onTimeStamp === 'function') {\n            config.onTimeStamp(self.timestamps[self.timestamps.length - 1], self.timestamps);\n        }\n    }\n\n    function getMimeType(secondObject) {\n        if (mediaRecorder && mediaRecorder.mimeType) {\n            return mediaRecorder.mimeType;\n        }\n\n        return secondObject.mimeType || 'video/webm';\n    }\n\n    /**\n     * This method stops recording MediaStream.\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\n     * @method\n     * @memberof MediaStreamRecorder\n     * @example\n     * recorder.stop(function(blob) {\n     *     video.src = URL.createObjectURL(blob);\n     * });\n     */\n    this.stop = function(callback) {\n        callback = callback || function() {};\n\n        self.manuallyStopped = true; // used inside the mediaRecorder.onerror\n\n        if (!mediaRecorder) {\n            return;\n        }\n\n        this.recordingCallback = callback;\n\n        if (mediaRecorder.state === 'recording') {\n            mediaRecorder.stop();\n        }\n\n        if (typeof config.timeSlice === 'number') {\n            setTimeout(function() {\n                self.blob = new Blob(arrayOfBlobs, {\n                    type: getMimeType(config)\n                });\n\n                self.recordingCallback(self.blob);\n            }, 100);\n        }\n    };\n\n    /**\n     * This method pauses the recording process.\n     * @method\n     * @memberof MediaStreamRecorder\n     * @example\n     * recorder.pause();\n     */\n    this.pause = function() {\n        if (!mediaRecorder) {\n            return;\n        }\n\n        if (mediaRecorder.state === 'recording') {\n            mediaRecorder.pause();\n        }\n    };\n\n    /**\n     * This method resumes the recording process.\n     * @method\n     * @memberof MediaStreamRecorder\n     * @example\n     * recorder.resume();\n     */\n    this.resume = function() {\n        if (!mediaRecorder) {\n            return;\n        }\n\n        if (mediaRecorder.state === 'paused') {\n            mediaRecorder.resume();\n        }\n    };\n\n    /**\n     * This method resets currently recorded data.\n     * @method\n     * @memberof MediaStreamRecorder\n     * @example\n     * recorder.clearRecordedData();\n     */\n    this.clearRecordedData = function() {\n        if (mediaRecorder && mediaRecorder.state === 'recording') {\n            self.stop(clearRecordedDataCB);\n        }\n\n        clearRecordedDataCB();\n    };\n\n    function clearRecordedDataCB() {\n        arrayOfBlobs = [];\n        mediaRecorder = null;\n        self.timestamps = [];\n    }\n\n    // Reference to \"MediaRecorder\" object\n    var mediaRecorder;\n\n    /**\n     * Access to native MediaRecorder API\n     * @method\n     * @memberof MediaStreamRecorder\n     * @instance\n     * @example\n     * var internal = recorder.getInternalRecorder();\n     * internal.ondataavailable = function() {}; // override\n     * internal.stream, internal.onpause, internal.onstop, etc.\n     * @returns {Object} Returns internal recording object.\n     */\n    this.getInternalRecorder = function() {\n        return mediaRecorder;\n    };\n\n    function isMediaStreamActive() {\n        if ('active' in mediaStream) {\n            if (!mediaStream.active) {\n                return false;\n            }\n        } else if ('ended' in mediaStream) { // old hack\n            if (mediaStream.ended) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @property {Blob} blob - Recorded data as \"Blob\" object.\n     * @memberof MediaStreamRecorder\n     * @example\n     * recorder.stop(function() {\n     *     var blob = recorder.blob;\n     * });\n     */\n    this.blob = null;\n\n\n    /**\n     * Get MediaRecorder readonly state.\n     * @method\n     * @memberof MediaStreamRecorder\n     * @example\n     * var state = recorder.getState();\n     * @returns {String} Returns recording state.\n     */\n    this.getState = function() {\n        if (!mediaRecorder) {\n            return 'inactive';\n        }\n\n        return mediaRecorder.state || 'inactive';\n    };\n\n    // list of all recording states\n    var allStates = [];\n\n    /**\n     * Get MediaRecorder all recording states.\n     * @method\n     * @memberof MediaStreamRecorder\n     * @example\n     * var state = recorder.getAllStates();\n     * @returns {Array} Returns all recording states\n     */\n    this.getAllStates = function() {\n        return allStates;\n    };\n\n    // if any Track within the MediaStream is muted or not enabled at any time, \n    // the browser will only record black frames \n    // or silence since that is the content produced by the Track\n    // so we need to stopRecording as soon as any single track ends.\n    if (typeof config.checkForInactiveTracks === 'undefined') {\n        config.checkForInactiveTracks = false; // disable to minimize CPU usage\n    }\n\n    var self = this;\n\n    // this method checks if media stream is stopped\n    // or if any track is ended.\n    (function looper() {\n        if (!mediaRecorder || config.checkForInactiveTracks === false) {\n            return;\n        }\n\n        if (isMediaStreamActive() === false) {\n            if (!config.disableLogs) {\n                console.log('MediaStream seems stopped.');\n            }\n            self.stop();\n            return;\n        }\n\n        setTimeout(looper, 1000); // check every second\n    })();\n\n    // for debugging\n    this.name = 'MediaStreamRecorder';\n    this.toString = function() {\n        return this.name;\n    };\n}\n\nif (typeof RecordRTC !== 'undefined') {\n    RecordRTC.MediaStreamRecorder = MediaStreamRecorder;\n}\n\n// source code from: http://typedarray.org/wp-content/projects/WebAudioRecorder/script.js\n// https://github.com/mattdiamond/Recorderjs#license-mit\n// ______________________\n// StereoAudioRecorder.js\n\n/**\n * StereoAudioRecorder is a standalone class used by {@link RecordRTC} to bring \"stereo\" audio-recording in chrome.\n * @summary JavaScript standalone object for stereo audio recording.\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @typedef StereoAudioRecorder\n * @class\n * @example\n * var recorder = new StereoAudioRecorder(MediaStream, {\n *     sampleRate: 44100,\n *     bufferSize: 4096\n * });\n * recorder.record();\n * recorder.stop(function(blob) {\n *     video.src = URL.createObjectURL(blob);\n * });\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\n * @param {object} config - {sampleRate: 44100, bufferSize: 4096, numberOfAudioChannels: 1, etc.}\n */\n\nfunction StereoAudioRecorder(mediaStream, config) {\n    if (!getTracks(mediaStream, 'audio').length) {\n        throw 'Your stream has no audio tracks.';\n    }\n\n    config = config || {};\n\n    var self = this;\n\n    // variables\n    var leftchannel = [];\n    var rightchannel = [];\n    var recording = false;\n    var recordingLength = 0;\n    var jsAudioNode;\n\n    var numberOfAudioChannels = 2;\n\n    /**\n     * Set sample rates such as 8K or 16K. Reference: http://stackoverflow.com/a/28977136/552182\n     * @property {number} desiredSampRate - Desired Bits per sample * 1000\n     * @memberof StereoAudioRecorder\n     * @instance\n     * @example\n     * var recorder = StereoAudioRecorder(mediaStream, {\n     *   desiredSampRate: 16 * 1000 // bits-per-sample * 1000\n     * });\n     */\n    var desiredSampRate = config.desiredSampRate;\n\n    // backward compatibility\n    if (config.leftChannel === true) {\n        numberOfAudioChannels = 1;\n    }\n\n    if (config.numberOfAudioChannels === 1) {\n        numberOfAudioChannels = 1;\n    }\n\n    if (!numberOfAudioChannels || numberOfAudioChannels < 1) {\n        numberOfAudioChannels = 2;\n    }\n\n    if (!config.disableLogs) {\n        console.log('StereoAudioRecorder is set to record number of channels: ' + numberOfAudioChannels);\n    }\n\n    // if any Track within the MediaStream is muted or not enabled at any time, \n    // the browser will only record black frames \n    // or silence since that is the content produced by the Track\n    // so we need to stopRecording as soon as any single track ends.\n    if (typeof config.checkForInactiveTracks === 'undefined') {\n        config.checkForInactiveTracks = true;\n    }\n\n    function isMediaStreamActive() {\n        if (config.checkForInactiveTracks === false) {\n            // always return \"true\"\n            return true;\n        }\n\n        if ('active' in mediaStream) {\n            if (!mediaStream.active) {\n                return false;\n            }\n        } else if ('ended' in mediaStream) { // old hack\n            if (mediaStream.ended) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * This method records MediaStream.\n     * @method\n     * @memberof StereoAudioRecorder\n     * @example\n     * recorder.record();\n     */\n    this.record = function() {\n        if (isMediaStreamActive() === false) {\n            throw 'Please make sure MediaStream is active.';\n        }\n\n        resetVariables();\n\n        isAudioProcessStarted = isPaused = false;\n        recording = true;\n\n        if (typeof config.timeSlice !== 'undefined') {\n            looper();\n        }\n    };\n\n    function mergeLeftRightBuffers(config, callback) {\n        function mergeAudioBuffers(config, cb) {\n            var numberOfAudioChannels = config.numberOfAudioChannels;\n\n            // todo: \"slice(0)\" --- is it causes loop? Should be removed?\n            var leftBuffers = config.leftBuffers.slice(0);\n            var rightBuffers = config.rightBuffers.slice(0);\n            var sampleRate = config.sampleRate;\n            var internalInterleavedLength = config.internalInterleavedLength;\n            var desiredSampRate = config.desiredSampRate;\n\n            if (numberOfAudioChannels === 2) {\n                leftBuffers = mergeBuffers(leftBuffers, internalInterleavedLength);\n                rightBuffers = mergeBuffers(rightBuffers, internalInterleavedLength);\n\n                if (desiredSampRate) {\n                    leftBuffers = interpolateArray(leftBuffers, desiredSampRate, sampleRate);\n                    rightBuffers = interpolateArray(rightBuffers, desiredSampRate, sampleRate);\n                }\n            }\n\n            if (numberOfAudioChannels === 1) {\n                leftBuffers = mergeBuffers(leftBuffers, internalInterleavedLength);\n\n                if (desiredSampRate) {\n                    leftBuffers = interpolateArray(leftBuffers, desiredSampRate, sampleRate);\n                }\n            }\n\n            // set sample rate as desired sample rate\n            if (desiredSampRate) {\n                sampleRate = desiredSampRate;\n            }\n\n            // for changing the sampling rate, reference:\n            // http://stackoverflow.com/a/28977136/552182\n            function interpolateArray(data, newSampleRate, oldSampleRate) {\n                var fitCount = Math.round(data.length * (newSampleRate / oldSampleRate));\n                var newData = [];\n                var springFactor = Number((data.length - 1) / (fitCount - 1));\n                newData[0] = data[0];\n                for (var i = 1; i < fitCount - 1; i++) {\n                    var tmp = i * springFactor;\n                    var before = Number(Math.floor(tmp)).toFixed();\n                    var after = Number(Math.ceil(tmp)).toFixed();\n                    var atPoint = tmp - before;\n                    newData[i] = linearInterpolate(data[before], data[after], atPoint);\n                }\n                newData[fitCount - 1] = data[data.length - 1];\n                return newData;\n            }\n\n            function linearInterpolate(before, after, atPoint) {\n                return before + (after - before) * atPoint;\n            }\n\n            function mergeBuffers(channelBuffer, rLength) {\n                var result = new Float64Array(rLength);\n                var offset = 0;\n                var lng = channelBuffer.length;\n\n                for (var i = 0; i < lng; i++) {\n                    var buffer = channelBuffer[i];\n                    result.set(buffer, offset);\n                    offset += buffer.length;\n                }\n\n                return result;\n            }\n\n            function interleave(leftChannel, rightChannel) {\n                var length = leftChannel.length + rightChannel.length;\n\n                var result = new Float64Array(length);\n\n                var inputIndex = 0;\n\n                for (var index = 0; index < length;) {\n                    result[index++] = leftChannel[inputIndex];\n                    result[index++] = rightChannel[inputIndex];\n                    inputIndex++;\n                }\n                return result;\n            }\n\n            function writeUTFBytes(view, offset, string) {\n                var lng = string.length;\n                for (var i = 0; i < lng; i++) {\n                    view.setUint8(offset + i, string.charCodeAt(i));\n                }\n            }\n\n            // interleave both channels together\n            var interleaved;\n\n            if (numberOfAudioChannels === 2) {\n                interleaved = interleave(leftBuffers, rightBuffers);\n            }\n\n            if (numberOfAudioChannels === 1) {\n                interleaved = leftBuffers;\n            }\n\n            var interleavedLength = interleaved.length;\n\n            // create wav file\n            var resultingBufferLength = 44 + interleavedLength * 2;\n\n            var buffer = new ArrayBuffer(resultingBufferLength);\n\n            var view = new DataView(buffer);\n\n            // RIFF chunk descriptor/identifier \n            writeUTFBytes(view, 0, 'RIFF');\n\n            // RIFF chunk length\n            // changed \"44\" to \"36\" via #401\n            view.setUint32(4, 36 + interleavedLength * 2, true);\n\n            // RIFF type \n            writeUTFBytes(view, 8, 'WAVE');\n\n            // format chunk identifier \n            // FMT sub-chunk\n            writeUTFBytes(view, 12, 'fmt ');\n\n            // format chunk length \n            view.setUint32(16, 16, true);\n\n            // sample format (raw)\n            view.setUint16(20, 1, true);\n\n            // stereo (2 channels)\n            view.setUint16(22, numberOfAudioChannels, true);\n\n            // sample rate \n            view.setUint32(24, sampleRate, true);\n\n            // byte rate (sample rate * block align)\n            view.setUint32(28, sampleRate * numberOfAudioChannels * 2, true);\n\n            // block align (channel count * bytes per sample) \n            view.setUint16(32, numberOfAudioChannels * 2, true);\n\n            // bits per sample \n            view.setUint16(34, 16, true);\n\n            // data sub-chunk\n            // data chunk identifier \n            writeUTFBytes(view, 36, 'data');\n\n            // data chunk length \n            view.setUint32(40, interleavedLength * 2, true);\n\n            // write the PCM samples\n            var lng = interleavedLength;\n            var index = 44;\n            var volume = 1;\n            for (var i = 0; i < lng; i++) {\n                view.setInt16(index, interleaved[i] * (0x7FFF * volume), true);\n                index += 2;\n            }\n\n            if (cb) {\n                return cb({\n                    buffer: buffer,\n                    view: view\n                });\n            }\n\n            postMessage({\n                buffer: buffer,\n                view: view\n            });\n        }\n\n        if (config.noWorker) {\n            mergeAudioBuffers(config, function(data) {\n                callback(data.buffer, data.view);\n            });\n            return;\n        }\n\n\n        var webWorker = processInWebWorker(mergeAudioBuffers);\n\n        webWorker.onmessage = function(event) {\n            callback(event.data.buffer, event.data.view);\n\n            // release memory\n            URL.revokeObjectURL(webWorker.workerURL);\n\n            // kill webworker (or Chrome will kill your page after ~25 calls)\n            webWorker.terminate();\n        };\n\n        webWorker.postMessage(config);\n    }\n\n    function processInWebWorker(_function) {\n        var workerURL = URL.createObjectURL(new Blob([_function.toString(),\n            ';this.onmessage =  function (eee) {' + _function.name + '(eee.data);}'\n        ], {\n            type: 'application/javascript'\n        }));\n\n        var worker = new Worker(workerURL);\n        worker.workerURL = workerURL;\n        return worker;\n    }\n\n    /**\n     * This method stops recording MediaStream.\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\n     * @method\n     * @memberof StereoAudioRecorder\n     * @example\n     * recorder.stop(function(blob) {\n     *     video.src = URL.createObjectURL(blob);\n     * });\n     */\n    this.stop = function(callback) {\n        callback = callback || function() {};\n\n        // stop recording\n        recording = false;\n\n        mergeLeftRightBuffers({\n            desiredSampRate: desiredSampRate,\n            sampleRate: sampleRate,\n            numberOfAudioChannels: numberOfAudioChannels,\n            internalInterleavedLength: recordingLength,\n            leftBuffers: leftchannel,\n            rightBuffers: numberOfAudioChannels === 1 ? [] : rightchannel,\n            noWorker: config.noWorker\n        }, function(buffer, view) {\n            /**\n             * @property {Blob} blob - The recorded blob object.\n             * @memberof StereoAudioRecorder\n             * @example\n             * recorder.stop(function(){\n             *     var blob = recorder.blob;\n             * });\n             */\n            self.blob = new Blob([view], {\n                type: 'audio/wav'\n            });\n\n            /**\n             * @property {ArrayBuffer} buffer - The recorded buffer object.\n             * @memberof StereoAudioRecorder\n             * @example\n             * recorder.stop(function(){\n             *     var buffer = recorder.buffer;\n             * });\n             */\n            self.buffer = new ArrayBuffer(view.buffer.byteLength);\n\n            /**\n             * @property {DataView} view - The recorded data-view object.\n             * @memberof StereoAudioRecorder\n             * @example\n             * recorder.stop(function(){\n             *     var view = recorder.view;\n             * });\n             */\n            self.view = view;\n\n            self.sampleRate = desiredSampRate || sampleRate;\n            self.bufferSize = bufferSize;\n\n            // recorded audio length\n            self.length = recordingLength;\n\n            isAudioProcessStarted = false;\n\n            if (callback) {\n                callback(self.blob);\n            }\n        });\n    };\n\n    if (typeof RecordRTC.Storage === 'undefined') {\n        RecordRTC.Storage = {\n            AudioContextConstructor: null,\n            AudioContext: window.AudioContext || window.webkitAudioContext\n        };\n    }\n\n    if (!RecordRTC.Storage.AudioContextConstructor || RecordRTC.Storage.AudioContextConstructor.state === 'closed') {\n        RecordRTC.Storage.AudioContextConstructor = new RecordRTC.Storage.AudioContext();\n    }\n\n    var context = RecordRTC.Storage.AudioContextConstructor;\n\n    // creates an audio node from the microphone incoming stream\n    var audioInput = context.createMediaStreamSource(mediaStream);\n\n    var legalBufferValues = [0, 256, 512, 1024, 2048, 4096, 8192, 16384];\n\n    /**\n     * From the spec: This value controls how frequently the audioprocess event is\n     * dispatched and how many sample-frames need to be processed each call.\n     * Lower values for buffer size will result in a lower (better) latency.\n     * Higher values will be necessary to avoid audio breakup and glitches\n     * The size of the buffer (in sample-frames) which needs to\n     * be processed each time onprocessaudio is called.\n     * Legal values are (256, 512, 1024, 2048, 4096, 8192, 16384).\n     * @property {number} bufferSize - Buffer-size for how frequently the audioprocess event is dispatched.\n     * @memberof StereoAudioRecorder\n     * @example\n     * recorder = new StereoAudioRecorder(mediaStream, {\n     *     bufferSize: 4096\n     * });\n     */\n\n    // \"0\" means, let chrome decide the most accurate buffer-size for current platform.\n    var bufferSize = typeof config.bufferSize === 'undefined' ? 4096 : config.bufferSize;\n\n    if (legalBufferValues.indexOf(bufferSize) === -1) {\n        if (!config.disableLogs) {\n            console.log('Legal values for buffer-size are ' + JSON.stringify(legalBufferValues, null, '\\t'));\n        }\n    }\n\n    if (context.createJavaScriptNode) {\n        jsAudioNode = context.createJavaScriptNode(bufferSize, numberOfAudioChannels, numberOfAudioChannels);\n    } else if (context.createScriptProcessor) {\n        jsAudioNode = context.createScriptProcessor(bufferSize, numberOfAudioChannels, numberOfAudioChannels);\n    } else {\n        throw 'WebAudio API has no support on this browser.';\n    }\n\n    // connect the stream to the script processor\n    audioInput.connect(jsAudioNode);\n\n    if (!config.bufferSize) {\n        bufferSize = jsAudioNode.bufferSize; // device buffer-size\n    }\n\n    /**\n     * The sample rate (in sample-frames per second) at which the\n     * AudioContext handles audio. It is assumed that all AudioNodes\n     * in the context run at this rate. In making this assumption,\n     * sample-rate converters or \"varispeed\" processors are not supported\n     * in real-time processing.\n     * The sampleRate parameter describes the sample-rate of the\n     * linear PCM audio data in the buffer in sample-frames per second.\n     * An implementation must support sample-rates in at least\n     * the range 22050 to 96000.\n     * @property {number} sampleRate - Buffer-size for how frequently the audioprocess event is dispatched.\n     * @memberof StereoAudioRecorder\n     * @example\n     * recorder = new StereoAudioRecorder(mediaStream, {\n     *     sampleRate: 44100\n     * });\n     */\n    var sampleRate = typeof config.sampleRate !== 'undefined' ? config.sampleRate : context.sampleRate || 44100;\n\n    if (sampleRate < 22050 || sampleRate > 96000) {\n        // Ref: http://stackoverflow.com/a/26303918/552182\n        if (!config.disableLogs) {\n            console.log('sample-rate must be under range 22050 and 96000.');\n        }\n    }\n\n    if (!config.disableLogs) {\n        if (config.desiredSampRate) {\n            console.log('Desired sample-rate: ' + config.desiredSampRate);\n        }\n    }\n\n    var isPaused = false;\n    /**\n     * This method pauses the recording process.\n     * @method\n     * @memberof StereoAudioRecorder\n     * @example\n     * recorder.pause();\n     */\n    this.pause = function() {\n        isPaused = true;\n    };\n\n    /**\n     * This method resumes the recording process.\n     * @method\n     * @memberof StereoAudioRecorder\n     * @example\n     * recorder.resume();\n     */\n    this.resume = function() {\n        if (isMediaStreamActive() === false) {\n            throw 'Please make sure MediaStream is active.';\n        }\n\n        if (!recording) {\n            if (!config.disableLogs) {\n                console.log('Seems recording has been restarted.');\n            }\n            this.record();\n            return;\n        }\n\n        isPaused = false;\n    };\n\n    /**\n     * This method resets currently recorded data.\n     * @method\n     * @memberof StereoAudioRecorder\n     * @example\n     * recorder.clearRecordedData();\n     */\n    this.clearRecordedData = function() {\n        config.checkForInactiveTracks = false;\n\n        if (recording) {\n            this.stop(clearRecordedDataCB);\n        }\n\n        clearRecordedDataCB();\n    };\n\n    function resetVariables() {\n        leftchannel = [];\n        rightchannel = [];\n        recordingLength = 0;\n        isAudioProcessStarted = false;\n        recording = false;\n        isPaused = false;\n        context = null;\n\n        self.leftchannel = leftchannel;\n        self.rightchannel = rightchannel;\n        self.numberOfAudioChannels = numberOfAudioChannels;\n        self.desiredSampRate = desiredSampRate;\n        self.sampleRate = sampleRate;\n        self.recordingLength = recordingLength;\n\n        intervalsBasedBuffers = {\n            left: [],\n            right: [],\n            recordingLength: 0\n        };\n    }\n\n    function clearRecordedDataCB() {\n        if (jsAudioNode) {\n            jsAudioNode.onaudioprocess = null;\n            jsAudioNode.disconnect();\n            jsAudioNode = null;\n        }\n\n        if (audioInput) {\n            audioInput.disconnect();\n            audioInput = null;\n        }\n\n        resetVariables();\n    }\n\n    // for debugging\n    this.name = 'StereoAudioRecorder';\n    this.toString = function() {\n        return this.name;\n    };\n\n    var isAudioProcessStarted = false;\n\n    function onAudioProcessDataAvailable(e) {\n        if (isPaused) {\n            return;\n        }\n\n        if (isMediaStreamActive() === false) {\n            if (!config.disableLogs) {\n                console.log('MediaStream seems stopped.');\n            }\n            jsAudioNode.disconnect();\n            recording = false;\n        }\n\n        if (!recording) {\n            if (audioInput) {\n                audioInput.disconnect();\n                audioInput = null;\n            }\n            return;\n        }\n\n        /**\n         * This method is called on \"onaudioprocess\" event's first invocation.\n         * @method {function} onAudioProcessStarted\n         * @memberof StereoAudioRecorder\n         * @example\n         * recorder.onAudioProcessStarted: function() { };\n         */\n        if (!isAudioProcessStarted) {\n            isAudioProcessStarted = true;\n            if (config.onAudioProcessStarted) {\n                config.onAudioProcessStarted();\n            }\n\n            if (config.initCallback) {\n                config.initCallback();\n            }\n        }\n\n        var left = e.inputBuffer.getChannelData(0);\n\n        // we clone the samples\n        var chLeft = new Float32Array(left);\n        leftchannel.push(chLeft);\n\n        if (numberOfAudioChannels === 2) {\n            var right = e.inputBuffer.getChannelData(1);\n            var chRight = new Float32Array(right);\n            rightchannel.push(chRight);\n        }\n\n        recordingLength += bufferSize;\n\n        // export raw PCM\n        self.recordingLength = recordingLength;\n\n        if (typeof config.timeSlice !== 'undefined') {\n            intervalsBasedBuffers.recordingLength += bufferSize;\n            intervalsBasedBuffers.left.push(chLeft);\n\n            if (numberOfAudioChannels === 2) {\n                intervalsBasedBuffers.right.push(chRight);\n            }\n        }\n    }\n\n    jsAudioNode.onaudioprocess = onAudioProcessDataAvailable;\n\n    // to prevent self audio to be connected with speakers\n    if (context.createMediaStreamDestination) {\n        jsAudioNode.connect(context.createMediaStreamDestination());\n    } else {\n        jsAudioNode.connect(context.destination);\n    }\n\n    // export raw PCM\n    this.leftchannel = leftchannel;\n    this.rightchannel = rightchannel;\n    this.numberOfAudioChannels = numberOfAudioChannels;\n    this.desiredSampRate = desiredSampRate;\n    this.sampleRate = sampleRate;\n    self.recordingLength = recordingLength;\n\n    // helper for intervals based blobs\n    var intervalsBasedBuffers = {\n        left: [],\n        right: [],\n        recordingLength: 0\n    };\n\n    // this looper is used to support intervals based blobs (via timeSlice+ondataavailable)\n    function looper() {\n        if (!recording || typeof config.ondataavailable !== 'function' || typeof config.timeSlice === 'undefined') {\n            return;\n        }\n\n        if (intervalsBasedBuffers.left.length) {\n            mergeLeftRightBuffers({\n                desiredSampRate: desiredSampRate,\n                sampleRate: sampleRate,\n                numberOfAudioChannels: numberOfAudioChannels,\n                internalInterleavedLength: intervalsBasedBuffers.recordingLength,\n                leftBuffers: intervalsBasedBuffers.left,\n                rightBuffers: numberOfAudioChannels === 1 ? [] : intervalsBasedBuffers.right\n            }, function(buffer, view) {\n                var blob = new Blob([view], {\n                    type: 'audio/wav'\n                });\n                config.ondataavailable(blob);\n\n                setTimeout(looper, config.timeSlice);\n            });\n\n            intervalsBasedBuffers = {\n                left: [],\n                right: [],\n                recordingLength: 0\n            };\n        } else {\n            setTimeout(looper, config.timeSlice);\n        }\n    }\n}\n\nif (typeof RecordRTC !== 'undefined') {\n    RecordRTC.StereoAudioRecorder = StereoAudioRecorder;\n}\n\n// _________________\n// CanvasRecorder.js\n\n/**\n * CanvasRecorder is a standalone class used by {@link RecordRTC} to bring HTML5-Canvas recording into video WebM. It uses HTML2Canvas library and runs top over {@link Whammy}.\n * @summary HTML2Canvas recording into video WebM.\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @typedef CanvasRecorder\n * @class\n * @example\n * var recorder = new CanvasRecorder(htmlElement, { disableLogs: true, useWhammyRecorder: true });\n * recorder.record();\n * recorder.stop(function(blob) {\n *     video.src = URL.createObjectURL(blob);\n * });\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n * @param {HTMLElement} htmlElement - querySelector/getElementById/getElementsByTagName[0]/etc.\n * @param {object} config - {disableLogs:true, initCallback: function}\n */\n\nfunction CanvasRecorder(htmlElement, config) {\n    if (typeof html2canvas === 'undefined') {\n        throw 'Please link: https://www.webrtc-experiment.com/screenshot.js';\n    }\n\n    config = config || {};\n    if (!config.frameInterval) {\n        config.frameInterval = 10;\n    }\n\n    // via DetectRTC.js\n    var isCanvasSupportsStreamCapturing = false;\n    ['captureStream', 'mozCaptureStream', 'webkitCaptureStream'].forEach(function(item) {\n        if (item in document.createElement('canvas')) {\n            isCanvasSupportsStreamCapturing = true;\n        }\n    });\n\n    var _isChrome = (!!window.webkitRTCPeerConnection || !!window.webkitGetUserMedia) && !!window.chrome;\n\n    var chromeVersion = 50;\n    var matchArray = navigator.userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./);\n    if (_isChrome && matchArray && matchArray[2]) {\n        chromeVersion = parseInt(matchArray[2], 10);\n    }\n\n    if (_isChrome && chromeVersion < 52) {\n        isCanvasSupportsStreamCapturing = false;\n    }\n\n    if (config.useWhammyRecorder) {\n        isCanvasSupportsStreamCapturing = false;\n    }\n\n    var globalCanvas, mediaStreamRecorder;\n\n    if (isCanvasSupportsStreamCapturing) {\n        if (!config.disableLogs) {\n            console.log('Your browser supports both MediRecorder API and canvas.captureStream!');\n        }\n\n        if (htmlElement instanceof HTMLCanvasElement) {\n            globalCanvas = htmlElement;\n        } else if (htmlElement instanceof CanvasRenderingContext2D) {\n            globalCanvas = htmlElement.canvas;\n        } else {\n            throw 'Please pass either HTMLCanvasElement or CanvasRenderingContext2D.';\n        }\n    } else if (!!navigator.mozGetUserMedia) {\n        if (!config.disableLogs) {\n            console.error('Canvas recording is NOT supported in Firefox.');\n        }\n    }\n\n    var isRecording;\n\n    /**\n     * This method records Canvas.\n     * @method\n     * @memberof CanvasRecorder\n     * @example\n     * recorder.record();\n     */\n    this.record = function() {\n        isRecording = true;\n\n        if (isCanvasSupportsStreamCapturing && !config.useWhammyRecorder) {\n            // CanvasCaptureMediaStream\n            var canvasMediaStream;\n            if ('captureStream' in globalCanvas) {\n                canvasMediaStream = globalCanvas.captureStream(25); // 25 FPS\n            } else if ('mozCaptureStream' in globalCanvas) {\n                canvasMediaStream = globalCanvas.mozCaptureStream(25);\n            } else if ('webkitCaptureStream' in globalCanvas) {\n                canvasMediaStream = globalCanvas.webkitCaptureStream(25);\n            }\n\n            try {\n                var mdStream = new MediaStream();\n                mdStream.addTrack(getTracks(canvasMediaStream, 'video')[0]);\n                canvasMediaStream = mdStream;\n            } catch (e) {}\n\n            if (!canvasMediaStream) {\n                throw 'captureStream API are NOT available.';\n            }\n\n            // Note: Jan 18, 2016 status is that, \n            // Firefox MediaRecorder API can't record CanvasCaptureMediaStream object.\n            mediaStreamRecorder = new MediaStreamRecorder(canvasMediaStream, {\n                mimeType: config.mimeType || 'video/webm'\n            });\n            mediaStreamRecorder.record();\n        } else {\n            whammy.frames = [];\n            lastTime = new Date().getTime();\n            drawCanvasFrame();\n        }\n\n        if (config.initCallback) {\n            config.initCallback();\n        }\n    };\n\n    this.getWebPImages = function(callback) {\n        if (htmlElement.nodeName.toLowerCase() !== 'canvas') {\n            callback();\n            return;\n        }\n\n        var framesLength = whammy.frames.length;\n        whammy.frames.forEach(function(frame, idx) {\n            var framesRemaining = framesLength - idx;\n            if (!config.disableLogs) {\n                console.log(framesRemaining + '/' + framesLength + ' frames remaining');\n            }\n\n            if (config.onEncodingCallback) {\n                config.onEncodingCallback(framesRemaining, framesLength);\n            }\n\n            var webp = frame.image.toDataURL('image/webp', 1);\n            whammy.frames[idx].image = webp;\n        });\n\n        if (!config.disableLogs) {\n            console.log('Generating WebM');\n        }\n\n        callback();\n    };\n\n    /**\n     * This method stops recording Canvas.\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\n     * @method\n     * @memberof CanvasRecorder\n     * @example\n     * recorder.stop(function(blob) {\n     *     video.src = URL.createObjectURL(blob);\n     * });\n     */\n    this.stop = function(callback) {\n        isRecording = false;\n\n        var that = this;\n\n        if (isCanvasSupportsStreamCapturing && mediaStreamRecorder) {\n            mediaStreamRecorder.stop(callback);\n            return;\n        }\n\n        this.getWebPImages(function() {\n            /**\n             * @property {Blob} blob - Recorded frames in video/webm blob.\n             * @memberof CanvasRecorder\n             * @example\n             * recorder.stop(function() {\n             *     var blob = recorder.blob;\n             * });\n             */\n            whammy.compile(function(blob) {\n                if (!config.disableLogs) {\n                    console.log('Recording finished!');\n                }\n\n                that.blob = blob;\n\n                if (that.blob.forEach) {\n                    that.blob = new Blob([], {\n                        type: 'video/webm'\n                    });\n                }\n\n                if (callback) {\n                    callback(that.blob);\n                }\n\n                whammy.frames = [];\n            });\n        });\n    };\n\n    var isPausedRecording = false;\n\n    /**\n     * This method pauses the recording process.\n     * @method\n     * @memberof CanvasRecorder\n     * @example\n     * recorder.pause();\n     */\n    this.pause = function() {\n        isPausedRecording = true;\n\n        if (mediaStreamRecorder instanceof MediaStreamRecorder) {\n            mediaStreamRecorder.pause();\n            return;\n        }\n    };\n\n    /**\n     * This method resumes the recording process.\n     * @method\n     * @memberof CanvasRecorder\n     * @example\n     * recorder.resume();\n     */\n    this.resume = function() {\n        isPausedRecording = false;\n\n        if (mediaStreamRecorder instanceof MediaStreamRecorder) {\n            mediaStreamRecorder.resume();\n            return;\n        }\n\n        if (!isRecording) {\n            this.record();\n        }\n    };\n\n    /**\n     * This method resets currently recorded data.\n     * @method\n     * @memberof CanvasRecorder\n     * @example\n     * recorder.clearRecordedData();\n     */\n    this.clearRecordedData = function() {\n        if (isRecording) {\n            this.stop(clearRecordedDataCB);\n        }\n        clearRecordedDataCB();\n    };\n\n    function clearRecordedDataCB() {\n        whammy.frames = [];\n        isRecording = false;\n        isPausedRecording = false;\n    }\n\n    // for debugging\n    this.name = 'CanvasRecorder';\n    this.toString = function() {\n        return this.name;\n    };\n\n    function cloneCanvas() {\n        //create a new canvas\n        var newCanvas = document.createElement('canvas');\n        var context = newCanvas.getContext('2d');\n\n        //set dimensions\n        newCanvas.width = htmlElement.width;\n        newCanvas.height = htmlElement.height;\n\n        //apply the old canvas to the new one\n        context.drawImage(htmlElement, 0, 0);\n\n        //return the new canvas\n        return newCanvas;\n    }\n\n    function drawCanvasFrame() {\n        if (isPausedRecording) {\n            lastTime = new Date().getTime();\n            return setTimeout(drawCanvasFrame, 500);\n        }\n\n        if (htmlElement.nodeName.toLowerCase() === 'canvas') {\n            var duration = new Date().getTime() - lastTime;\n            // via #206, by Jack i.e. @Seymourr\n            lastTime = new Date().getTime();\n\n            whammy.frames.push({\n                image: cloneCanvas(),\n                duration: duration\n            });\n\n            if (isRecording) {\n                setTimeout(drawCanvasFrame, config.frameInterval);\n            }\n            return;\n        }\n\n        html2canvas(htmlElement, {\n            grabMouse: typeof config.showMousePointer === 'undefined' || config.showMousePointer,\n            onrendered: function(canvas) {\n                var duration = new Date().getTime() - lastTime;\n                if (!duration) {\n                    return setTimeout(drawCanvasFrame, config.frameInterval);\n                }\n\n                // via #206, by Jack i.e. @Seymourr\n                lastTime = new Date().getTime();\n\n                whammy.frames.push({\n                    image: canvas.toDataURL('image/webp', 1),\n                    duration: duration\n                });\n\n                if (isRecording) {\n                    setTimeout(drawCanvasFrame, config.frameInterval);\n                }\n            }\n        });\n    }\n\n    var lastTime = new Date().getTime();\n\n    var whammy = new Whammy.Video(100);\n}\n\nif (typeof RecordRTC !== 'undefined') {\n    RecordRTC.CanvasRecorder = CanvasRecorder;\n}\n\n// _________________\n// WhammyRecorder.js\n\n/**\n * WhammyRecorder is a standalone class used by {@link RecordRTC} to bring video recording in Chrome. It runs top over {@link Whammy}.\n * @summary Video recording feature in Chrome.\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @typedef WhammyRecorder\n * @class\n * @example\n * var recorder = new WhammyRecorder(mediaStream);\n * recorder.record();\n * recorder.stop(function(blob) {\n *     video.src = URL.createObjectURL(blob);\n * });\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\n * @param {object} config - {disableLogs: true, initCallback: function, video: HTMLVideoElement, etc.}\n */\n\nfunction WhammyRecorder(mediaStream, config) {\n\n    config = config || {};\n\n    if (!config.frameInterval) {\n        config.frameInterval = 10;\n    }\n\n    if (!config.disableLogs) {\n        console.log('Using frames-interval:', config.frameInterval);\n    }\n\n    /**\n     * This method records video.\n     * @method\n     * @memberof WhammyRecorder\n     * @example\n     * recorder.record();\n     */\n    this.record = function() {\n        if (!config.width) {\n            config.width = 320;\n        }\n\n        if (!config.height) {\n            config.height = 240;\n        }\n\n        if (!config.video) {\n            config.video = {\n                width: config.width,\n                height: config.height\n            };\n        }\n\n        if (!config.canvas) {\n            config.canvas = {\n                width: config.width,\n                height: config.height\n            };\n        }\n\n        canvas.width = config.canvas.width || 320;\n        canvas.height = config.canvas.height || 240;\n\n        context = canvas.getContext('2d');\n\n        // setting defaults\n        if (config.video && config.video instanceof HTMLVideoElement) {\n            video = config.video.cloneNode();\n\n            if (config.initCallback) {\n                config.initCallback();\n            }\n        } else {\n            video = document.createElement('video');\n\n            setSrcObject(mediaStream, video);\n\n            video.onloadedmetadata = function() { // \"onloadedmetadata\" may NOT work in FF?\n                if (config.initCallback) {\n                    config.initCallback();\n                }\n            };\n\n            video.width = config.video.width;\n            video.height = config.video.height;\n        }\n\n        video.muted = true;\n        video.play();\n\n        lastTime = new Date().getTime();\n        whammy = new Whammy.Video();\n\n        if (!config.disableLogs) {\n            console.log('canvas resolutions', canvas.width, '*', canvas.height);\n            console.log('video width/height', video.width || canvas.width, '*', video.height || canvas.height);\n        }\n\n        drawFrames(config.frameInterval);\n    };\n\n    /**\n     * Draw and push frames to Whammy\n     * @param {integer} frameInterval - set minimum interval (in milliseconds) between each time we push a frame to Whammy\n     */\n    function drawFrames(frameInterval) {\n        frameInterval = typeof frameInterval !== 'undefined' ? frameInterval : 10;\n\n        var duration = new Date().getTime() - lastTime;\n        if (!duration) {\n            return setTimeout(drawFrames, frameInterval, frameInterval);\n        }\n\n        if (isPausedRecording) {\n            lastTime = new Date().getTime();\n            return setTimeout(drawFrames, 100);\n        }\n\n        // via #206, by Jack i.e. @Seymourr\n        lastTime = new Date().getTime();\n\n        if (video.paused) {\n            // via: https://github.com/muaz-khan/WebRTC-Experiment/pull/316\n            // Tweak for Android Chrome\n            video.play();\n        }\n\n        context.drawImage(video, 0, 0, canvas.width, canvas.height);\n        whammy.frames.push({\n            duration: duration,\n            image: canvas.toDataURL('image/webp')\n        });\n\n        if (!isStopDrawing) {\n            setTimeout(drawFrames, frameInterval, frameInterval);\n        }\n    }\n\n    function asyncLoop(o) {\n        var i = -1,\n            length = o.length;\n\n        (function loop() {\n            i++;\n            if (i === length) {\n                o.callback();\n                return;\n            }\n\n            // \"setTimeout\" added by Jim McLeod\n            setTimeout(function() {\n                o.functionToLoop(loop, i);\n            }, 1);\n        })();\n    }\n\n\n    /**\n     * remove black frames from the beginning to the specified frame\n     * @param {Array} _frames - array of frames to be checked\n     * @param {number} _framesToCheck - number of frame until check will be executed (-1 - will drop all frames until frame not matched will be found)\n     * @param {number} _pixTolerance - 0 - very strict (only black pixel color) ; 1 - all\n     * @param {number} _frameTolerance - 0 - very strict (only black frame color) ; 1 - all\n     * @returns {Array} - array of frames\n     */\n    // pull#293 by @volodalexey\n    function dropBlackFrames(_frames, _framesToCheck, _pixTolerance, _frameTolerance, callback) {\n        var localCanvas = document.createElement('canvas');\n        localCanvas.width = canvas.width;\n        localCanvas.height = canvas.height;\n        var context2d = localCanvas.getContext('2d');\n        var resultFrames = [];\n\n        var checkUntilNotBlack = _framesToCheck === -1;\n        var endCheckFrame = (_framesToCheck && _framesToCheck > 0 && _framesToCheck <= _frames.length) ?\n            _framesToCheck : _frames.length;\n        var sampleColor = {\n            r: 0,\n            g: 0,\n            b: 0\n        };\n        var maxColorDifference = Math.sqrt(\n            Math.pow(255, 2) +\n            Math.pow(255, 2) +\n            Math.pow(255, 2)\n        );\n        var pixTolerance = _pixTolerance && _pixTolerance >= 0 && _pixTolerance <= 1 ? _pixTolerance : 0;\n        var frameTolerance = _frameTolerance && _frameTolerance >= 0 && _frameTolerance <= 1 ? _frameTolerance : 0;\n        var doNotCheckNext = false;\n\n        asyncLoop({\n            length: endCheckFrame,\n            functionToLoop: function(loop, f) {\n                var matchPixCount, endPixCheck, maxPixCount;\n\n                var finishImage = function() {\n                    if (!doNotCheckNext && maxPixCount - matchPixCount <= maxPixCount * frameTolerance) {\n                        // console.log('removed black frame : ' + f + ' ; frame duration ' + _frames[f].duration);\n                    } else {\n                        // console.log('frame is passed : ' + f);\n                        if (checkUntilNotBlack) {\n                            doNotCheckNext = true;\n                        }\n                        resultFrames.push(_frames[f]);\n                    }\n                    loop();\n                };\n\n                if (!doNotCheckNext) {\n                    var image = new Image();\n                    image.onload = function() {\n                        context2d.drawImage(image, 0, 0, canvas.width, canvas.height);\n                        var imageData = context2d.getImageData(0, 0, canvas.width, canvas.height);\n                        matchPixCount = 0;\n                        endPixCheck = imageData.data.length;\n                        maxPixCount = imageData.data.length / 4;\n\n                        for (var pix = 0; pix < endPixCheck; pix += 4) {\n                            var currentColor = {\n                                r: imageData.data[pix],\n                                g: imageData.data[pix + 1],\n                                b: imageData.data[pix + 2]\n                            };\n                            var colorDifference = Math.sqrt(\n                                Math.pow(currentColor.r - sampleColor.r, 2) +\n                                Math.pow(currentColor.g - sampleColor.g, 2) +\n                                Math.pow(currentColor.b - sampleColor.b, 2)\n                            );\n                            // difference in color it is difference in color vectors (r1,g1,b1) <=> (r2,g2,b2)\n                            if (colorDifference <= maxColorDifference * pixTolerance) {\n                                matchPixCount++;\n                            }\n                        }\n                        finishImage();\n                    };\n                    image.src = _frames[f].image;\n                } else {\n                    finishImage();\n                }\n            },\n            callback: function() {\n                resultFrames = resultFrames.concat(_frames.slice(endCheckFrame));\n\n                if (resultFrames.length <= 0) {\n                    // at least one last frame should be available for next manipulation\n                    // if total duration of all frames will be < 1000 than ffmpeg doesn't work well...\n                    resultFrames.push(_frames[_frames.length - 1]);\n                }\n                callback(resultFrames);\n            }\n        });\n    }\n\n    var isStopDrawing = false;\n\n    /**\n     * This method stops recording video.\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\n     * @method\n     * @memberof WhammyRecorder\n     * @example\n     * recorder.stop(function(blob) {\n     *     video.src = URL.createObjectURL(blob);\n     * });\n     */\n    this.stop = function(callback) {\n        callback = callback || function() {};\n\n        isStopDrawing = true;\n\n        var _this = this;\n        // analyse of all frames takes some time!\n        setTimeout(function() {\n            // e.g. dropBlackFrames(frames, 10, 1, 1) - will cut all 10 frames\n            // e.g. dropBlackFrames(frames, 10, 0.5, 0.5) - will analyse 10 frames\n            // e.g. dropBlackFrames(frames, 10) === dropBlackFrames(frames, 10, 0, 0) - will analyse 10 frames with strict black color\n            dropBlackFrames(whammy.frames, -1, null, null, function(frames) {\n                whammy.frames = frames;\n\n                // to display advertisement images!\n                if (config.advertisement && config.advertisement.length) {\n                    whammy.frames = config.advertisement.concat(whammy.frames);\n                }\n\n                /**\n                 * @property {Blob} blob - Recorded frames in video/webm blob.\n                 * @memberof WhammyRecorder\n                 * @example\n                 * recorder.stop(function() {\n                 *     var blob = recorder.blob;\n                 * });\n                 */\n                whammy.compile(function(blob) {\n                    _this.blob = blob;\n\n                    if (_this.blob.forEach) {\n                        _this.blob = new Blob([], {\n                            type: 'video/webm'\n                        });\n                    }\n\n                    if (callback) {\n                        callback(_this.blob);\n                    }\n                });\n            });\n        }, 10);\n    };\n\n    var isPausedRecording = false;\n\n    /**\n     * This method pauses the recording process.\n     * @method\n     * @memberof WhammyRecorder\n     * @example\n     * recorder.pause();\n     */\n    this.pause = function() {\n        isPausedRecording = true;\n    };\n\n    /**\n     * This method resumes the recording process.\n     * @method\n     * @memberof WhammyRecorder\n     * @example\n     * recorder.resume();\n     */\n    this.resume = function() {\n        isPausedRecording = false;\n\n        if (isStopDrawing) {\n            this.record();\n        }\n    };\n\n    /**\n     * This method resets currently recorded data.\n     * @method\n     * @memberof WhammyRecorder\n     * @example\n     * recorder.clearRecordedData();\n     */\n    this.clearRecordedData = function() {\n        if (!isStopDrawing) {\n            this.stop(clearRecordedDataCB);\n        }\n        clearRecordedDataCB();\n    };\n\n    function clearRecordedDataCB() {\n        whammy.frames = [];\n        isStopDrawing = true;\n        isPausedRecording = false;\n    }\n\n    // for debugging\n    this.name = 'WhammyRecorder';\n    this.toString = function() {\n        return this.name;\n    };\n\n    var canvas = document.createElement('canvas');\n    var context = canvas.getContext('2d');\n\n    var video;\n    var lastTime;\n    var whammy;\n}\n\nif (typeof RecordRTC !== 'undefined') {\n    RecordRTC.WhammyRecorder = WhammyRecorder;\n}\n\n// https://github.com/antimatter15/whammy/blob/master/LICENSE\n// _________\n// Whammy.js\n\n// todo: Firefox now supports webp for webm containers!\n// their MediaRecorder implementation works well!\n// should we provide an option to record via Whammy.js or MediaRecorder API is a better solution?\n\n/**\n * Whammy is a standalone class used by {@link RecordRTC} to bring video recording in Chrome. It is written by {@link https://github.com/antimatter15|antimatter15}\n * @summary A real time javascript webm encoder based on a canvas hack.\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @typedef Whammy\n * @class\n * @example\n * var recorder = new Whammy().Video(15);\n * recorder.add(context || canvas || dataURL);\n * var output = recorder.compile();\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n */\n\nvar Whammy = (function() {\n    // a more abstract-ish API\n\n    function WhammyVideo(duration) {\n        this.frames = [];\n        this.duration = duration || 1;\n        this.quality = 0.8;\n    }\n\n    /**\n     * Pass Canvas or Context or image/webp(string) to {@link Whammy} encoder.\n     * @method\n     * @memberof Whammy\n     * @example\n     * recorder = new Whammy().Video(0.8, 100);\n     * recorder.add(canvas || context || 'image/webp');\n     * @param {string} frame - Canvas || Context || image/webp\n     * @param {number} duration - Stick a duration (in milliseconds)\n     */\n    WhammyVideo.prototype.add = function(frame, duration) {\n        if ('canvas' in frame) { //CanvasRenderingContext2D\n            frame = frame.canvas;\n        }\n\n        if ('toDataURL' in frame) {\n            frame = frame.toDataURL('image/webp', this.quality);\n        }\n\n        if (!(/^data:image\\/webp;base64,/ig).test(frame)) {\n            throw 'Input must be formatted properly as a base64 encoded DataURI of type image/webp';\n        }\n        this.frames.push({\n            image: frame,\n            duration: duration || this.duration\n        });\n    };\n\n    function processInWebWorker(_function) {\n        var blob = URL.createObjectURL(new Blob([_function.toString(),\n            'this.onmessage =  function (eee) {' + _function.name + '(eee.data);}'\n        ], {\n            type: 'application/javascript'\n        }));\n\n        var worker = new Worker(blob);\n        URL.revokeObjectURL(blob);\n        return worker;\n    }\n\n    function whammyInWebWorker(frames) {\n        function ArrayToWebM(frames) {\n            var info = checkFrames(frames);\n            if (!info) {\n                return [];\n            }\n\n            var clusterMaxDuration = 30000;\n\n            var EBML = [{\n                'id': 0x1a45dfa3, // EBML\n                'data': [{\n                    'data': 1,\n                    'id': 0x4286 // EBMLVersion\n                }, {\n                    'data': 1,\n                    'id': 0x42f7 // EBMLReadVersion\n                }, {\n                    'data': 4,\n                    'id': 0x42f2 // EBMLMaxIDLength\n                }, {\n                    'data': 8,\n                    'id': 0x42f3 // EBMLMaxSizeLength\n                }, {\n                    'data': 'webm',\n                    'id': 0x4282 // DocType\n                }, {\n                    'data': 2,\n                    'id': 0x4287 // DocTypeVersion\n                }, {\n                    'data': 2,\n                    'id': 0x4285 // DocTypeReadVersion\n                }]\n            }, {\n                'id': 0x18538067, // Segment\n                'data': [{\n                    'id': 0x1549a966, // Info\n                    'data': [{\n                        'data': 1e6, //do things in millisecs (num of nanosecs for duration scale)\n                        'id': 0x2ad7b1 // TimecodeScale\n                    }, {\n                        'data': 'whammy',\n                        'id': 0x4d80 // MuxingApp\n                    }, {\n                        'data': 'whammy',\n                        'id': 0x5741 // WritingApp\n                    }, {\n                        'data': doubleToString(info.duration),\n                        'id': 0x4489 // Duration\n                    }]\n                }, {\n                    'id': 0x1654ae6b, // Tracks\n                    'data': [{\n                        'id': 0xae, // TrackEntry\n                        'data': [{\n                            'data': 1,\n                            'id': 0xd7 // TrackNumber\n                        }, {\n                            'data': 1,\n                            'id': 0x73c5 // TrackUID\n                        }, {\n                            'data': 0,\n                            'id': 0x9c // FlagLacing\n                        }, {\n                            'data': 'und',\n                            'id': 0x22b59c // Language\n                        }, {\n                            'data': 'V_VP8',\n                            'id': 0x86 // CodecID\n                        }, {\n                            'data': 'VP8',\n                            'id': 0x258688 // CodecName\n                        }, {\n                            'data': 1,\n                            'id': 0x83 // TrackType\n                        }, {\n                            'id': 0xe0, // Video\n                            'data': [{\n                                'data': info.width,\n                                'id': 0xb0 // PixelWidth\n                            }, {\n                                'data': info.height,\n                                'id': 0xba // PixelHeight\n                            }]\n                        }]\n                    }]\n                }]\n            }];\n\n            //Generate clusters (max duration)\n            var frameNumber = 0;\n            var clusterTimecode = 0;\n            while (frameNumber < frames.length) {\n\n                var clusterFrames = [];\n                var clusterDuration = 0;\n                do {\n                    clusterFrames.push(frames[frameNumber]);\n                    clusterDuration += frames[frameNumber].duration;\n                    frameNumber++;\n                } while (frameNumber < frames.length && clusterDuration < clusterMaxDuration);\n\n                var clusterCounter = 0;\n                var cluster = {\n                    'id': 0x1f43b675, // Cluster\n                    'data': getClusterData(clusterTimecode, clusterCounter, clusterFrames)\n                }; //Add cluster to segment\n                EBML[1].data.push(cluster);\n                clusterTimecode += clusterDuration;\n            }\n\n            return generateEBML(EBML);\n        }\n\n        function getClusterData(clusterTimecode, clusterCounter, clusterFrames) {\n            return [{\n                'data': clusterTimecode,\n                'id': 0xe7 // Timecode\n            }].concat(clusterFrames.map(function(webp) {\n                var block = makeSimpleBlock({\n                    discardable: 0,\n                    frame: webp.data.slice(4),\n                    invisible: 0,\n                    keyframe: 1,\n                    lacing: 0,\n                    trackNum: 1,\n                    timecode: Math.round(clusterCounter)\n                });\n                clusterCounter += webp.duration;\n                return {\n                    data: block,\n                    id: 0xa3\n                };\n            }));\n        }\n\n        // sums the lengths of all the frames and gets the duration\n\n        function checkFrames(frames) {\n            if (!frames[0]) {\n                postMessage({\n                    error: 'Something went wrong. Maybe WebP format is not supported in the current browser.'\n                });\n                return;\n            }\n\n            var width = frames[0].width,\n                height = frames[0].height,\n                duration = frames[0].duration;\n\n            for (var i = 1; i < frames.length; i++) {\n                duration += frames[i].duration;\n            }\n            return {\n                duration: duration,\n                width: width,\n                height: height\n            };\n        }\n\n        function numToBuffer(num) {\n            var parts = [];\n            while (num > 0) {\n                parts.push(num & 0xff);\n                num = num >> 8;\n            }\n            return new Uint8Array(parts.reverse());\n        }\n\n        function strToBuffer(str) {\n            return new Uint8Array(str.split('').map(function(e) {\n                return e.charCodeAt(0);\n            }));\n        }\n\n        function bitsToBuffer(bits) {\n            var data = [];\n            var pad = (bits.length % 8) ? (new Array(1 + 8 - (bits.length % 8))).join('0') : '';\n            bits = pad + bits;\n            for (var i = 0; i < bits.length; i += 8) {\n                data.push(parseInt(bits.substr(i, 8), 2));\n            }\n            return new Uint8Array(data);\n        }\n\n        function generateEBML(json) {\n            var ebml = [];\n            for (var i = 0; i < json.length; i++) {\n                var data = json[i].data;\n\n                if (typeof data === 'object') {\n                    data = generateEBML(data);\n                }\n\n                if (typeof data === 'number') {\n                    data = bitsToBuffer(data.toString(2));\n                }\n\n                if (typeof data === 'string') {\n                    data = strToBuffer(data);\n                }\n\n                var len = data.size || data.byteLength || data.length;\n                var zeroes = Math.ceil(Math.ceil(Math.log(len) / Math.log(2)) / 8);\n                var sizeToString = len.toString(2);\n                var padded = (new Array((zeroes * 7 + 7 + 1) - sizeToString.length)).join('0') + sizeToString;\n                var size = (new Array(zeroes)).join('0') + '1' + padded;\n\n                ebml.push(numToBuffer(json[i].id));\n                ebml.push(bitsToBuffer(size));\n                ebml.push(data);\n            }\n\n            return new Blob(ebml, {\n                type: 'video/webm'\n            });\n        }\n\n        function toBinStrOld(bits) {\n            var data = '';\n            var pad = (bits.length % 8) ? (new Array(1 + 8 - (bits.length % 8))).join('0') : '';\n            bits = pad + bits;\n            for (var i = 0; i < bits.length; i += 8) {\n                data += String.fromCharCode(parseInt(bits.substr(i, 8), 2));\n            }\n            return data;\n        }\n\n        function makeSimpleBlock(data) {\n            var flags = 0;\n\n            if (data.keyframe) {\n                flags |= 128;\n            }\n\n            if (data.invisible) {\n                flags |= 8;\n            }\n\n            if (data.lacing) {\n                flags |= (data.lacing << 1);\n            }\n\n            if (data.discardable) {\n                flags |= 1;\n            }\n\n            if (data.trackNum > 127) {\n                throw 'TrackNumber > 127 not supported';\n            }\n\n            var out = [data.trackNum | 0x80, data.timecode >> 8, data.timecode & 0xff, flags].map(function(e) {\n                return String.fromCharCode(e);\n            }).join('') + data.frame;\n\n            return out;\n        }\n\n        function parseWebP(riff) {\n            var VP8 = riff.RIFF[0].WEBP[0];\n\n            var frameStart = VP8.indexOf('\\x9d\\x01\\x2a'); // A VP8 keyframe starts with the 0x9d012a header\n            for (var i = 0, c = []; i < 4; i++) {\n                c[i] = VP8.charCodeAt(frameStart + 3 + i);\n            }\n\n            var width, height, tmp;\n\n            //the code below is literally copied verbatim from the bitstream spec\n            tmp = (c[1] << 8) | c[0];\n            width = tmp & 0x3FFF;\n            tmp = (c[3] << 8) | c[2];\n            height = tmp & 0x3FFF;\n            return {\n                width: width,\n                height: height,\n                data: VP8,\n                riff: riff\n            };\n        }\n\n        function getStrLength(string, offset) {\n            return parseInt(string.substr(offset + 4, 4).split('').map(function(i) {\n                var unpadded = i.charCodeAt(0).toString(2);\n                return (new Array(8 - unpadded.length + 1)).join('0') + unpadded;\n            }).join(''), 2);\n        }\n\n        function parseRIFF(string) {\n            var offset = 0;\n            var chunks = {};\n\n            while (offset < string.length) {\n                var id = string.substr(offset, 4);\n                var len = getStrLength(string, offset);\n                var data = string.substr(offset + 4 + 4, len);\n                offset += 4 + 4 + len;\n                chunks[id] = chunks[id] || [];\n\n                if (id === 'RIFF' || id === 'LIST') {\n                    chunks[id].push(parseRIFF(data));\n                } else {\n                    chunks[id].push(data);\n                }\n            }\n            return chunks;\n        }\n\n        function doubleToString(num) {\n            return [].slice.call(\n                new Uint8Array((new Float64Array([num])).buffer), 0).map(function(e) {\n                return String.fromCharCode(e);\n            }).reverse().join('');\n        }\n\n        var webm = new ArrayToWebM(frames.map(function(frame) {\n            var webp = parseWebP(parseRIFF(atob(frame.image.slice(23))));\n            webp.duration = frame.duration;\n            return webp;\n        }));\n\n        postMessage(webm);\n    }\n\n    /**\n     * Encodes frames in WebM container. It uses WebWorkinvoke to invoke 'ArrayToWebM' method.\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\n     * @method\n     * @memberof Whammy\n     * @example\n     * recorder = new Whammy().Video(0.8, 100);\n     * recorder.compile(function(blob) {\n     *    // blob.size - blob.type\n     * });\n     */\n    WhammyVideo.prototype.compile = function(callback) {\n        var webWorker = processInWebWorker(whammyInWebWorker);\n\n        webWorker.onmessage = function(event) {\n            if (event.data.error) {\n                console.error(event.data.error);\n                return;\n            }\n            callback(event.data);\n        };\n\n        webWorker.postMessage(this.frames);\n    };\n\n    return {\n        /**\n         * A more abstract-ish API.\n         * @method\n         * @memberof Whammy\n         * @example\n         * recorder = new Whammy().Video(0.8, 100);\n         * @param {?number} speed - 0.8\n         * @param {?number} quality - 100\n         */\n        Video: WhammyVideo\n    };\n})();\n\nif (typeof RecordRTC !== 'undefined') {\n    RecordRTC.Whammy = Whammy;\n}\n\n// ______________ (indexed-db)\n// DiskStorage.js\n\n/**\n * DiskStorage is a standalone object used by {@link RecordRTC} to store recorded blobs in IndexedDB storage.\n * @summary Writing blobs into IndexedDB.\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @example\n * DiskStorage.Store({\n *     audioBlob: yourAudioBlob,\n *     videoBlob: yourVideoBlob,\n *     gifBlob  : yourGifBlob\n * });\n * DiskStorage.Fetch(function(dataURL, type) {\n *     if(type === 'audioBlob') { }\n *     if(type === 'videoBlob') { }\n *     if(type === 'gifBlob')   { }\n * });\n * // DiskStorage.dataStoreName = 'recordRTC';\n * // DiskStorage.onError = function(error) { };\n * @property {function} init - This method must be called once to initialize IndexedDB ObjectStore. Though, it is auto-used internally.\n * @property {function} Fetch - This method fetches stored blobs from IndexedDB.\n * @property {function} Store - This method stores blobs in IndexedDB.\n * @property {function} onError - This function is invoked for any known/unknown error.\n * @property {string} dataStoreName - Name of the ObjectStore created in IndexedDB storage.\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n */\n\n\nvar DiskStorage = {\n    /**\n     * This method must be called once to initialize IndexedDB ObjectStore. Though, it is auto-used internally.\n     * @method\n     * @memberof DiskStorage\n     * @internal\n     * @example\n     * DiskStorage.init();\n     */\n    init: function() {\n        var self = this;\n\n        if (typeof indexedDB === 'undefined' || typeof indexedDB.open === 'undefined') {\n            console.error('IndexedDB API are not available in this browser.');\n            return;\n        }\n\n        var dbVersion = 1;\n        var dbName = this.dbName || location.href.replace(/\\/|:|#|%|\\.|\\[|\\]/g, ''),\n            db;\n        var request = indexedDB.open(dbName, dbVersion);\n\n        function createObjectStore(dataBase) {\n            dataBase.createObjectStore(self.dataStoreName);\n        }\n\n        function putInDB() {\n            var transaction = db.transaction([self.dataStoreName], 'readwrite');\n\n            if (self.videoBlob) {\n                transaction.objectStore(self.dataStoreName).put(self.videoBlob, 'videoBlob');\n            }\n\n            if (self.gifBlob) {\n                transaction.objectStore(self.dataStoreName).put(self.gifBlob, 'gifBlob');\n            }\n\n            if (self.audioBlob) {\n                transaction.objectStore(self.dataStoreName).put(self.audioBlob, 'audioBlob');\n            }\n\n            function getFromStore(portionName) {\n                transaction.objectStore(self.dataStoreName).get(portionName).onsuccess = function(event) {\n                    if (self.callback) {\n                        self.callback(event.target.result, portionName);\n                    }\n                };\n            }\n\n            getFromStore('audioBlob');\n            getFromStore('videoBlob');\n            getFromStore('gifBlob');\n        }\n\n        request.onerror = self.onError;\n\n        request.onsuccess = function() {\n            db = request.result;\n            db.onerror = self.onError;\n\n            if (db.setVersion) {\n                if (db.version !== dbVersion) {\n                    var setVersion = db.setVersion(dbVersion);\n                    setVersion.onsuccess = function() {\n                        createObjectStore(db);\n                        putInDB();\n                    };\n                } else {\n                    putInDB();\n                }\n            } else {\n                putInDB();\n            }\n        };\n        request.onupgradeneeded = function(event) {\n            createObjectStore(event.target.result);\n        };\n    },\n    /**\n     * This method fetches stored blobs from IndexedDB.\n     * @method\n     * @memberof DiskStorage\n     * @internal\n     * @example\n     * DiskStorage.Fetch(function(dataURL, type) {\n     *     if(type === 'audioBlob') { }\n     *     if(type === 'videoBlob') { }\n     *     if(type === 'gifBlob')   { }\n     * });\n     */\n    Fetch: function(callback) {\n        this.callback = callback;\n        this.init();\n\n        return this;\n    },\n    /**\n     * This method stores blobs in IndexedDB.\n     * @method\n     * @memberof DiskStorage\n     * @internal\n     * @example\n     * DiskStorage.Store({\n     *     audioBlob: yourAudioBlob,\n     *     videoBlob: yourVideoBlob,\n     *     gifBlob  : yourGifBlob\n     * });\n     */\n    Store: function(config) {\n        this.audioBlob = config.audioBlob;\n        this.videoBlob = config.videoBlob;\n        this.gifBlob = config.gifBlob;\n\n        this.init();\n\n        return this;\n    },\n    /**\n     * This function is invoked for any known/unknown error.\n     * @method\n     * @memberof DiskStorage\n     * @internal\n     * @example\n     * DiskStorage.onError = function(error){\n     *     alerot( JSON.stringify(error) );\n     * };\n     */\n    onError: function(error) {\n        console.error(JSON.stringify(error, null, '\\t'));\n    },\n\n    /**\n     * @property {string} dataStoreName - Name of the ObjectStore created in IndexedDB storage.\n     * @memberof DiskStorage\n     * @internal\n     * @example\n     * DiskStorage.dataStoreName = 'recordRTC';\n     */\n    dataStoreName: 'recordRTC',\n    dbName: null\n};\n\nif (typeof RecordRTC !== 'undefined') {\n    RecordRTC.DiskStorage = DiskStorage;\n}\n\n// ______________\n// GifRecorder.js\n\n/**\n * GifRecorder is standalone calss used by {@link RecordRTC} to record video or canvas into animated gif.\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @typedef GifRecorder\n * @class\n * @example\n * var recorder = new GifRecorder(mediaStream || canvas || context, { onGifPreview: function, onGifRecordingStarted: function, width: 1280, height: 720, frameRate: 200, quality: 10 });\n * recorder.record();\n * recorder.stop(function(blob) {\n *     img.src = URL.createObjectURL(blob);\n * });\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n * @param {MediaStream} mediaStream - MediaStream object or HTMLCanvasElement or CanvasRenderingContext2D.\n * @param {object} config - {disableLogs:true, initCallback: function, width: 320, height: 240, frameRate: 200, quality: 10}\n */\n\nfunction GifRecorder(mediaStream, config) {\n    if (typeof GIFEncoder === 'undefined') {\n        var script = document.createElement('script');\n        script.src = 'https://www.webrtc-experiment.com/gif-recorder.js';\n        (document.body || document.documentElement).appendChild(script);\n    }\n\n    config = config || {};\n\n    var isHTMLObject = mediaStream instanceof CanvasRenderingContext2D || mediaStream instanceof HTMLCanvasElement;\n\n    /**\n     * This method records MediaStream.\n     * @method\n     * @memberof GifRecorder\n     * @example\n     * recorder.record();\n     */\n    this.record = function() {\n        if (typeof GIFEncoder === 'undefined') {\n            setTimeout(self.record, 1000);\n            return;\n        }\n\n        if (!isLoadedMetaData) {\n            setTimeout(self.record, 1000);\n            return;\n        }\n\n        if (!isHTMLObject) {\n            if (!config.width) {\n                config.width = video.offsetWidth || 320;\n            }\n\n            if (!config.height) {\n                config.height = video.offsetHeight || 240;\n            }\n\n            if (!config.video) {\n                config.video = {\n                    width: config.width,\n                    height: config.height\n                };\n            }\n\n            if (!config.canvas) {\n                config.canvas = {\n                    width: config.width,\n                    height: config.height\n                };\n            }\n\n            canvas.width = config.canvas.width || 320;\n            canvas.height = config.canvas.height || 240;\n\n            video.width = config.video.width || 320;\n            video.height = config.video.height || 240;\n        }\n\n        // external library to record as GIF images\n        gifEncoder = new GIFEncoder();\n\n        // void setRepeat(int iter) \n        // Sets the number of times the set of GIF frames should be played. \n        // Default is 1; 0 means play indefinitely.\n        gifEncoder.setRepeat(0);\n\n        // void setFrameRate(Number fps) \n        // Sets frame rate in frames per second. \n        // Equivalent to setDelay(1000/fps).\n        // Using \"setDelay\" instead of \"setFrameRate\"\n        gifEncoder.setDelay(config.frameRate || 200);\n\n        // void setQuality(int quality) \n        // Sets quality of color quantization (conversion of images to the \n        // maximum 256 colors allowed by the GIF specification). \n        // Lower values (minimum = 1) produce better colors, \n        // but slow processing significantly. 10 is the default, \n        // and produces good color mapping at reasonable speeds. \n        // Values greater than 20 do not yield significant improvements in speed.\n        gifEncoder.setQuality(config.quality || 10);\n\n        // Boolean start() \n        // This writes the GIF Header and returns false if it fails.\n        gifEncoder.start();\n\n        if (typeof config.onGifRecordingStarted === 'function') {\n            config.onGifRecordingStarted();\n        }\n\n        startTime = Date.now();\n\n        function drawVideoFrame(time) {\n            if (self.clearedRecordedData === true) {\n                return;\n            }\n\n            if (isPausedRecording) {\n                return setTimeout(function() {\n                    drawVideoFrame(time);\n                }, 100);\n            }\n\n            lastAnimationFrame = requestAnimationFrame(drawVideoFrame);\n\n            if (typeof lastFrameTime === undefined) {\n                lastFrameTime = time;\n            }\n\n            // ~10 fps\n            if (time - lastFrameTime < 90) {\n                return;\n            }\n\n            if (!isHTMLObject && video.paused) {\n                // via: https://github.com/muaz-khan/WebRTC-Experiment/pull/316\n                // Tweak for Android Chrome\n                video.play();\n            }\n\n            if (!isHTMLObject) {\n                context.drawImage(video, 0, 0, canvas.width, canvas.height);\n            }\n\n            if (config.onGifPreview) {\n                config.onGifPreview(canvas.toDataURL('image/png'));\n            }\n\n            gifEncoder.addFrame(context);\n            lastFrameTime = time;\n        }\n\n        lastAnimationFrame = requestAnimationFrame(drawVideoFrame);\n\n        if (config.initCallback) {\n            config.initCallback();\n        }\n    };\n\n    /**\n     * This method stops recording MediaStream.\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\n     * @method\n     * @memberof GifRecorder\n     * @example\n     * recorder.stop(function(blob) {\n     *     img.src = URL.createObjectURL(blob);\n     * });\n     */\n    this.stop = function(callback) {\n        callback = callback || function() {};\n\n        if (lastAnimationFrame) {\n            cancelAnimationFrame(lastAnimationFrame);\n        }\n\n        endTime = Date.now();\n\n        /**\n         * @property {Blob} blob - The recorded blob object.\n         * @memberof GifRecorder\n         * @example\n         * recorder.stop(function(){\n         *     var blob = recorder.blob;\n         * });\n         */\n        this.blob = new Blob([new Uint8Array(gifEncoder.stream().bin)], {\n            type: 'image/gif'\n        });\n\n        callback(this.blob);\n\n        // bug: find a way to clear old recorded blobs\n        gifEncoder.stream().bin = [];\n    };\n\n    var isPausedRecording = false;\n\n    /**\n     * This method pauses the recording process.\n     * @method\n     * @memberof GifRecorder\n     * @example\n     * recorder.pause();\n     */\n    this.pause = function() {\n        isPausedRecording = true;\n    };\n\n    /**\n     * This method resumes the recording process.\n     * @method\n     * @memberof GifRecorder\n     * @example\n     * recorder.resume();\n     */\n    this.resume = function() {\n        isPausedRecording = false;\n    };\n\n    /**\n     * This method resets currently recorded data.\n     * @method\n     * @memberof GifRecorder\n     * @example\n     * recorder.clearRecordedData();\n     */\n    this.clearRecordedData = function() {\n        self.clearedRecordedData = true;\n        clearRecordedDataCB();\n    };\n\n    function clearRecordedDataCB() {\n        if (gifEncoder) {\n            gifEncoder.stream().bin = [];\n        }\n    }\n\n    // for debugging\n    this.name = 'GifRecorder';\n    this.toString = function() {\n        return this.name;\n    };\n\n    var canvas = document.createElement('canvas');\n    var context = canvas.getContext('2d');\n\n    if (isHTMLObject) {\n        if (mediaStream instanceof CanvasRenderingContext2D) {\n            context = mediaStream;\n            canvas = context.canvas;\n        } else if (mediaStream instanceof HTMLCanvasElement) {\n            context = mediaStream.getContext('2d');\n            canvas = mediaStream;\n        }\n    }\n\n    var isLoadedMetaData = true;\n\n    if (!isHTMLObject) {\n        var video = document.createElement('video');\n        video.muted = true;\n        video.autoplay = true;\n        video.playsInline = true;\n\n        isLoadedMetaData = false;\n        video.onloadedmetadata = function() {\n            isLoadedMetaData = true;\n        };\n\n        setSrcObject(mediaStream, video);\n\n        video.play();\n    }\n\n    var lastAnimationFrame = null;\n    var startTime, endTime, lastFrameTime;\n\n    var gifEncoder;\n\n    var self = this;\n}\n\nif (typeof RecordRTC !== 'undefined') {\n    RecordRTC.GifRecorder = GifRecorder;\n}\n\n// Last time updated: 2019-06-21 4:09:42 AM UTC\n\n// ________________________\n// MultiStreamsMixer v1.2.2\n\n// Open-Sourced: https://github.com/muaz-khan/MultiStreamsMixer\n\n// --------------------------------------------------\n// Muaz Khan     - www.MuazKhan.com\n// MIT License   - www.WebRTC-Experiment.com/licence\n// --------------------------------------------------\n\nfunction MultiStreamsMixer(arrayOfMediaStreams, elementClass) {\n\n    var browserFakeUserAgent = 'Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45';\n\n    (function(that) {\n        if (typeof RecordRTC !== 'undefined') {\n            return;\n        }\n\n        if (!that) {\n            return;\n        }\n\n        if (typeof window !== 'undefined') {\n            return;\n        }\n\n        if (typeof global === 'undefined') {\n            return;\n        }\n\n        global.navigator = {\n            userAgent: browserFakeUserAgent,\n            getUserMedia: function() {}\n        };\n\n        if (!global.console) {\n            global.console = {};\n        }\n\n        if (typeof global.console.log === 'undefined' || typeof global.console.error === 'undefined') {\n            global.console.error = global.console.log = global.console.log || function() {\n                console.log(arguments);\n            };\n        }\n\n        if (typeof document === 'undefined') {\n            /*global document:true */\n            that.document = {\n                documentElement: {\n                    appendChild: function() {\n                        return '';\n                    }\n                }\n            };\n\n            document.createElement = document.captureStream = document.mozCaptureStream = function() {\n                var obj = {\n                    getContext: function() {\n                        return obj;\n                    },\n                    play: function() {},\n                    pause: function() {},\n                    drawImage: function() {},\n                    toDataURL: function() {\n                        return '';\n                    },\n                    style: {}\n                };\n                return obj;\n            };\n\n            that.HTMLVideoElement = function() {};\n        }\n\n        if (typeof location === 'undefined') {\n            /*global location:true */\n            that.location = {\n                protocol: 'file:',\n                href: '',\n                hash: ''\n            };\n        }\n\n        if (typeof screen === 'undefined') {\n            /*global screen:true */\n            that.screen = {\n                width: 0,\n                height: 0\n            };\n        }\n\n        if (typeof URL === 'undefined') {\n            /*global screen:true */\n            that.URL = {\n                createObjectURL: function() {\n                    return '';\n                },\n                revokeObjectURL: function() {\n                    return '';\n                }\n            };\n        }\n\n        /*global window:true */\n        that.window = global;\n    })(typeof global !== 'undefined' ? global : null);\n\n    // requires: chrome://flags/#enable-experimental-web-platform-features\n\n    elementClass = elementClass || 'multi-streams-mixer';\n\n    var videos = [];\n    var isStopDrawingFrames = false;\n\n    var canvas = document.createElement('canvas');\n    var context = canvas.getContext('2d');\n    canvas.style.opacity = 0;\n    canvas.style.position = 'absolute';\n    canvas.style.zIndex = -1;\n    canvas.style.top = '-1000em';\n    canvas.style.left = '-1000em';\n    canvas.className = elementClass;\n    (document.body || document.documentElement).appendChild(canvas);\n\n    this.disableLogs = false;\n    this.frameInterval = 10;\n\n    this.width = 360;\n    this.height = 240;\n\n    // use gain node to prevent echo\n    this.useGainNode = true;\n\n    var self = this;\n\n    // _____________________________\n    // Cross-Browser-Declarations.js\n\n    // WebAudio API representer\n    var AudioContext = window.AudioContext;\n\n    if (typeof AudioContext === 'undefined') {\n        if (typeof webkitAudioContext !== 'undefined') {\n            /*global AudioContext:true */\n            AudioContext = webkitAudioContext;\n        }\n\n        if (typeof mozAudioContext !== 'undefined') {\n            /*global AudioContext:true */\n            AudioContext = mozAudioContext;\n        }\n    }\n\n    /*jshint -W079 */\n    var URL = window.URL;\n\n    if (typeof URL === 'undefined' && typeof webkitURL !== 'undefined') {\n        /*global URL:true */\n        URL = webkitURL;\n    }\n\n    if (typeof navigator !== 'undefined' && typeof navigator.getUserMedia === 'undefined') { // maybe window.navigator?\n        if (typeof navigator.webkitGetUserMedia !== 'undefined') {\n            navigator.getUserMedia = navigator.webkitGetUserMedia;\n        }\n\n        if (typeof navigator.mozGetUserMedia !== 'undefined') {\n            navigator.getUserMedia = navigator.mozGetUserMedia;\n        }\n    }\n\n    var MediaStream = window.MediaStream;\n\n    if (typeof MediaStream === 'undefined' && typeof webkitMediaStream !== 'undefined') {\n        MediaStream = webkitMediaStream;\n    }\n\n    /*global MediaStream:true */\n    if (typeof MediaStream !== 'undefined') {\n        // override \"stop\" method for all browsers\n        if (typeof MediaStream.prototype.stop === 'undefined') {\n            MediaStream.prototype.stop = function() {\n                this.getTracks().forEach(function(track) {\n                    track.stop();\n                });\n            };\n        }\n    }\n\n    var Storage = {};\n\n    if (typeof AudioContext !== 'undefined') {\n        Storage.AudioContext = AudioContext;\n    } else if (typeof webkitAudioContext !== 'undefined') {\n        Storage.AudioContext = webkitAudioContext;\n    }\n\n    function setSrcObject(stream, element) {\n        if ('srcObject' in element) {\n            element.srcObject = stream;\n        } else if ('mozSrcObject' in element) {\n            element.mozSrcObject = stream;\n        } else {\n            element.srcObject = stream;\n        }\n    }\n\n    this.startDrawingFrames = function() {\n        drawVideosToCanvas();\n    };\n\n    function drawVideosToCanvas() {\n        if (isStopDrawingFrames) {\n            return;\n        }\n\n        var videosLength = videos.length;\n\n        var fullcanvas = false;\n        var remaining = [];\n        videos.forEach(function(video) {\n            if (!video.stream) {\n                video.stream = {};\n            }\n\n            if (video.stream.fullcanvas) {\n                fullcanvas = video;\n            } else {\n                // todo: video.stream.active or video.stream.live to fix blank frames issues?\n                remaining.push(video);\n            }\n        });\n\n        if (fullcanvas) {\n            canvas.width = fullcanvas.stream.width;\n            canvas.height = fullcanvas.stream.height;\n        } else if (remaining.length) {\n            canvas.width = videosLength > 1 ? remaining[0].width * 2 : remaining[0].width;\n\n            var height = 1;\n            if (videosLength === 3 || videosLength === 4) {\n                height = 2;\n            }\n            if (videosLength === 5 || videosLength === 6) {\n                height = 3;\n            }\n            if (videosLength === 7 || videosLength === 8) {\n                height = 4;\n            }\n            if (videosLength === 9 || videosLength === 10) {\n                height = 5;\n            }\n            canvas.height = remaining[0].height * height;\n        } else {\n            canvas.width = self.width || 360;\n            canvas.height = self.height || 240;\n        }\n\n        if (fullcanvas && fullcanvas instanceof HTMLVideoElement) {\n            drawImage(fullcanvas);\n        }\n\n        remaining.forEach(function(video, idx) {\n            drawImage(video, idx);\n        });\n\n        setTimeout(drawVideosToCanvas, self.frameInterval);\n    }\n\n    function drawImage(video, idx) {\n        if (isStopDrawingFrames) {\n            return;\n        }\n\n        var x = 0;\n        var y = 0;\n        var width = video.width;\n        var height = video.height;\n\n        if (idx === 1) {\n            x = video.width;\n        }\n\n        if (idx === 2) {\n            y = video.height;\n        }\n\n        if (idx === 3) {\n            x = video.width;\n            y = video.height;\n        }\n\n        if (idx === 4) {\n            y = video.height * 2;\n        }\n\n        if (idx === 5) {\n            x = video.width;\n            y = video.height * 2;\n        }\n\n        if (idx === 6) {\n            y = video.height * 3;\n        }\n\n        if (idx === 7) {\n            x = video.width;\n            y = video.height * 3;\n        }\n\n        if (typeof video.stream.left !== 'undefined') {\n            x = video.stream.left;\n        }\n\n        if (typeof video.stream.top !== 'undefined') {\n            y = video.stream.top;\n        }\n\n        if (typeof video.stream.width !== 'undefined') {\n            width = video.stream.width;\n        }\n\n        if (typeof video.stream.height !== 'undefined') {\n            height = video.stream.height;\n        }\n\n        context.drawImage(video, x, y, width, height);\n\n        if (typeof video.stream.onRender === 'function') {\n            video.stream.onRender(context, x, y, width, height, idx);\n        }\n    }\n\n    function getMixedStream() {\n        isStopDrawingFrames = false;\n        var mixedVideoStream = getMixedVideoStream();\n\n        var mixedAudioStream = getMixedAudioStream();\n        if (mixedAudioStream) {\n            mixedAudioStream.getTracks().filter(function(t) {\n                return t.kind === 'audio';\n            }).forEach(function(track) {\n                mixedVideoStream.addTrack(track);\n            });\n        }\n\n        var fullcanvas;\n        arrayOfMediaStreams.forEach(function(stream) {\n            if (stream.fullcanvas) {\n                fullcanvas = true;\n            }\n        });\n\n        // mixedVideoStream.prototype.appendStreams = appendStreams;\n        // mixedVideoStream.prototype.resetVideoStreams = resetVideoStreams;\n        // mixedVideoStream.prototype.clearRecordedData = clearRecordedData;\n\n        return mixedVideoStream;\n    }\n\n    function getMixedVideoStream() {\n        resetVideoStreams();\n\n        var capturedStream;\n\n        if ('captureStream' in canvas) {\n            capturedStream = canvas.captureStream();\n        } else if ('mozCaptureStream' in canvas) {\n            capturedStream = canvas.mozCaptureStream();\n        } else if (!self.disableLogs) {\n            console.error('Upgrade to latest Chrome or otherwise enable this flag: chrome://flags/#enable-experimental-web-platform-features');\n        }\n\n        var videoStream = new MediaStream();\n\n        capturedStream.getTracks().filter(function(t) {\n            return t.kind === 'video';\n        }).forEach(function(track) {\n            videoStream.addTrack(track);\n        });\n\n        canvas.stream = videoStream;\n\n        return videoStream;\n    }\n\n    function getMixedAudioStream() {\n        // via: @pehrsons\n        if (!Storage.AudioContextConstructor) {\n            Storage.AudioContextConstructor = new Storage.AudioContext();\n        }\n\n        self.audioContext = Storage.AudioContextConstructor;\n\n        self.audioSources = [];\n\n        if (self.useGainNode === true) {\n            self.gainNode = self.audioContext.createGain();\n            self.gainNode.connect(self.audioContext.destination);\n            self.gainNode.gain.value = 0; // don't hear self\n        }\n\n        var audioTracksLength = 0;\n        arrayOfMediaStreams.forEach(function(stream) {\n            if (!stream.getTracks().filter(function(t) {\n                    return t.kind === 'audio';\n                }).length) {\n                return;\n            }\n\n            audioTracksLength++;\n\n            var audioSource = self.audioContext.createMediaStreamSource(stream);\n\n            if (self.useGainNode === true) {\n                audioSource.connect(self.gainNode);\n            }\n\n            self.audioSources.push(audioSource);\n        });\n\n        if (!audioTracksLength) {\n            // because \"self.audioContext\" is not initialized\n            // that's why we've to ignore rest of the code\n            return;\n        }\n\n        self.audioDestination = self.audioContext.createMediaStreamDestination();\n        self.audioSources.forEach(function(audioSource) {\n            audioSource.connect(self.audioDestination);\n        });\n        return self.audioDestination.stream;\n    }\n\n    function getVideo(stream) {\n        var video = document.createElement('video');\n\n        setSrcObject(stream, video);\n\n        video.className = elementClass;\n\n        video.muted = true;\n        video.volume = 0;\n\n        video.width = stream.width || self.width || 360;\n        video.height = stream.height || self.height || 240;\n\n        video.play();\n\n        return video;\n    }\n\n    this.appendStreams = function(streams) {\n        if (!streams) {\n            throw 'First parameter is required.';\n        }\n\n        if (!(streams instanceof Array)) {\n            streams = [streams];\n        }\n\n        streams.forEach(function(stream) {\n            var newStream = new MediaStream();\n\n            if (stream.getTracks().filter(function(t) {\n                    return t.kind === 'video';\n                }).length) {\n                var video = getVideo(stream);\n                video.stream = stream;\n                videos.push(video);\n\n                newStream.addTrack(stream.getTracks().filter(function(t) {\n                    return t.kind === 'video';\n                })[0]);\n            }\n\n            if (stream.getTracks().filter(function(t) {\n                    return t.kind === 'audio';\n                }).length) {\n                var audioSource = self.audioContext.createMediaStreamSource(stream);\n                self.audioDestination = self.audioContext.createMediaStreamDestination();\n                audioSource.connect(self.audioDestination);\n\n                newStream.addTrack(self.audioDestination.stream.getTracks().filter(function(t) {\n                    return t.kind === 'audio';\n                })[0]);\n            }\n\n            arrayOfMediaStreams.push(newStream);\n        });\n    };\n\n    this.releaseStreams = function() {\n        videos = [];\n        isStopDrawingFrames = true;\n\n        if (self.gainNode) {\n            self.gainNode.disconnect();\n            self.gainNode = null;\n        }\n\n        if (self.audioSources.length) {\n            self.audioSources.forEach(function(source) {\n                source.disconnect();\n            });\n            self.audioSources = [];\n        }\n\n        if (self.audioDestination) {\n            self.audioDestination.disconnect();\n            self.audioDestination = null;\n        }\n\n        if (self.audioContext) {\n            self.audioContext.close();\n        }\n\n        self.audioContext = null;\n\n        context.clearRect(0, 0, canvas.width, canvas.height);\n\n        if (canvas.stream) {\n            canvas.stream.stop();\n            canvas.stream = null;\n        }\n    };\n\n    this.resetVideoStreams = function(streams) {\n        if (streams && !(streams instanceof Array)) {\n            streams = [streams];\n        }\n\n        resetVideoStreams(streams);\n    };\n\n    function resetVideoStreams(streams) {\n        videos = [];\n        streams = streams || arrayOfMediaStreams;\n\n        // via: @adrian-ber\n        streams.forEach(function(stream) {\n            if (!stream.getTracks().filter(function(t) {\n                    return t.kind === 'video';\n                }).length) {\n                return;\n            }\n\n            var video = getVideo(stream);\n            video.stream = stream;\n            videos.push(video);\n        });\n    }\n\n    // for debugging\n    this.name = 'MultiStreamsMixer';\n    this.toString = function() {\n        return this.name;\n    };\n\n    this.getMixedStream = getMixedStream;\n\n}\n\nif (typeof RecordRTC === 'undefined') {\n    if (typeof module !== 'undefined' /* && !!module.exports*/ ) {\n        module.exports = MultiStreamsMixer;\n    }\n\n    if (typeof define === 'function' && define.amd) {\n        define('MultiStreamsMixer', [], function() {\n            return MultiStreamsMixer;\n        });\n    }\n}\n\n// ______________________\n// MultiStreamRecorder.js\n\n/*\n * Video conference recording, using captureStream API along with WebAudio and Canvas2D API.\n */\n\n/**\n * MultiStreamRecorder can record multiple videos in single container.\n * @summary Multi-videos recorder.\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @typedef MultiStreamRecorder\n * @class\n * @example\n * var options = {\n *     mimeType: 'video/webm'\n * }\n * var recorder = new MultiStreamRecorder(ArrayOfMediaStreams, options);\n * recorder.record();\n * recorder.stop(function(blob) {\n *     video.src = URL.createObjectURL(blob);\n *\n *     // or\n *     var blob = recorder.blob;\n * });\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n * @param {MediaStreams} mediaStreams - Array of MediaStreams.\n * @param {object} config - {disableLogs:true, frameInterval: 1, mimeType: \"video/webm\"}\n */\n\nfunction MultiStreamRecorder(arrayOfMediaStreams, options) {\n    arrayOfMediaStreams = arrayOfMediaStreams || [];\n    var self = this;\n\n    var mixer;\n    var mediaRecorder;\n\n    options = options || {\n        elementClass: 'multi-streams-mixer',\n        mimeType: 'video/webm',\n        video: {\n            width: 360,\n            height: 240\n        }\n    };\n\n    if (!options.frameInterval) {\n        options.frameInterval = 10;\n    }\n\n    if (!options.video) {\n        options.video = {};\n    }\n\n    if (!options.video.width) {\n        options.video.width = 360;\n    }\n\n    if (!options.video.height) {\n        options.video.height = 240;\n    }\n\n    /**\n     * This method records all MediaStreams.\n     * @method\n     * @memberof MultiStreamRecorder\n     * @example\n     * recorder.record();\n     */\n    this.record = function() {\n        // github/muaz-khan/MultiStreamsMixer\n        mixer = new MultiStreamsMixer(arrayOfMediaStreams, options.elementClass || 'multi-streams-mixer');\n\n        if (getAllVideoTracks().length) {\n            mixer.frameInterval = options.frameInterval || 10;\n            mixer.width = options.video.width || 360;\n            mixer.height = options.video.height || 240;\n            mixer.startDrawingFrames();\n        }\n\n        if (options.previewStream && typeof options.previewStream === 'function') {\n            options.previewStream(mixer.getMixedStream());\n        }\n\n        // record using MediaRecorder API\n        mediaRecorder = new MediaStreamRecorder(mixer.getMixedStream(), options);\n        mediaRecorder.record();\n    };\n\n    function getAllVideoTracks() {\n        var tracks = [];\n        arrayOfMediaStreams.forEach(function(stream) {\n            getTracks(stream, 'video').forEach(function(track) {\n                tracks.push(track);\n            });\n        });\n        return tracks;\n    }\n\n    /**\n     * This method stops recording MediaStream.\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\n     * @method\n     * @memberof MultiStreamRecorder\n     * @example\n     * recorder.stop(function(blob) {\n     *     video.src = URL.createObjectURL(blob);\n     * });\n     */\n    this.stop = function(callback) {\n        if (!mediaRecorder) {\n            return;\n        }\n\n        mediaRecorder.stop(function(blob) {\n            self.blob = blob;\n\n            callback(blob);\n\n            self.clearRecordedData();\n        });\n    };\n\n    /**\n     * This method pauses the recording process.\n     * @method\n     * @memberof MultiStreamRecorder\n     * @example\n     * recorder.pause();\n     */\n    this.pause = function() {\n        if (mediaRecorder) {\n            mediaRecorder.pause();\n        }\n    };\n\n    /**\n     * This method resumes the recording process.\n     * @method\n     * @memberof MultiStreamRecorder\n     * @example\n     * recorder.resume();\n     */\n    this.resume = function() {\n        if (mediaRecorder) {\n            mediaRecorder.resume();\n        }\n    };\n\n    /**\n     * This method resets currently recorded data.\n     * @method\n     * @memberof MultiStreamRecorder\n     * @example\n     * recorder.clearRecordedData();\n     */\n    this.clearRecordedData = function() {\n        if (mediaRecorder) {\n            mediaRecorder.clearRecordedData();\n            mediaRecorder = null;\n        }\n\n        if (mixer) {\n            mixer.releaseStreams();\n            mixer = null;\n        }\n    };\n\n    /**\n     * Add extra media-streams to existing recordings.\n     * @method\n     * @memberof MultiStreamRecorder\n     * @param {MediaStreams} mediaStreams - Array of MediaStreams\n     * @example\n     * recorder.addStreams([newAudioStream, newVideoStream]);\n     */\n    this.addStreams = function(streams) {\n        if (!streams) {\n            throw 'First parameter is required.';\n        }\n\n        if (!(streams instanceof Array)) {\n            streams = [streams];\n        }\n\n        arrayOfMediaStreams.concat(streams);\n\n        if (!mediaRecorder || !mixer) {\n            return;\n        }\n\n        mixer.appendStreams(streams);\n\n        if (options.previewStream && typeof options.previewStream === 'function') {\n            options.previewStream(mixer.getMixedStream());\n        }\n    };\n\n    /**\n     * Reset videos during live recording. Replace old videos e.g. replace cameras with full-screen.\n     * @method\n     * @memberof MultiStreamRecorder\n     * @param {MediaStreams} mediaStreams - Array of MediaStreams\n     * @example\n     * recorder.resetVideoStreams([newVideo1, newVideo2]);\n     */\n    this.resetVideoStreams = function(streams) {\n        if (!mixer) {\n            return;\n        }\n\n        if (streams && !(streams instanceof Array)) {\n            streams = [streams];\n        }\n\n        mixer.resetVideoStreams(streams);\n    };\n\n    /**\n     * Returns MultiStreamsMixer\n     * @method\n     * @memberof MultiStreamRecorder\n     * @example\n     * let mixer = recorder.getMixer();\n     * mixer.appendStreams([newStream]);\n     */\n    this.getMixer = function() {\n        return mixer;\n    };\n\n    // for debugging\n    this.name = 'MultiStreamRecorder';\n    this.toString = function() {\n        return this.name;\n    };\n}\n\nif (typeof RecordRTC !== 'undefined') {\n    RecordRTC.MultiStreamRecorder = MultiStreamRecorder;\n}\n\n// _____________________\n// RecordRTC.promises.js\n\n/**\n * RecordRTCPromisesHandler adds promises support in {@link RecordRTC}. Try a {@link https://github.com/muaz-khan/RecordRTC/blob/master/simple-demos/RecordRTCPromisesHandler.html|demo here}\n * @summary Promises for {@link RecordRTC}\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @typedef RecordRTCPromisesHandler\n * @class\n * @example\n * var recorder = new RecordRTCPromisesHandler(mediaStream, options);\n * recorder.startRecording()\n *         .then(successCB)\n *         .catch(errorCB);\n * // Note: You can access all RecordRTC API using \"recorder.recordRTC\" e.g. \n * recorder.recordRTC.onStateChanged = function(state) {};\n * recorder.recordRTC.setRecordingDuration(5000);\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n * @param {MediaStream} mediaStream - Single media-stream object, array of media-streams, html-canvas-element, etc.\n * @param {object} config - {type:\"video\", recorderType: MediaStreamRecorder, disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, etc.}\n * @throws Will throw an error if \"new\" keyword is not used to initiate \"RecordRTCPromisesHandler\". Also throws error if first argument \"MediaStream\" is missing.\n * @requires {@link RecordRTC}\n */\n\nfunction RecordRTCPromisesHandler(mediaStream, options) {\n    if (!this) {\n        throw 'Use \"new RecordRTCPromisesHandler()\"';\n    }\n\n    if (typeof mediaStream === 'undefined') {\n        throw 'First argument \"MediaStream\" is required.';\n    }\n\n    var self = this;\n\n    /**\n     * @property {Blob} blob - Access/reach the native {@link RecordRTC} object.\n     * @memberof RecordRTCPromisesHandler\n     * @example\n     * let internal = recorder.recordRTC.getInternalRecorder();\n     * alert(internal instanceof MediaStreamRecorder);\n     * recorder.recordRTC.onStateChanged = function(state) {};\n     */\n    self.recordRTC = new RecordRTC(mediaStream, options);\n\n    /**\n     * This method records MediaStream.\n     * @method\n     * @memberof RecordRTCPromisesHandler\n     * @example\n     * recorder.startRecording()\n     *         .then(successCB)\n     *         .catch(errorCB);\n     */\n    this.startRecording = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                self.recordRTC.startRecording();\n                resolve();\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * This method stops the recording.\n     * @method\n     * @memberof RecordRTCPromisesHandler\n     * @example\n     * recorder.stopRecording().then(function() {\n     *     var blob = recorder.getBlob();\n     * }).catch(errorCB);\n     */\n    this.stopRecording = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                self.recordRTC.stopRecording(function(url) {\n                    self.blob = self.recordRTC.getBlob();\n\n                    if (!self.blob || !self.blob.size) {\n                        reject('Empty blob.', self.blob);\n                        return;\n                    }\n\n                    resolve(url);\n                });\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * This method pauses the recording. You can resume recording using \"resumeRecording\" method.\n     * @method\n     * @memberof RecordRTCPromisesHandler\n     * @example\n     * recorder.pauseRecording()\n     *         .then(successCB)\n     *         .catch(errorCB);\n     */\n    this.pauseRecording = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                self.recordRTC.pauseRecording();\n                resolve();\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * This method resumes the recording.\n     * @method\n     * @memberof RecordRTCPromisesHandler\n     * @example\n     * recorder.resumeRecording()\n     *         .then(successCB)\n     *         .catch(errorCB);\n     */\n    this.resumeRecording = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                self.recordRTC.resumeRecording();\n                resolve();\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * This method returns data-url for the recorded blob.\n     * @method\n     * @memberof RecordRTCPromisesHandler\n     * @example\n     * recorder.stopRecording().then(function() {\n     *     recorder.getDataURL().then(function(dataURL) {\n     *         window.open(dataURL);\n     *     }).catch(errorCB);;\n     * }).catch(errorCB);\n     */\n    this.getDataURL = function(callback) {\n        return new Promise(function(resolve, reject) {\n            try {\n                self.recordRTC.getDataURL(function(dataURL) {\n                    resolve(dataURL);\n                });\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * This method returns the recorded blob.\n     * @method\n     * @memberof RecordRTCPromisesHandler\n     * @example\n     * recorder.stopRecording().then(function() {\n     *     recorder.getBlob().then(function(blob) {})\n     * }).catch(errorCB);\n     */\n    this.getBlob = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                resolve(self.recordRTC.getBlob());\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * This method returns the internal recording object.\n     * @method\n     * @memberof RecordRTCPromisesHandler\n     * @example\n     * let internalRecorder = await recorder.getInternalRecorder();\n     * if(internalRecorder instanceof MultiStreamRecorder) {\n     *     internalRecorder.addStreams([newAudioStream]);\n     *     internalRecorder.resetVideoStreams([screenStream]);\n     * }\n     * @returns {Object} \n     */\n    this.getInternalRecorder = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                resolve(self.recordRTC.getInternalRecorder());\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * This method resets the recorder. So that you can reuse single recorder instance many times.\n     * @method\n     * @memberof RecordRTCPromisesHandler\n     * @example\n     * await recorder.reset();\n     * recorder.startRecording(); // record again\n     */\n    this.reset = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                resolve(self.recordRTC.reset());\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * Destroy RecordRTC instance. Clear all recorders and objects.\n     * @method\n     * @memberof RecordRTCPromisesHandler\n     * @example\n     * recorder.destroy().then(successCB).catch(errorCB);\n     */\n    this.destroy = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                resolve(self.recordRTC.destroy());\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * Get recorder's readonly state.\n     * @method\n     * @memberof RecordRTCPromisesHandler\n     * @example\n     * let state = await recorder.getState();\n     * // or\n     * recorder.getState().then(state => { console.log(state); })\n     * @returns {String} Returns recording state.\n     */\n    this.getState = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                resolve(self.recordRTC.getState());\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * @property {Blob} blob - Recorded data as \"Blob\" object.\n     * @memberof RecordRTCPromisesHandler\n     * @example\n     * await recorder.stopRecording();\n     * let blob = recorder.getBlob(); // or \"recorder.recordRTC.blob\"\n     * invokeSaveAsDialog(blob);\n     */\n    this.blob = null;\n\n    /**\n     * RecordRTC version number\n     * @property {String} version - Release version number.\n     * @memberof RecordRTCPromisesHandler\n     * @static\n     * @readonly\n     * @example\n     * alert(recorder.version);\n     */\n    this.version = '5.6.2';\n}\n\nif (typeof RecordRTC !== 'undefined') {\n    RecordRTC.RecordRTCPromisesHandler = RecordRTCPromisesHandler;\n}\n\n// ______________________\n// WebAssemblyRecorder.js\n\n/**\n * WebAssemblyRecorder lets you create webm videos in JavaScript via WebAssembly. The library consumes raw RGBA32 buffers (4 bytes per pixel) and turns them into a webm video with the given framerate and quality. This makes it compatible out-of-the-box with ImageData from a CANVAS. With realtime mode you can also use webm-wasm for streaming webm videos.\n * @summary Video recording feature in Chrome, Firefox and maybe Edge.\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @typedef WebAssemblyRecorder\n * @class\n * @example\n * var recorder = new WebAssemblyRecorder(mediaStream);\n * recorder.record();\n * recorder.stop(function(blob) {\n *     video.src = URL.createObjectURL(blob);\n * });\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\n * @param {object} config - {webAssemblyPath:'webm-wasm.wasm',workerPath: 'webm-worker.js', frameRate: 30, width: 1920, height: 1080, bitrate: 1024, realtime: true}\n */\nfunction WebAssemblyRecorder(stream, config) {\n    // based on: github.com/GoogleChromeLabs/webm-wasm\n\n    if (typeof ReadableStream === 'undefined' || typeof WritableStream === 'undefined') {\n        // because it fixes readable/writable streams issues\n        console.error('Following polyfill is strongly recommended: https://unpkg.com/@mattiasbuelens/web-streams-polyfill/dist/polyfill.min.js');\n    }\n\n    config = config || {};\n\n    config.width = config.width || 640;\n    config.height = config.height || 480;\n    config.frameRate = config.frameRate || 30;\n    config.bitrate = config.bitrate || 1200;\n    config.realtime = config.realtime || true;\n\n    function createBufferURL(buffer, type) {\n        return URL.createObjectURL(new Blob([buffer], {\n            type: type || ''\n        }));\n    }\n\n    var finished;\n\n    function cameraStream() {\n        return new ReadableStream({\n            start: function(controller) {\n                var cvs = document.createElement('canvas');\n                var video = document.createElement('video');\n                var first = true;\n                video.srcObject = stream;\n                video.muted = true;\n                video.height = config.height;\n                video.width = config.width;\n                video.volume = 0;\n                video.onplaying = function() {\n                    cvs.width = config.width;\n                    cvs.height = config.height;\n                    var ctx = cvs.getContext('2d');\n                    var frameTimeout = 1000 / config.frameRate;\n                    var cameraTimer = setInterval(function f() {\n                        if (finished) {\n                            clearInterval(cameraTimer);\n                            controller.close();\n                        }\n\n                        if (first) {\n                            first = false;\n                            if (config.onVideoProcessStarted) {\n                                config.onVideoProcessStarted();\n                            }\n                        }\n\n                        ctx.drawImage(video, 0, 0);\n                        if (controller._controlledReadableStream.state !== 'closed') {\n                            try {\n                                controller.enqueue(\n                                    ctx.getImageData(0, 0, config.width, config.height)\n                                );\n                            } catch (e) {}\n                        }\n                    }, frameTimeout);\n                };\n                video.play();\n            }\n        });\n    }\n\n    var worker;\n\n    function startRecording(stream, buffer) {\n        if (!config.workerPath && !buffer) {\n            finished = false;\n\n            // is it safe to use @latest ?\n\n            fetch(\n                'https://unpkg.com/webm-wasm@latest/dist/webm-worker.js'\n            ).then(function(r) {\n                r.arrayBuffer().then(function(buffer) {\n                    startRecording(stream, buffer);\n                });\n            });\n            return;\n        }\n\n        if (!config.workerPath && buffer instanceof ArrayBuffer) {\n            var blob = new Blob([buffer], {\n                type: 'text/javascript'\n            });\n            config.workerPath = URL.createObjectURL(blob);\n        }\n\n        if (!config.workerPath) {\n            console.error('workerPath parameter is missing.');\n        }\n\n        worker = new Worker(config.workerPath);\n\n        worker.postMessage(config.webAssemblyPath || 'https://unpkg.com/webm-wasm@latest/dist/webm-wasm.wasm');\n        worker.addEventListener('message', function(event) {\n            if (event.data === 'READY') {\n                worker.postMessage({\n                    width: config.width,\n                    height: config.height,\n                    bitrate: config.bitrate || 1200,\n                    timebaseDen: config.frameRate || 30,\n                    realtime: config.realtime\n                });\n\n                cameraStream().pipeTo(new WritableStream({\n                    write: function(image) {\n                        if (finished) {\n                            console.error('Got image, but recorder is finished!');\n                            return;\n                        }\n\n                        worker.postMessage(image.data.buffer, [image.data.buffer]);\n                    }\n                }));\n            } else if (!!event.data) {\n                if (!isPaused) {\n                    arrayOfBuffers.push(event.data);\n                }\n            }\n        });\n    }\n\n    /**\n     * This method records video.\n     * @method\n     * @memberof WebAssemblyRecorder\n     * @example\n     * recorder.record();\n     */\n    this.record = function() {\n        arrayOfBuffers = [];\n        isPaused = false;\n        this.blob = null;\n        startRecording(stream);\n\n        if (typeof config.initCallback === 'function') {\n            config.initCallback();\n        }\n    };\n\n    var isPaused;\n\n    /**\n     * This method pauses the recording process.\n     * @method\n     * @memberof WebAssemblyRecorder\n     * @example\n     * recorder.pause();\n     */\n    this.pause = function() {\n        isPaused = true;\n    };\n\n    /**\n     * This method resumes the recording process.\n     * @method\n     * @memberof WebAssemblyRecorder\n     * @example\n     * recorder.resume();\n     */\n    this.resume = function() {\n        isPaused = false;\n    };\n\n    function terminate(callback) {\n        if (!worker) {\n            if (callback) {\n                callback();\n            }\n\n            return;\n        }\n\n        // Wait for null event data to indicate that the encoding is complete\n        worker.addEventListener('message', function(event) {\n            if (event.data === null) {\n                worker.terminate();\n                worker = null;\n\n                if (callback) {\n                    callback();\n                }\n            }\n        });\n\n        worker.postMessage(null);\n    }\n\n    var arrayOfBuffers = [];\n\n    /**\n     * This method stops recording video.\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\n     * @method\n     * @memberof WebAssemblyRecorder\n     * @example\n     * recorder.stop(function(blob) {\n     *     video.src = URL.createObjectURL(blob);\n     * });\n     */\n    this.stop = function(callback) {\n        finished = true;\n\n        var recorder = this;\n\n        terminate(function() {\n            recorder.blob = new Blob(arrayOfBuffers, {\n                type: 'video/webm'\n            });\n\n            callback(recorder.blob);\n        });\n    };\n\n    // for debugging\n    this.name = 'WebAssemblyRecorder';\n    this.toString = function() {\n        return this.name;\n    };\n\n    /**\n     * This method resets currently recorded data.\n     * @method\n     * @memberof WebAssemblyRecorder\n     * @example\n     * recorder.clearRecordedData();\n     */\n    this.clearRecordedData = function() {\n        arrayOfBuffers = [];\n        isPaused = false;\n        this.blob = null;\n\n        // todo: if recording-ON then STOP it first\n    };\n\n    /**\n     * @property {Blob} blob - The recorded blob object.\n     * @memberof WebAssemblyRecorder\n     * @example\n     * recorder.stop(function(){\n     *     var blob = recorder.blob;\n     * });\n     */\n    this.blob = null;\n}\n\nif (typeof RecordRTC !== 'undefined') {\n    RecordRTC.WebAssemblyRecorder = WebAssemblyRecorder;\n}\n","export default class Webcam {\r\n    constructor(webcamElement, facingMode = 'user', canvasElement = null, snapSoundElement = null) {\r\n      this._webcamElement = webcamElement;\r\n      this._webcamElement.width = this._webcamElement.width || 640;\r\n      this._webcamElement.height = this._webcamElement.height || this._webcamElement.width * (3 / 4);\r\n      this._facingMode = facingMode;\r\n      this._webcamList = [];\r\n      this._streamList = [];\r\n      this._selectedDeviceId = '';\r\n      this._canvasElement = canvasElement;\r\n      this._snapSoundElement = snapSoundElement;\r\n    }\r\n\r\n    get facingMode(){\r\n      return this._facingMode;\r\n    }\r\n\r\n    set facingMode(value){\r\n      this._facingMode = value;\r\n    }\r\n\r\n    get webcamList(){\r\n      return this._webcamList;\r\n    }\r\n\r\n    get webcamCount(){\r\n      return this._webcamList.length;\r\n    }\r\n\r\n    get selectedDeviceId(){\r\n      return this._selectedDeviceId;\r\n    }\r\n\r\n    /* Get all video input devices info */\r\n    getVideoInputs(mediaDevices){\r\n      this._webcamList = [];\r\n      mediaDevices.forEach(mediaDevice => {\r\n        if (mediaDevice.kind === 'videoinput') {\r\n          this._webcamList.push(mediaDevice);\r\n        }\r\n      });\r\n      if(this._webcamList.length == 1){\r\n        this._facingMode = 'user';\r\n      }    \r\n      return this._webcamList;\r\n    }\r\n\r\n    /* Get media constraints */\r\n    getMediaConstraints() {\r\n        var videoConstraints = {};\r\n        if (this._selectedDeviceId == '') {\r\n            videoConstraints.facingMode =  this._facingMode;\r\n        } else {\r\n            videoConstraints.deviceId = { exact: this._selectedDeviceId};\r\n        }\r\n        var constraints = {\r\n            video: videoConstraints,\r\n            audio: false\r\n        };\r\n        return constraints;\r\n    }\r\n\r\n    /* Select camera based on facingMode */ \r\n    selectCamera(){\r\n      for(let webcam of this._webcamList){\r\n        if(   (this._facingMode=='user' && webcam.label.toLowerCase().includes('front'))\r\n          ||  (this._facingMode=='enviroment' && webcam.label.toLowerCase().includes('back'))\r\n        )\r\n        {\r\n          this._selectedDeviceId = webcam.deviceId;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    /* Change Facing mode and selected camera */ \r\n    flip(){\r\n      this._facingMode = (this._facingMode == 'user')? 'enviroment': 'user';\r\n      this._webcamElement.style.transform = \"\";\r\n      this.selectCamera();  \r\n    }\r\n\r\n    /*\r\n      1. Get permission from user\r\n      2. Get all video input devices info\r\n      3. Select camera based on facingMode \r\n      4. Start stream\r\n    */\r\n    async start(startStream = true) {\r\n      return new Promise((resolve, reject) => {         \r\n        this.stop();\r\n        navigator.mediaDevices.getUserMedia(this.getMediaConstraints()) //get permisson from user\r\n          .then(stream => {\r\n            this._streamList.push(stream);\r\n            this.info() //get all video input devices info\r\n              .then(webcams =>{\r\n                this.selectCamera();   //select camera based on facingMode\r\n                if(startStream){\r\n                    this.stream()\r\n                        .then(facingMode =>{\r\n                            resolve(this._facingMode);\r\n                        })\r\n                        .catch(error => {\r\n                            reject(error);\r\n                        });\r\n                }else{\r\n                    resolve(this._selectedDeviceId);\r\n                }\r\n              }) \r\n              .catch(error => {\r\n                reject(error);\r\n              });\r\n          })\r\n          .catch(error => {\r\n              reject(error);\r\n          });\r\n      });\r\n    }\r\n\r\n    /* Get all video input devices info */ \r\n    async info(){\r\n      return new Promise((resolve, reject) => {            \r\n        navigator.mediaDevices.enumerateDevices()\r\n          .then(devices =>{\r\n            this.getVideoInputs(devices);\r\n            resolve(this._webcamList);\r\n          }) \r\n          .catch(error => {\r\n            reject(error);\r\n          });\r\n      });\r\n    }\r\n  \r\n    /* Start streaming webcam to video element */ \r\n    async stream() {\r\n      return new Promise((resolve, reject) => {         \r\n        navigator.mediaDevices.getUserMedia(this.getMediaConstraints())\r\n          .then(stream => {\r\n              this._streamList.push(stream);\r\n              this._webcamElement.srcObject = stream;\r\n              if(this._facingMode == 'user'){\r\n                this._webcamElement.style.transform = \"scale(-1,1)\";\r\n              }\r\n              this._webcamElement.play();\r\n              resolve(this._facingMode);\r\n          })\r\n          .catch(error => {\r\n              console.log(error);\r\n              reject(error);\r\n          });\r\n      });\r\n    }\r\n\r\n    /* Stop streaming webcam */ \r\n    stop() {\r\n      this._streamList.forEach(stream => {\r\n        stream.getTracks().forEach(track => {\r\n          track.stop();\r\n        });\r\n      });   \r\n    }\r\n\r\n    snap() {\r\n      if(this._canvasElement!=null){\r\n        if(this._snapSoundElement!= null){\r\n          this._snapSoundElement.play();\r\n        }\r\n        this._canvasElement.height = this._webcamElement.scrollHeight;\r\n        this._canvasElement.width = this._webcamElement.scrollWidth;\r\n        let context = this._canvasElement.getContext('2d');\r\n        if(this._facingMode == 'user'){\r\n          context.translate(this._canvasElement.width, 0);\r\n          context.scale(-1, 1);\r\n        }\r\n        context.clearRect(0, 0, this._canvasElement.width, this._canvasElement.height);\r\n        context.drawImage(this._webcamElement, 0, 0, this._canvasElement.width, this._canvasElement.height);\r\n        let data = this._canvasElement.toDataURL('image/png');\r\n        return data;\r\n      }\r\n      else{\r\n        throw \"canvas element is missing\";\r\n      }\r\n    } \r\n}\r\n","<script>\n    import { onMount } from 'svelte';\n    import RecordRTC, { MediaStreamRecorder, WhammyRecorder } from './RecordRTC.js';\n    import Webcam from 'webcam-easy';\n    let videoRecorder;\n    let videoRecorded;\n    let videoRecordedURL;\n    let recorder;\n    let webcamElement;\n    let canvasElement;\n    let webcam;\n\n    onMount(() => {\n        videoRecorder  = document.getElementById(\"video-recorder\");\n        videoRecorded = document.getElementById(\"video-recorded\");\n        webcamElement = document.getElementById('webcam');\n        canvasElement = document.getElementById('canvas');\n        webcam = new Webcam(webcamElement, 'user', canvasElement);\n\n\t});\n\n    export const handleRecordVideo = () => {\n        const recordingTimeMS = 6000;\n        console.log(videoRecorder)\n        videoRecorder.style.display = \"block\"; // display video for record\n        videoRecorded.style.display = \"none\"; // hide video recorded\n        videoRecorder.style.backgroundColor = \"black\"\n        videoRecorded.style.backgroundColor = \"black\";\n\n        if (videoRecordedURL) { // check for revoke obj url\n            URL.revokeObjectURL(videoRecordedURL)\n        }\n\n        captureCamera(function(camera) {\n            videoRecorder.muted = true;\n            videoRecorder.volume = 0;\n            videoRecorder.srcObject = camera;\n\n            recorder = RecordRTC(camera, {\n                type: 'video',\n                audio: false,\n                video: true,\n                mimeType: 'video/webm',\n                recorderType: MediaStreamRecorder || WhammyRecorder\n            });\n\n            recorder.startRecording();\n\n            // release camera on stopRecording\n            recorder.camera = camera;\n\n            setTimeout(function () {\n                recorder.stopRecording(stopRecordingCallback);\n            }, recordingTimeMS)\n        })\n    }\n\n    const captureCamera = (callback) => {\n        const constraints = { video: true };\n\n        navigator.mediaDevices.getUserMedia(constraints).then(function(camera) {\n        callback(camera);\n        }).catch(function(error) {\n        console.error(error);\n\n        if (error.name.indexOf('NotAllowedError') !== -1) {\n            onErrorGetAccessCamera()\n        }\n        });\n    }\n\n    const stopRecordingCallback = () => {\n        const recordedBlob = recorder.getBlob()\n        console.log('recordedBlob', recordedBlob)\n        videoRecordedURL = URL.createObjectURL(recordedBlob);\n        videoRecorder.muted = true;\n        videoRecorded.src = videoRecordedURL\n        recorder.camera.stop();\n        recorder.destroy();\n        recorder = null;\n\n        videoRecorder.style.display = \"none\"; // hide video recorder\n        videoRecorded.style.display = \"block\"; // display video recorded\n        // Assign video file to `input file for prepare to upload`\n    }\n\n    const startWebcam = () => {\n        webcam.start()\n        .then(result =>{\n            console.log(\"webcam started\");\n        })\n        .catch(err => {\n            console.log(err);\n        });\n    }\n\n    const handleTakePicture = () => {\n        const picture = webcam.snap();\n        console.log('picture =>', picture)\n        webcam.stop();\n    }\n\n</script>\n<link rel=\"stylesheet\" href=\"video-verify-identity.css\" />\n\n<div id=\"video-recorder-container\" class=\"video-recorder-container\">\n    <content class=\"video-recorder-content-container\">\n        <div class=\"content-wrapper\">\n            <div class=\"video-recorder-header-message\">\n                <span>Record Video</span>\n            </div>\n            <div class=\"video-recorder-wrapper\">\n                <video id=\"video-recorder\" class=\"video-recorder\" autoplay muted playsinline></video>\n                <video id=\"video-recorded\" class=\"video-recorder\" controls style=\"display: none\"></video>\n            </div>\n            <div class=\"start-verify-button-wrapper\">\n                <button class=\"start-verify-button\" on:click={handleRecordVideo}>\n                    <span>Start Recording</span>\n                </button>\n            </div>\n            <div class=\"message-wrapper\">\n                <div class=\"hint-message\">\n                    <span>Note: Recording for 5 seconds when you click start recording </span>\n                </div>\n            </div>\n            <p id=\"not-verify-message\" class=\"upload-document-error\" style=\"display: none; margin-bottom: 10px;\">กรุณายืนยันตัวตน</p>\n            <p id=\"video-verify-success-message\" class=\"upload-success\" style=\"display: none; margin-bottom: 10px;\">วิดีโอของท่านได้รับการบันทึกเรียบร้อยแล้ว</p>\n        </div>\n    </content>\n    <content class=\"video-recorder-content-container\">\n        <div class=\"content-wrapper\">\n            <div class=\"video-recorder-header-message\">\n                <span>Web Cam Capture</span>\n            </div>\n            <div class=\"video-recorder-wrapper\">\n                <video id=\"webcam\" autoplay muted playsinline></video>\n                <canvas id=\"canvas\" class=\"d-none\"></canvas>\n            </div>\n            <div class=\"start-verify-button-wrapper\">\n                <button class=\"start-verify-button\" on:click={startWebcam}>\n                    <span>Start webcam</span>\n                </button>\n                <button class=\"start-verify-button\" on:click={handleTakePicture}>\n                    <span>take a picture</span>\n                </button>\n            </div>\n        </div>\n    </content>\n</div>","<script>\n\timport adapter from 'webrtc-adapter';\n\timport VideoRecord from './VideoRecord.svelte'\n\n\tconst userAgent = navigator.userAgent;\n\tconst detectOpenWebOnLineApp = () => {\n\t\tconst userAgentSplitToArr = userAgent.split(' ');\n\t\tconst userAgentSplitToArrLast = userAgentSplitToArr[userAgentSplitToArr.length - 1]\n\n\t\treturn userAgentSplitToArrLast.includes('Line')\n\t}\n\n\tif (window.location.href.includes('?openExternalBrowser=1')) {\n\t\twindow.location.href = window.location.href.replace('/?openExternalBrowser=1', '');\n\t}\n\n\texport const getCurrentWebOpen = () => {\n\t\treturn detectOpenWebOnLineApp() ? 'Line Application' : 'Itself';\n\t}\n\n\texport let name;\n\t$: adapter;\n\t$: userAgent\n</script>\n<link rel=\"stylesheet\" href=\"main.css\" />\n\n<header>\n\tWebRTC Experiment🧪\n</header>\n<main>\n\t<div class=\"flex-container\">\n\t\t<div class=\"row\"> \n\t\t\t<VideoRecord />\n\t\t\t<div class=\"div-table\">\n\t\t\t\t<div class=\"div-table-row\">\n\t\t\t\t\t<div class=\"div-table-col header\" align=\"center\">Browser</div>\n\t\t\t\t\t<div class=\"div-table-col header\">Version</div>\n\t\t\t\t\t<div class=\"div-table-col header\">Run On</div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"div-table-row\">\n\t\t\t\t\t<div class=\"div-table-col\">{adapter.browserDetails.browser}</div>\n\t\t\t\t\t<div class=\"div-table-col\">{adapter.browserDetails.version}</div>\n\t\t\t\t\t<div class=\"div-table-col\">{getCurrentWebOpen()}</div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"div-table-row\" style=\"color: white;\">\n\t\t\t\t\t{userAgent}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</main>\n\n<footer>\n\tCopyright © 2021 Nottnt. \n\t<img src=\"/sad-cat.png\" alt=\"Girl in a jacket\" width=\"25\" height=\"25\">\n</footer>","import App from './App.svelte';\n\nconst app = new App({\n\ttarget: document.body,\n\tprops: {\n\t\tname: 'nott'\n\t}\n});\n\nexport default app;"],"names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","element","name","document","createElement","space","data","createTextNode","listen","event","handler","options","addEventListener","removeEventListener","attr","attribute","value","removeAttribute","getAttribute","setAttribute","set_style","key","important","style","setProperty","current_component","set_current_component","component","onMount","Error","get_current_component","$$","on_mount","push","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","flushing","seen_callbacks","Set","flush","i","length","update","pop","callback","has","add","clear","fragment","before_update","dirty","p","ctx","after_update","outroing","transition_in","block","local","delete","mount_component","customElement","on_destroy","m","new_on_destroy","map","filter","destroy_component","detaching","d","make_dirty","then","fill","init","instance","create_fragment","not_equal","props","append_styles","parent_component","bound","on_disconnect","context","Map","callbacks","skip_bound","root","ready","ret","rest","hydrate","nodes","Array","from","childNodes","children","l","c","intro","SvelteComponent","$destroy","this","$on","type","index","indexOf","splice","$set","$$props","obj","$$set","keys","logDisabled_","deprecationWarnings_","extractVersion","uastring","expr","pos","match","parseInt","wrapPeerConnectionEvent","window","eventNameToWrap","wrapper","RTCPeerConnection","proto","prototype","nativeAddEventListener","nativeEventName","cb","apply","arguments","wrappedCallback","e","modifiedEvent","handleEvent","_eventMap","set","nativeRemoveEventListener","unwrappedCb","get","size","defineProperty","enumerable","configurable","disableLog","bool","disableWarnings","log","console","deprecated","oldMethod","newMethod","warn","isObject","val","toString","call","compactObject","reduce","accumulator","isObj","isEmptyObject","undefined","assign","walkStats","stats","base","resultSet","id","endsWith","filterStats","result","track","outbound","streamStatsType","filteredResult","trackStats","trackIdentifier","trackStat","trackId","logging","utils.log","shimGetUserMedia","browserDetails","navigator","mediaDevices","constraintsToChrome_","mandatory","optional","cc","r","ideal","exact","min","max","oldname_","prefix","charAt","toUpperCase","slice","oc","mix","advanced","concat","shimConstraints_","constraints","func","version","JSON","parse","stringify","audio","remap","video","face","facingMode","getSupportedFacingModeLies","getSupportedConstraints","matches","enumerateDevices","devices","dev","kind","find","some","label","toLowerCase","includes","deviceId","shimError_","PermissionDeniedError","PermissionDismissedError","InvalidStateError","DevicesNotFoundError","ConstraintNotSatisfiedError","TrackStartError","MediaDeviceFailedDueToShutdown","MediaDeviceKillSwitchOn","TabCaptureError","ScreenCaptureError","DeviceCaptureError","message","constraint","constraintName","getUserMedia","onSuccess","onError","webkitGetUserMedia","bind","origGetUserMedia","cs","stream","getAudioTracks","getVideoTracks","getTracks","stop","DOMException","reject","shimMediaStream","MediaStream","webkitMediaStream","shimOnTrack","_ontrack","f","origSetRemoteDescription","setRemoteDescription","_ontrackpoly","te","receiver","getReceivers","Event","transceiver","streams","dispatchEvent","utils.wrapPeerConnectionEvent","shimGetSendersWithDtmf","shimSenderWithDtmf","pc","dtmf","_dtmf","createDTMFSender","_pc","getSenders","_senders","origAddTrack","addTrack","sender","origRemoveTrack","removeTrack","idx","origAddStream","addStream","origRemoveStream","removeStream","s","RTCRtpSender","origGetSenders","senders","shimGetStats","origGetStats","getStats","selector","onSucc","onErr","fixChromeStats_","response","standardReport","report","standardStats","timestamp","localcandidate","remotecandidate","names","stat","makeMapStats","successCallbackWrapper_","shimSenderReceiverGetStats","RTCRtpReceiver","utils.filterStats","origGetReceivers","receivers","srcElement","MediaStreamTrack","err","shimAddTrackRemoveTrackWithNative","getLocalStreams","_shimmedLocalStreams","streamId","existingSenders","newSenders","newSender","shimAddTrackRemoveTrack","origGetLocalStreams","nativeStreams","_reverseStreams","_streams","newStream","replaceInternalStreamId","description","sdp","internalId","externalStream","internalStream","replace","RegExp","RTCSessionDescription","replaceExternalStreamId","signalingState","t","alreadyExists","oldStream","method","nativeMethod","methodObj","args","desc","origSetLocalDescription","setLocalDescription","origLocalDescription","getOwnPropertyDescriptor","streamid","shimPeerConnection","webkitRTCPeerConnection","RTCIceCandidate","fixNegotiationNeeded","getConfiguration","sdpSemantics","getSourceId","getDisplayMedia","sourceId","widthSpecified","width","heightSpecified","height","frameRateSpecified","frameRate","chromeMediaSource","chromeMediaSourceId","maxFrameRate","maxWidth","maxHeight","error","utils.deprecated","nativeGetUserMedia","getSettings","nativeGetSettings","applyConstraints","nativeApplyConstraints","RTCTrackEvent","mozRTCPeerConnection","modernStatsTypes","inboundrtp","outboundrtp","candidatepair","nativeGetStats","shimSenderGetStats","shimReceiverGetStats","shimRemoveStream","shimRTCDataChannel","DataChannel","RTCDataChannel","shimAddTransceiver","origAddTransceiver","addTransceiver","setParametersPromises","initParameters","shouldPerformCheck","sendEncodings","encodingParam","test","rid","TypeError","parseFloat","scaleResolutionDownBy","RangeError","maxFramerate","params","getParameters","encodings","setParameters","catch","shimGetParameters","origGetParameters","shimCreateOffer","origCreateOffer","createOffer","all","finally","shimCreateAnswer","origCreateAnswer","createAnswer","preferredMediaSource","code","mediaSource","shimLocalStreamsAPI","_localStreams","_addTrack","tracks","shimRemoteStreamsAPI","getRemoteStreams","_remoteStreams","_onaddstream","_onaddstreampoly","shimCallbacksAPI","addIceCandidate","successCallback","failureCallback","promise","withCallback","candidate","_getUserMedia","shimConstraints","errcb","utils.compactObject","shimRTCIceServerUrls","OrigPeerConnection","pcConfig","pcConstraints","iceServers","newIceServers","server","hasOwnProperty","urls","url","generateCertificate","shimTrackEventTransceiver","shimCreateOfferLegacy","offerOptions","offerToReceiveAudio","audioTransceiver","getTransceivers","direction","setDirection","offerToReceiveVideo","videoTransceiver","shimAudioContext","AudioContext","webkitAudioContext","SDPUtils","Math","random","substr","localCName","generateIdentifier","splitLines","blob","trim","split","line","splitSections","part","getDescription","sections","getMediaSections","shift","matchPrefix","parseCandidate","parts","substring","foundation","protocol","priority","ip","address","port","relatedAddress","relatedPort","tcpType","ufrag","usernameFragment","writeCandidate","join","parseIceOptions","parseRtpMap","parsed","payloadType","clockRate","channels","numChannels","writeRtpMap","codec","pt","preferredPayloadType","parseExtmap","uri","writeExtmap","headerExtension","preferredId","parseFmtp","kv","j","writeFmtp","parameters","param","parseRtcpFb","parameter","writeRtcpFb","lines","rtcpFeedback","fb","parseSsrcMedia","sp","ssrc","colon","parseSsrcGroup","semantics","ssrcs","getMid","mediaSection","mid","parseFingerprint","algorithm","getDtlsParameters","sessionpart","role","fingerprints","writeDtlsParameters","setupType","fp","parseCryptoLine","tag","cryptoSuite","keyParams","sessionParams","writeCryptoLine","writeCryptoKeyParams","parseCryptoKeyParams","keyMethod","keySalt","lifeTime","mkiValue","mkiLength","getCryptoParameters","getIceParameters","pwd","password","writeIceParameters","iceLite","parseRtpParameters","codecs","headerExtensions","fecMechanisms","rtcp","mline","rtpmapline","fmtps","writeRtpDescription","caps","maxptime","extension","parseRtpEncodingParameters","encodingParameters","hasRed","hasUlpfec","primarySsrc","secondarySsrc","flows","apt","encParam","codecPayloadType","rtx","fec","mechanism","bandwidth","maxBitrate","parseRtcpParameters","rtcpParameters","remoteSsrc","cname","rsize","reducedSize","compound","mux","writeRtcpParameters","parseMsid","spec","planB","msidParts","parseSctpDescription","parseMLine","maxSizeLine","maxMessageSize","isNaN","sctpPort","fmt","sctpMapLines","writeSctpDescription","media","sctp","output","generateSessionId","writeSessionBoilerplate","sessId","sessVer","sessUser","sessionId","getDirection","getKind","isRejected","parseOLine","username","sessionVersion","netType","addressType","isValidSDP","module","shimRTCIceCandidate","NativeRTCIceCandidate","nativeCandidate","parsedCandidate","augmentedCandidate","toJSON","sdpMid","sdpMLineIndex","writable","shimMaxMessageSize","_sctp","sctpInDescription","mLine","getRemoteFirefoxVersion","getCanSendMaxMessageSize","remoteIsFirefox","canSendMaxMessageSize","browser","getMaxMessageSize","isFirefox","canSendMMS","remoteMMS","Number","POSITIVE_INFINITY","shimSendThrowTypeError","wrapDcSend","dc","origDataChannelSend","send","byteLength","readyState","origCreateDataChannel","createDataChannel","dataChannel","channel","shimConnectionState","completed","checking","iceConnectionState","_onconnectionstatechange","origMethod","_connectionstatechangepoly","_lastConnectionState","connectionState","newEvent","removeExtmapAllowMixed","nativeSRD","shimAddIceCandidateNullOrEmpty","nativeAddIceCandidate","shimParameterlessSetLocalDescription","nativeSetLocalDescription","adapter","shimChrome","shimFirefox","shimSafari","mozGetUserMedia","userAgent","isSecureContext","RTCIceGatherer","supportsUnifiedPlan","RTCRtpTransceiver","utils.detectBrowser","commonShim","utils.extractVersion","utils.disableLog","utils.disableWarnings","chromeShim","chromeShim.shimPeerConnection","browserShim","commonShim.shimAddIceCandidateNullOrEmpty","commonShim.shimParameterlessSetLocalDescription","chromeShim.shimGetUserMedia","chromeShim.shimMediaStream","chromeShim.shimOnTrack","chromeShim.shimAddTrackRemoveTrack","chromeShim.shimGetSendersWithDtmf","chromeShim.shimGetStats","chromeShim.shimSenderReceiverGetStats","chromeShim.fixNegotiationNeeded","commonShim.shimRTCIceCandidate","commonShim.shimConnectionState","commonShim.shimMaxMessageSize","commonShim.shimSendThrowTypeError","commonShim.removeExtmapAllowMixed","firefoxShim","firefoxShim.shimPeerConnection","firefoxShim.shimGetUserMedia","firefoxShim.shimOnTrack","firefoxShim.shimRemoveStream","firefoxShim.shimSenderGetStats","firefoxShim.shimReceiverGetStats","firefoxShim.shimRTCDataChannel","firefoxShim.shimAddTransceiver","firefoxShim.shimGetParameters","firefoxShim.shimCreateOffer","firefoxShim.shimCreateAnswer","safariShim","safariShim.shimRTCIceServerUrls","safariShim.shimCreateOfferLegacy","safariShim.shimCallbacksAPI","safariShim.shimLocalStreamsAPI","safariShim.shimRemoteStreamsAPI","safariShim.shimTrackEventTransceiver","safariShim.shimGetUserMedia","safariShim.shimAudioContext","adapterFactory","RecordRTC","mediaStream","config","RecordRTCConfiguration","self","initRecorder","initCallback","Recorder","GetRecorderType","mediaRecorder","record","setState","disableLogs","constructor","stopRecording","state","resumeRecording","setTimeout","_callback","warningLog","__blob","bytesToSize","URL","createObjectURL","autoWriteToDisk","getDataURL","dataURL","DiskStorage","Store","readFile","_blob","postMessage","FileReaderSync","readAsDataURL","_mediaRecorder","Worker","reader","FileReader","onload","webWorker","_function","Blob","worker","revokeObjectURL","processInWebWorker","onmessage","handleRecordingDuration","counter","recordingDuration","onRecordingStopped","onStateChanged","WARNING","returnObject","startRecording","config2","clearRecordedData","pauseRecording","pause","resume","setRecordingDuration","getBlob","toURL","getInternalRecorder","save","fileName","invokeSaveAsDialog","getFromDisk","setAdvertisementArray","arrayOfWebPImages","advertisement","duration","image","bufferSize","sampleRate","buffer","reset","getState","destroy","disableLogsCache","Storage","AudioContextConstructor","close","prop","recorderType","WhammyRecorder","CanvasRecorder","WebAssemblyRecorder","GifRecorder","StereoAudioRecorder","MediaStreamRecorder","MediaRecorder","mimeType","bitsPerSecond","recorder","isChrome","isEdge","isOpera","ReadableStream","isMediaRecorderCompatible","isTypeSupported","MultiStreamRecorder","isSafari","MRecordRTC","_mediaStream","mediaType","gif","audioRecorder","numberOfAudioChannels","timeSlice","onTimeStamp","videoTrack","videoRecorder","canvas","frameInterval","workerPath","webAssemblyPath","bitrate","isSingleRecorder","gifRecorder","quality","blobURL","callback00","webkitURL","_audioDataURL","_videoDataURL","writeToDisk","Fetch","_type","audioDataURL","videoDataURL","gifDataURL","audioBlob","videoBlob","gifBlob","that","global","documentElement","captureStream","mozCaptureStream","getContext","play","drawImage","toDataURL","HTMLVideoElement","location","href","hash","screen","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","lastTime","currTime","Date","getTime","timeToCall","cancelAnimationFrame","webkitCancelAnimationFrame","mozCancelAnimationFrame","msCancelAnimationFrame","clearTimeout","mozAudioContext","msSaveBlob","msSaveOrOpenBlob","opera","isElectron","bytes","floor","pow","toPrecision","file","fileExtension","splitted","fileFullName","round","hyperlink","download","body","click","MouseEvent","view","bubbles","cancelable","process","versions","electron","setSrcObject","srcObject","mozSrcObject","getSeekableBlob","inputBlob","EBML","Reader","decoder","Decoder","tools","fileReader","decode","read","refinedMetadataBuf","makeMetadataSeekable","metadatas","cues","metadataSize","newBlob","readAsArrayBuffer","verOffset","ix","nAgt","fullVersion","appVersion","majorVersion","arrayOfBlobs","updateTimeStamp","timestamps","getMimeType","secondObject","clearRecordedDataCB","getArrayOfBlobs","allStates","recorderHints","canRecordMimeType","ondataavailable","recordingCallback","getNativeBlob","onstart","onpause","onresume","onstop","onerror","looper","manuallyStopped","timeslice","start","getAllStates","checkForInactiveTracks","active","ended","isMediaStreamActive","jsAudioNode","leftchannel","rightchannel","recording","recordingLength","desiredSampRate","mergeLeftRightBuffers","mergeAudioBuffers","interleaved","leftBuffers","rightBuffers","internalInterleavedLength","interpolateArray","newSampleRate","oldSampleRate","fitCount","newData","springFactor","tmp","before","toFixed","after","ceil","atPoint","linearInterpolate","mergeBuffers","channelBuffer","rLength","Float64Array","offset","lng","writeUTFBytes","string","setUint8","charCodeAt","leftChannel","rightChannel","inputIndex","interleave","interleavedLength","ArrayBuffer","DataView","setUint32","setUint16","setInt16","noWorker","workerURL","terminate","resetVariables","isAudioProcessStarted","isPaused","audioInput","createMediaStreamSource","legalBufferValues","createJavaScriptNode","createScriptProcessor","connect","intervalsBasedBuffers","left","right","onaudioprocess","disconnect","onAudioProcessStarted","inputBuffer","getChannelData","chLeft","Float32Array","chRight","createMediaStreamDestination","destination","htmlElement","html2canvas","isCanvasSupportsStreamCapturing","item","globalCanvas","mediaStreamRecorder","isRecording","_isChrome","chrome","chromeVersion","matchArray","useWhammyRecorder","HTMLCanvasElement","CanvasRenderingContext2D","canvasMediaStream","webkitCaptureStream","mdStream","whammy","frames","drawCanvasFrame","getWebPImages","nodeName","framesLength","frame","framesRemaining","onEncodingCallback","webp","compile","isPausedRecording","newCanvas","grabMouse","showMousePointer","onrendered","Whammy","Video","drawFrames","paused","isStopDrawing","dropBlackFrames","_frames","_framesToCheck","_pixTolerance","_frameTolerance","localCanvas","o","context2d","resultFrames","checkUntilNotBlack","endCheckFrame","sampleColor","maxColorDifference","sqrt","pixTolerance","frameTolerance","doNotCheckNext","functionToLoop","loop","matchPixCount","endPixCheck","maxPixCount","finishImage","Image","imageData","getImageData","pix","currentColor","g","src","cloneNode","onloadedmetadata","muted","_this","WhammyVideo","whammyInWebWorker","getClusterData","clusterTimecode","clusterCounter","clusterFrames","flags","keyframe","invisible","lacing","discardable","trackNum","timecode","String","fromCharCode","makeSimpleBlock","numToBuffer","num","Uint8Array","reverse","bitsToBuffer","bits","generateEBML","json","ebml","len","zeroes","sizeToString","padded","getStrLength","unpadded","parseRIFF","chunks","webm","info","checkFrames","frameNumber","clusterDuration","cluster","riff","VP8","RIFF","WEBP","frameStart","parseWebP","atob","indexedDB","open","db","dbName","request","onsuccess","setVersion","createObjectStore","putInDB","onupgradeneeded","dataBase","dataStoreName","transaction","getFromStore","portionName","objectStore","put","GIFEncoder","script","isHTMLObject","isLoadedMetaData","offsetWidth","offsetHeight","gifEncoder","setRepeat","setDelay","setQuality","onGifRecordingStarted","lastAnimationFrame","drawVideoFrame","time","clearedRecordedData","lastFrameTime","onGifPreview","addFrame","bin","autoplay","playsInline","MultiStreamsMixer","arrayOfMediaStreams","elementClass","videos","isStopDrawingFrames","opacity","position","zIndex","top","className","useGainNode","drawVideosToCanvas","videosLength","fullcanvas","remaining","x","y","onRender","getVideo","volume","resetVideoStreams","startDrawingFrames","appendStreams","audioSource","audioContext","audioDestination","releaseStreams","gainNode","audioSources","source","clearRect","getMixedStream","mixedVideoStream","capturedStream","videoStream","getMixedVideoStream","mixedAudioStream","createGain","gain","audioTracksLength","getMixedAudioStream","mixer","previewStream","addStreams","getMixer","finished","cameraStream","controller","cvs","first","onplaying","frameTimeout","cameraTimer","setInterval","clearInterval","onVideoProcessStarted","_controlledReadableStream","enqueue","fetch","arrayBuffer","timebaseDen","realtime","pipeTo","WritableStream","write","arrayOfBuffers","RecordRTCPromisesHandler","recordRTC","Webcam","webcamElement","canvasElement","snapSoundElement","_webcamElement","_facingMode","_webcamList","_streamList","_selectedDeviceId","_canvasElement","_snapSoundElement","webcamList","webcamCount","selectedDeviceId","getVideoInputs","mediaDevice","getMediaConstraints","videoConstraints","selectCamera","webcam","flip","transform","async","startStream","webcams","snap","scrollHeight","scrollWidth","translate","scale","videoRecorded","videoRecordedURL","getElementById","captureCamera","camera","onErrorGetAccessCamera","stopRecordingCallback","recordedBlob","display","backgroundColor","picture","outros","userAgentSplitToArr","detectOpenWebOnLineApp"],"mappings":"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"}