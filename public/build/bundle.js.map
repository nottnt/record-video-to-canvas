{"version":3,"file":"bundle.js","sources":["../../node_modules/svelte/internal/index.mjs","../../node_modules/webrtc-adapter/src/js/utils.js","../../node_modules/webrtc-adapter/src/js/chrome/getusermedia.js","../../node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js","../../node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js","../../node_modules/webrtc-adapter/src/js/firefox/getusermedia.js","../../node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js","../../node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js","../../node_modules/webrtc-adapter/src/js/safari/safari_shim.js","../../node_modules/sdp/sdp.js","../../node_modules/webrtc-adapter/src/js/common_shim.js","../../node_modules/webrtc-adapter/src/js/adapter_core.js","../../node_modules/webrtc-adapter/src/js/adapter_factory.js","../../src/RecordRTC.js","../../src/VideoRecord.svelte","../../src/App.svelte","../../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration();\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    select.selectedIndex = -1; // no option should be selected\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, bubbles = false) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor() {\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = element(target.nodeName);\n            this.t = target;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes) {\n        super();\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction escape_attribute_value(value) {\n    return typeof value === 'string' ? escape(value) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(parent_component ? parent_component.$$.context : context || []),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = on_mount.map(run).filter(is_function);\n            if (on_destroy) {\n                on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(parent_component ? parent_component.$$.context : options.context || []),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.42.6' }, detail), true));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, identity, init, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, src_url_equal, start_hydrating, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n'use strict';\n\nlet logDisabled_ = true;\nlet deprecationWarnings_ = true;\n\n/**\n * Extract browser version out of the provided user agent string.\n *\n * @param {!string} uastring userAgent string.\n * @param {!string} expr Regular expression used as match criteria.\n * @param {!number} pos position in the version string to be returned.\n * @return {!number} browser version.\n */\nexport function extractVersion(uastring, expr, pos) {\n  const match = uastring.match(expr);\n  return match && match.length >= pos && parseInt(match[pos], 10);\n}\n\n// Wraps the peerconnection event eventNameToWrap in a function\n// which returns the modified event object (or false to prevent\n// the event).\nexport function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  const proto = window.RTCPeerConnection.prototype;\n  const nativeAddEventListener = proto.addEventListener;\n  proto.addEventListener = function(nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap) {\n      return nativeAddEventListener.apply(this, arguments);\n    }\n    const wrappedCallback = (e) => {\n      const modifiedEvent = wrapper(e);\n      if (modifiedEvent) {\n        if (cb.handleEvent) {\n          cb.handleEvent(modifiedEvent);\n        } else {\n          cb(modifiedEvent);\n        }\n      }\n    };\n    this._eventMap = this._eventMap || {};\n    if (!this._eventMap[eventNameToWrap]) {\n      this._eventMap[eventNameToWrap] = new Map();\n    }\n    this._eventMap[eventNameToWrap].set(cb, wrappedCallback);\n    return nativeAddEventListener.apply(this, [nativeEventName,\n      wrappedCallback]);\n  };\n\n  const nativeRemoveEventListener = proto.removeEventListener;\n  proto.removeEventListener = function(nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap || !this._eventMap\n        || !this._eventMap[eventNameToWrap]) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n    if (!this._eventMap[eventNameToWrap].has(cb)) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n    const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);\n    this._eventMap[eventNameToWrap].delete(cb);\n    if (this._eventMap[eventNameToWrap].size === 0) {\n      delete this._eventMap[eventNameToWrap];\n    }\n    if (Object.keys(this._eventMap).length === 0) {\n      delete this._eventMap;\n    }\n    return nativeRemoveEventListener.apply(this, [nativeEventName,\n      unwrappedCb]);\n  };\n\n  Object.defineProperty(proto, 'on' + eventNameToWrap, {\n    get() {\n      return this['_on' + eventNameToWrap];\n    },\n    set(cb) {\n      if (this['_on' + eventNameToWrap]) {\n        this.removeEventListener(eventNameToWrap,\n            this['_on' + eventNameToWrap]);\n        delete this['_on' + eventNameToWrap];\n      }\n      if (cb) {\n        this.addEventListener(eventNameToWrap,\n            this['_on' + eventNameToWrap] = cb);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n}\n\nexport function disableLog(bool) {\n  if (typeof bool !== 'boolean') {\n    return new Error('Argument type: ' + typeof bool +\n        '. Please use a boolean.');\n  }\n  logDisabled_ = bool;\n  return (bool) ? 'adapter.js logging disabled' :\n      'adapter.js logging enabled';\n}\n\n/**\n * Disable or enable deprecation warnings\n * @param {!boolean} bool set to true to disable warnings.\n */\nexport function disableWarnings(bool) {\n  if (typeof bool !== 'boolean') {\n    return new Error('Argument type: ' + typeof bool +\n        '. Please use a boolean.');\n  }\n  deprecationWarnings_ = !bool;\n  return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');\n}\n\nexport function log() {\n  if (typeof window === 'object') {\n    if (logDisabled_) {\n      return;\n    }\n    if (typeof console !== 'undefined' && typeof console.log === 'function') {\n      console.log.apply(console, arguments);\n    }\n  }\n}\n\n/**\n * Shows a deprecation warning suggesting the modern and spec-compatible API.\n */\nexport function deprecated(oldMethod, newMethod) {\n  if (!deprecationWarnings_) {\n    return;\n  }\n  console.warn(oldMethod + ' is deprecated, please use ' + newMethod +\n      ' instead.');\n}\n\n/**\n * Browser detector.\n *\n * @return {object} result containing browser and version\n *     properties.\n */\nexport function detectBrowser(window) {\n  // Returned result object.\n  const result = {browser: null, version: null};\n\n  // Fail early if it's not a browser\n  if (typeof window === 'undefined' || !window.navigator) {\n    result.browser = 'Not a browser.';\n    return result;\n  }\n\n  const {navigator} = window;\n\n  if (navigator.mozGetUserMedia) { // Firefox.\n    result.browser = 'firefox';\n    result.version = extractVersion(navigator.userAgent,\n        /Firefox\\/(\\d+)\\./, 1);\n  } else if (navigator.webkitGetUserMedia ||\n      (window.isSecureContext === false && window.webkitRTCPeerConnection &&\n       !window.RTCIceGatherer)) {\n    // Chrome, Chromium, Webview, Opera.\n    // Version matches Chrome/WebRTC version.\n    // Chrome 74 removed webkitGetUserMedia on http as well so we need the\n    // more complicated fallback to webkitRTCPeerConnection.\n    result.browser = 'chrome';\n    result.version = extractVersion(navigator.userAgent,\n        /Chrom(e|ium)\\/(\\d+)\\./, 2);\n  } else if (window.RTCPeerConnection &&\n      navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) { // Safari.\n    result.browser = 'safari';\n    result.version = extractVersion(navigator.userAgent,\n        /AppleWebKit\\/(\\d+)\\./, 1);\n    result.supportsUnifiedPlan = window.RTCRtpTransceiver &&\n        'currentDirection' in window.RTCRtpTransceiver.prototype;\n  } else { // Default fallthrough: not supported.\n    result.browser = 'Not a supported browser.';\n    return result;\n  }\n\n  return result;\n}\n\n/**\n * Checks if something is an object.\n *\n * @param {*} val The something you want to check.\n * @return true if val is an object, false otherwise.\n */\nfunction isObject(val) {\n  return Object.prototype.toString.call(val) === '[object Object]';\n}\n\n/**\n * Remove all empty objects and undefined values\n * from a nested object -- an enhanced and vanilla version\n * of Lodash's `compact`.\n */\nexport function compactObject(data) {\n  if (!isObject(data)) {\n    return data;\n  }\n\n  return Object.keys(data).reduce(function(accumulator, key) {\n    const isObj = isObject(data[key]);\n    const value = isObj ? compactObject(data[key]) : data[key];\n    const isEmptyObject = isObj && !Object.keys(value).length;\n    if (value === undefined || isEmptyObject) {\n      return accumulator;\n    }\n    return Object.assign(accumulator, {[key]: value});\n  }, {});\n}\n\n/* iterates the stats graph recursively. */\nexport function walkStats(stats, base, resultSet) {\n  if (!base || resultSet.has(base.id)) {\n    return;\n  }\n  resultSet.set(base.id, base);\n  Object.keys(base).forEach(name => {\n    if (name.endsWith('Id')) {\n      walkStats(stats, stats.get(base[name]), resultSet);\n    } else if (name.endsWith('Ids')) {\n      base[name].forEach(id => {\n        walkStats(stats, stats.get(id), resultSet);\n      });\n    }\n  });\n}\n\n/* filter getStats for a sender/receiver track. */\nexport function filterStats(result, track, outbound) {\n  const streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';\n  const filteredResult = new Map();\n  if (track === null) {\n    return filteredResult;\n  }\n  const trackStats = [];\n  result.forEach(value => {\n    if (value.type === 'track' &&\n        value.trackIdentifier === track.id) {\n      trackStats.push(value);\n    }\n  });\n  trackStats.forEach(trackStat => {\n    result.forEach(stats => {\n      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\n        walkStats(result, stats, filteredResult);\n      }\n    });\n  });\n  return filteredResult;\n}\n\n","/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\nimport * as utils from '../utils.js';\nconst logging = utils.log;\n\nexport function shimGetUserMedia(window, browserDetails) {\n  const navigator = window && window.navigator;\n\n  if (!navigator.mediaDevices) {\n    return;\n  }\n\n  const constraintsToChrome_ = function(c) {\n    if (typeof c !== 'object' || c.mandatory || c.optional) {\n      return c;\n    }\n    const cc = {};\n    Object.keys(c).forEach(key => {\n      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n        return;\n      }\n      const r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};\n      if (r.exact !== undefined && typeof r.exact === 'number') {\n        r.min = r.max = r.exact;\n      }\n      const oldname_ = function(prefix, name) {\n        if (prefix) {\n          return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n        }\n        return (name === 'deviceId') ? 'sourceId' : name;\n      };\n      if (r.ideal !== undefined) {\n        cc.optional = cc.optional || [];\n        let oc = {};\n        if (typeof r.ideal === 'number') {\n          oc[oldname_('min', key)] = r.ideal;\n          cc.optional.push(oc);\n          oc = {};\n          oc[oldname_('max', key)] = r.ideal;\n          cc.optional.push(oc);\n        } else {\n          oc[oldname_('', key)] = r.ideal;\n          cc.optional.push(oc);\n        }\n      }\n      if (r.exact !== undefined && typeof r.exact !== 'number') {\n        cc.mandatory = cc.mandatory || {};\n        cc.mandatory[oldname_('', key)] = r.exact;\n      } else {\n        ['min', 'max'].forEach(mix => {\n          if (r[mix] !== undefined) {\n            cc.mandatory = cc.mandatory || {};\n            cc.mandatory[oldname_(mix, key)] = r[mix];\n          }\n        });\n      }\n    });\n    if (c.advanced) {\n      cc.optional = (cc.optional || []).concat(c.advanced);\n    }\n    return cc;\n  };\n\n  const shimConstraints_ = function(constraints, func) {\n    if (browserDetails.version >= 61) {\n      return func(constraints);\n    }\n    constraints = JSON.parse(JSON.stringify(constraints));\n    if (constraints && typeof constraints.audio === 'object') {\n      const remap = function(obj, a, b) {\n        if (a in obj && !(b in obj)) {\n          obj[b] = obj[a];\n          delete obj[a];\n        }\n      };\n      constraints = JSON.parse(JSON.stringify(constraints));\n      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');\n      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');\n      constraints.audio = constraintsToChrome_(constraints.audio);\n    }\n    if (constraints && typeof constraints.video === 'object') {\n      // Shim facingMode for mobile & surface pro.\n      let face = constraints.video.facingMode;\n      face = face && ((typeof face === 'object') ? face : {ideal: face});\n      const getSupportedFacingModeLies = browserDetails.version < 66;\n\n      if ((face && (face.exact === 'user' || face.exact === 'environment' ||\n                    face.ideal === 'user' || face.ideal === 'environment')) &&\n          !(navigator.mediaDevices.getSupportedConstraints &&\n            navigator.mediaDevices.getSupportedConstraints().facingMode &&\n            !getSupportedFacingModeLies)) {\n        delete constraints.video.facingMode;\n        let matches;\n        if (face.exact === 'environment' || face.ideal === 'environment') {\n          matches = ['back', 'rear'];\n        } else if (face.exact === 'user' || face.ideal === 'user') {\n          matches = ['front'];\n        }\n        if (matches) {\n          // Look for matches in label, or use last cam for back (typical).\n          return navigator.mediaDevices.enumerateDevices()\n          .then(devices => {\n            devices = devices.filter(d => d.kind === 'videoinput');\n            let dev = devices.find(d => matches.some(match =>\n              d.label.toLowerCase().includes(match)));\n            if (!dev && devices.length && matches.includes('back')) {\n              dev = devices[devices.length - 1]; // more likely the back cam\n            }\n            if (dev) {\n              constraints.video.deviceId = face.exact ? {exact: dev.deviceId} :\n                                                        {ideal: dev.deviceId};\n            }\n            constraints.video = constraintsToChrome_(constraints.video);\n            logging('chrome: ' + JSON.stringify(constraints));\n            return func(constraints);\n          });\n        }\n      }\n      constraints.video = constraintsToChrome_(constraints.video);\n    }\n    logging('chrome: ' + JSON.stringify(constraints));\n    return func(constraints);\n  };\n\n  const shimError_ = function(e) {\n    if (browserDetails.version >= 64) {\n      return e;\n    }\n    return {\n      name: {\n        PermissionDeniedError: 'NotAllowedError',\n        PermissionDismissedError: 'NotAllowedError',\n        InvalidStateError: 'NotAllowedError',\n        DevicesNotFoundError: 'NotFoundError',\n        ConstraintNotSatisfiedError: 'OverconstrainedError',\n        TrackStartError: 'NotReadableError',\n        MediaDeviceFailedDueToShutdown: 'NotAllowedError',\n        MediaDeviceKillSwitchOn: 'NotAllowedError',\n        TabCaptureError: 'AbortError',\n        ScreenCaptureError: 'AbortError',\n        DeviceCaptureError: 'AbortError'\n      }[e.name] || e.name,\n      message: e.message,\n      constraint: e.constraint || e.constraintName,\n      toString() {\n        return this.name + (this.message && ': ') + this.message;\n      }\n    };\n  };\n\n  const getUserMedia_ = function(constraints, onSuccess, onError) {\n    shimConstraints_(constraints, c => {\n      navigator.webkitGetUserMedia(c, onSuccess, e => {\n        if (onError) {\n          onError(shimError_(e));\n        }\n      });\n    });\n  };\n  navigator.getUserMedia = getUserMedia_.bind(navigator);\n\n  // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\n  // function which returns a Promise, it does not accept spec-style\n  // constraints.\n  if (navigator.mediaDevices.getUserMedia) {\n    const origGetUserMedia = navigator.mediaDevices.getUserMedia.\n        bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function(cs) {\n      return shimConstraints_(cs, c => origGetUserMedia(c).then(stream => {\n        if (c.audio && !stream.getAudioTracks().length ||\n            c.video && !stream.getVideoTracks().length) {\n          stream.getTracks().forEach(track => {\n            track.stop();\n          });\n          throw new DOMException('', 'NotFoundError');\n        }\n        return stream;\n      }, e => Promise.reject(shimError_(e))));\n    };\n  }\n}\n","/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n'use strict';\nimport * as utils from '../utils.js';\n\nexport {shimGetUserMedia} from './getusermedia';\nexport {shimGetDisplayMedia} from './getdisplaymedia';\n\nexport function shimMediaStream(window) {\n  window.MediaStream = window.MediaStream || window.webkitMediaStream;\n}\n\nexport function shimOnTrack(window) {\n  if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\n      window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n      get() {\n        return this._ontrack;\n      },\n      set(f) {\n        if (this._ontrack) {\n          this.removeEventListener('track', this._ontrack);\n        }\n        this.addEventListener('track', this._ontrack = f);\n      },\n      enumerable: true,\n      configurable: true\n    });\n    const origSetRemoteDescription =\n        window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription =\n      function setRemoteDescription() {\n        if (!this._ontrackpoly) {\n          this._ontrackpoly = (e) => {\n            // onaddstream does not fire when a track is added to an existing\n            // stream. But stream.onaddtrack is implemented so we use that.\n            e.stream.addEventListener('addtrack', te => {\n              let receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = this.getReceivers()\n                  .find(r => r.track && r.track.id === te.track.id);\n              } else {\n                receiver = {track: te.track};\n              }\n\n              const event = new Event('track');\n              event.track = te.track;\n              event.receiver = receiver;\n              event.transceiver = {receiver};\n              event.streams = [e.stream];\n              this.dispatchEvent(event);\n            });\n            e.stream.getTracks().forEach(track => {\n              let receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = this.getReceivers()\n                  .find(r => r.track && r.track.id === track.id);\n              } else {\n                receiver = {track};\n              }\n              const event = new Event('track');\n              event.track = track;\n              event.receiver = receiver;\n              event.transceiver = {receiver};\n              event.streams = [e.stream];\n              this.dispatchEvent(event);\n            });\n          };\n          this.addEventListener('addstream', this._ontrackpoly);\n        }\n        return origSetRemoteDescription.apply(this, arguments);\n      };\n  } else {\n    // even if RTCRtpTransceiver is in window, it is only used and\n    // emitted in unified-plan. Unfortunately this means we need\n    // to unconditionally wrap the event.\n    utils.wrapPeerConnectionEvent(window, 'track', e => {\n      if (!e.transceiver) {\n        Object.defineProperty(e, 'transceiver',\n          {value: {receiver: e.receiver}});\n      }\n      return e;\n    });\n  }\n}\n\nexport function shimGetSendersWithDtmf(window) {\n  // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n  if (typeof window === 'object' && window.RTCPeerConnection &&\n      !('getSenders' in window.RTCPeerConnection.prototype) &&\n      'createDTMFSender' in window.RTCPeerConnection.prototype) {\n    const shimSenderWithDtmf = function(pc, track) {\n      return {\n        track,\n        get dtmf() {\n          if (this._dtmf === undefined) {\n            if (track.kind === 'audio') {\n              this._dtmf = pc.createDTMFSender(track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        },\n        _pc: pc\n      };\n    };\n\n    // augment addTrack when getSenders is not available.\n    if (!window.RTCPeerConnection.prototype.getSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        this._senders = this._senders || [];\n        return this._senders.slice(); // return a copy of the internal state.\n      };\n      const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n      window.RTCPeerConnection.prototype.addTrack =\n        function addTrack(track, stream) {\n          let sender = origAddTrack.apply(this, arguments);\n          if (!sender) {\n            sender = shimSenderWithDtmf(this, track);\n            this._senders.push(sender);\n          }\n          return sender;\n        };\n\n      const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n      window.RTCPeerConnection.prototype.removeTrack =\n        function removeTrack(sender) {\n          origRemoveTrack.apply(this, arguments);\n          const idx = this._senders.indexOf(sender);\n          if (idx !== -1) {\n            this._senders.splice(idx, 1);\n          }\n        };\n    }\n    const origAddStream = window.RTCPeerConnection.prototype.addStream;\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      this._senders = this._senders || [];\n      origAddStream.apply(this, [stream]);\n      stream.getTracks().forEach(track => {\n        this._senders.push(shimSenderWithDtmf(this, track));\n      });\n    };\n\n    const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n    window.RTCPeerConnection.prototype.removeStream =\n      function removeStream(stream) {\n        this._senders = this._senders || [];\n        origRemoveStream.apply(this, [stream]);\n\n        stream.getTracks().forEach(track => {\n          const sender = this._senders.find(s => s.track === track);\n          if (sender) { // remove sender\n            this._senders.splice(this._senders.indexOf(sender), 1);\n          }\n        });\n      };\n  } else if (typeof window === 'object' && window.RTCPeerConnection &&\n             'getSenders' in window.RTCPeerConnection.prototype &&\n             'createDTMFSender' in window.RTCPeerConnection.prototype &&\n             window.RTCRtpSender &&\n             !('dtmf' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n\n    Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n      get() {\n        if (this._dtmf === undefined) {\n          if (this.track.kind === 'audio') {\n            this._dtmf = this._pc.createDTMFSender(this.track);\n          } else {\n            this._dtmf = null;\n          }\n        }\n        return this._dtmf;\n      }\n    });\n  }\n}\n\nexport function shimGetStats(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    const [selector, onSucc, onErr] = arguments;\n\n    // If selector is a function then we are in the old style stats so just\n    // pass back the original getStats format to avoid breaking old users.\n    if (arguments.length > 0 && typeof selector === 'function') {\n      return origGetStats.apply(this, arguments);\n    }\n\n    // When spec-style getStats is supported, return those when called with\n    // either no arguments or the selector argument is null.\n    if (origGetStats.length === 0 && (arguments.length === 0 ||\n        typeof selector !== 'function')) {\n      return origGetStats.apply(this, []);\n    }\n\n    const fixChromeStats_ = function(response) {\n      const standardReport = {};\n      const reports = response.result();\n      reports.forEach(report => {\n        const standardStats = {\n          id: report.id,\n          timestamp: report.timestamp,\n          type: {\n            localcandidate: 'local-candidate',\n            remotecandidate: 'remote-candidate'\n          }[report.type] || report.type\n        };\n        report.names().forEach(name => {\n          standardStats[name] = report.stat(name);\n        });\n        standardReport[standardStats.id] = standardStats;\n      });\n\n      return standardReport;\n    };\n\n    // shim getStats with maplike support\n    const makeMapStats = function(stats) {\n      return new Map(Object.keys(stats).map(key => [key, stats[key]]));\n    };\n\n    if (arguments.length >= 2) {\n      const successCallbackWrapper_ = function(response) {\n        onSucc(makeMapStats(fixChromeStats_(response)));\n      };\n\n      return origGetStats.apply(this, [successCallbackWrapper_,\n        selector]);\n    }\n\n    // promise-support\n    return new Promise((resolve, reject) => {\n      origGetStats.apply(this, [\n        function(response) {\n          resolve(makeMapStats(fixChromeStats_(response)));\n        }, reject]);\n    }).then(onSucc, onErr);\n  };\n}\n\nexport function shimSenderReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection &&\n      window.RTCRtpSender && window.RTCRtpReceiver)) {\n    return;\n  }\n\n  // shim sender stats.\n  if (!('getStats' in window.RTCRtpSender.prototype)) {\n    const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n      window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n        const senders = origGetSenders.apply(this, []);\n        senders.forEach(sender => sender._pc = this);\n        return senders;\n      };\n    }\n\n    const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n      window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n        const sender = origAddTrack.apply(this, arguments);\n        sender._pc = this;\n        return sender;\n      };\n    }\n    window.RTCRtpSender.prototype.getStats = function getStats() {\n      const sender = this;\n      return this._pc.getStats().then(result =>\n        /* Note: this will include stats of all senders that\n         *   send a track with the same id as sender.track as\n         *   it is not possible to identify the RTCRtpSender.\n         */\n        utils.filterStats(result, sender.track, true));\n    };\n  }\n\n  // shim receiver stats.\n  if (!('getStats' in window.RTCRtpReceiver.prototype)) {\n    const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n      window.RTCPeerConnection.prototype.getReceivers =\n        function getReceivers() {\n          const receivers = origGetReceivers.apply(this, []);\n          receivers.forEach(receiver => receiver._pc = this);\n          return receivers;\n        };\n    }\n    utils.wrapPeerConnectionEvent(window, 'track', e => {\n      e.receiver._pc = e.srcElement;\n      return e;\n    });\n    window.RTCRtpReceiver.prototype.getStats = function getStats() {\n      const receiver = this;\n      return this._pc.getStats().then(result =>\n        utils.filterStats(result, receiver.track, false));\n    };\n  }\n\n  if (!('getStats' in window.RTCRtpSender.prototype &&\n      'getStats' in window.RTCRtpReceiver.prototype)) {\n    return;\n  }\n\n  // shim RTCPeerConnection.getStats(track).\n  const origGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    if (arguments.length > 0 &&\n        arguments[0] instanceof window.MediaStreamTrack) {\n      const track = arguments[0];\n      let sender;\n      let receiver;\n      let err;\n      this.getSenders().forEach(s => {\n        if (s.track === track) {\n          if (sender) {\n            err = true;\n          } else {\n            sender = s;\n          }\n        }\n      });\n      this.getReceivers().forEach(r => {\n        if (r.track === track) {\n          if (receiver) {\n            err = true;\n          } else {\n            receiver = r;\n          }\n        }\n        return r.track === track;\n      });\n      if (err || (sender && receiver)) {\n        return Promise.reject(new DOMException(\n          'There are more than one sender or receiver for the track.',\n          'InvalidAccessError'));\n      } else if (sender) {\n        return sender.getStats();\n      } else if (receiver) {\n        return receiver.getStats();\n      }\n      return Promise.reject(new DOMException(\n        'There is no sender or receiver for the track.',\n        'InvalidAccessError'));\n    }\n    return origGetStats.apply(this, arguments);\n  };\n}\n\nexport function shimAddTrackRemoveTrackWithNative(window) {\n  // shim addTrack/removeTrack with native variants in order to make\n  // the interactions with legacy getLocalStreams behave as in other browsers.\n  // Keeps a mapping stream.id => [stream, rtpsenders...]\n  window.RTCPeerConnection.prototype.getLocalStreams =\n    function getLocalStreams() {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      return Object.keys(this._shimmedLocalStreams)\n        .map(streamId => this._shimmedLocalStreams[streamId][0]);\n    };\n\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n  window.RTCPeerConnection.prototype.addTrack =\n    function addTrack(track, stream) {\n      if (!stream) {\n        return origAddTrack.apply(this, arguments);\n      }\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n      const sender = origAddTrack.apply(this, arguments);\n      if (!this._shimmedLocalStreams[stream.id]) {\n        this._shimmedLocalStreams[stream.id] = [stream, sender];\n      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n        this._shimmedLocalStreams[stream.id].push(sender);\n      }\n      return sender;\n    };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n    });\n    const existingSenders = this.getSenders();\n    origAddStream.apply(this, arguments);\n    const newSenders = this.getSenders()\n      .filter(newSender => existingSenders.indexOf(newSender) === -1);\n    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream =\n    function removeStream(stream) {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      delete this._shimmedLocalStreams[stream.id];\n      return origRemoveStream.apply(this, arguments);\n    };\n\n  const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n  window.RTCPeerConnection.prototype.removeTrack =\n    function removeTrack(sender) {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      if (sender) {\n        Object.keys(this._shimmedLocalStreams).forEach(streamId => {\n          const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n          if (idx !== -1) {\n            this._shimmedLocalStreams[streamId].splice(idx, 1);\n          }\n          if (this._shimmedLocalStreams[streamId].length === 1) {\n            delete this._shimmedLocalStreams[streamId];\n          }\n        });\n      }\n      return origRemoveTrack.apply(this, arguments);\n    };\n}\n\nexport function shimAddTrackRemoveTrack(window, browserDetails) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  // shim addTrack and removeTrack.\n  if (window.RTCPeerConnection.prototype.addTrack &&\n      browserDetails.version >= 65) {\n    return shimAddTrackRemoveTrackWithNative(window);\n  }\n\n  // also shim pc.getLocalStreams when addTrack is shimmed\n  // to return the original streams.\n  const origGetLocalStreams = window.RTCPeerConnection.prototype\n      .getLocalStreams;\n  window.RTCPeerConnection.prototype.getLocalStreams =\n    function getLocalStreams() {\n      const nativeStreams = origGetLocalStreams.apply(this);\n      this._reverseStreams = this._reverseStreams || {};\n      return nativeStreams.map(stream => this._reverseStreams[stream.id]);\n    };\n\n  const origAddStream = window.RTCPeerConnection.prototype.addStream;\n  window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n    this._streams = this._streams || {};\n    this._reverseStreams = this._reverseStreams || {};\n\n    stream.getTracks().forEach(track => {\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n    });\n    // Add identity mapping for consistency with addTrack.\n    // Unless this is being used with a stream from addTrack.\n    if (!this._reverseStreams[stream.id]) {\n      const newStream = new window.MediaStream(stream.getTracks());\n      this._streams[stream.id] = newStream;\n      this._reverseStreams[newStream.id] = stream;\n      stream = newStream;\n    }\n    origAddStream.apply(this, [stream]);\n  };\n\n  const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n  window.RTCPeerConnection.prototype.removeStream =\n    function removeStream(stream) {\n      this._streams = this._streams || {};\n      this._reverseStreams = this._reverseStreams || {};\n\n      origRemoveStream.apply(this, [(this._streams[stream.id] || stream)]);\n      delete this._reverseStreams[(this._streams[stream.id] ?\n          this._streams[stream.id].id : stream.id)];\n      delete this._streams[stream.id];\n    };\n\n  window.RTCPeerConnection.prototype.addTrack =\n    function addTrack(track, stream) {\n      if (this.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      const streams = [].slice.call(arguments, 1);\n      if (streams.length !== 1 ||\n          !streams[0].getTracks().find(t => t === track)) {\n        // this is not fully correct but all we can manage without\n        // [[associated MediaStreams]] internal slot.\n        throw new DOMException(\n          'The adapter.js addTrack polyfill only supports a single ' +\n          ' stream which is associated with the specified track.',\n          'NotSupportedError');\n      }\n\n      const alreadyExists = this.getSenders().find(s => s.track === track);\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n\n      this._streams = this._streams || {};\n      this._reverseStreams = this._reverseStreams || {};\n      const oldStream = this._streams[stream.id];\n      if (oldStream) {\n        // this is using odd Chrome behaviour, use with caution:\n        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n        // Note: we rely on the high-level addTrack/dtmf shim to\n        // create the sender with a dtmf sender.\n        oldStream.addTrack(track);\n\n        // Trigger ONN async.\n        Promise.resolve().then(() => {\n          this.dispatchEvent(new Event('negotiationneeded'));\n        });\n      } else {\n        const newStream = new window.MediaStream([track]);\n        this._streams[stream.id] = newStream;\n        this._reverseStreams[newStream.id] = stream;\n        this.addStream(newStream);\n      }\n      return this.getSenders().find(s => s.track === track);\n    };\n\n  // replace the internal stream id with the external one and\n  // vice versa.\n  function replaceInternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(internalStream.id, 'g'),\n          externalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  function replaceExternalStreamId(pc, description) {\n    let sdp = description.sdp;\n    Object.keys(pc._reverseStreams || []).forEach(internalId => {\n      const externalStream = pc._reverseStreams[internalId];\n      const internalStream = pc._streams[externalStream.id];\n      sdp = sdp.replace(new RegExp(externalStream.id, 'g'),\n          internalStream.id);\n    });\n    return new RTCSessionDescription({\n      type: description.type,\n      sdp\n    });\n  }\n  ['createOffer', 'createAnswer'].forEach(function(method) {\n    const nativeMethod = window.RTCPeerConnection.prototype[method];\n    const methodObj = {[method]() {\n      const args = arguments;\n      const isLegacyCall = arguments.length &&\n          typeof arguments[0] === 'function';\n      if (isLegacyCall) {\n        return nativeMethod.apply(this, [\n          (description) => {\n            const desc = replaceInternalStreamId(this, description);\n            args[0].apply(null, [desc]);\n          },\n          (err) => {\n            if (args[1]) {\n              args[1].apply(null, err);\n            }\n          }, arguments[2]\n        ]);\n      }\n      return nativeMethod.apply(this, arguments)\n      .then(description => replaceInternalStreamId(this, description));\n    }};\n    window.RTCPeerConnection.prototype[method] = methodObj[method];\n  });\n\n  const origSetLocalDescription =\n      window.RTCPeerConnection.prototype.setLocalDescription;\n  window.RTCPeerConnection.prototype.setLocalDescription =\n    function setLocalDescription() {\n      if (!arguments.length || !arguments[0].type) {\n        return origSetLocalDescription.apply(this, arguments);\n      }\n      arguments[0] = replaceExternalStreamId(this, arguments[0]);\n      return origSetLocalDescription.apply(this, arguments);\n    };\n\n  // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n\n  const origLocalDescription = Object.getOwnPropertyDescriptor(\n      window.RTCPeerConnection.prototype, 'localDescription');\n  Object.defineProperty(window.RTCPeerConnection.prototype,\n      'localDescription', {\n        get() {\n          const description = origLocalDescription.get.apply(this);\n          if (description.type === '') {\n            return description;\n          }\n          return replaceInternalStreamId(this, description);\n        }\n      });\n\n  window.RTCPeerConnection.prototype.removeTrack =\n    function removeTrack(sender) {\n      if (this.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      // We can not yet check for sender instanceof RTCRtpSender\n      // since we shim RTPSender. So we check if sender._pc is set.\n      if (!sender._pc) {\n        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +\n            'does not implement interface RTCRtpSender.', 'TypeError');\n      }\n      const isLocal = sender._pc === this;\n      if (!isLocal) {\n        throw new DOMException('Sender was not created by this connection.',\n            'InvalidAccessError');\n      }\n\n      // Search for the native stream the senders track belongs to.\n      this._streams = this._streams || {};\n      let stream;\n      Object.keys(this._streams).forEach(streamid => {\n        const hasTrack = this._streams[streamid].getTracks()\n          .find(track => sender.track === track);\n        if (hasTrack) {\n          stream = this._streams[streamid];\n        }\n      });\n\n      if (stream) {\n        if (stream.getTracks().length === 1) {\n          // if this is the last track of the stream, remove the stream. This\n          // takes care of any shimmed _senders.\n          this.removeStream(this._reverseStreams[stream.id]);\n        } else {\n          // relying on the same odd chrome behaviour as above.\n          stream.removeTrack(sender.track);\n        }\n        this.dispatchEvent(new Event('negotiationneeded'));\n      }\n    };\n}\n\nexport function shimPeerConnection(window, browserDetails) {\n  if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.webkitRTCPeerConnection;\n  }\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n  if (browserDetails.version < 53) {\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n        .forEach(function(method) {\n          const nativeMethod = window.RTCPeerConnection.prototype[method];\n          const methodObj = {[method]() {\n            arguments[0] = new ((method === 'addIceCandidate') ?\n                window.RTCIceCandidate :\n                window.RTCSessionDescription)(arguments[0]);\n            return nativeMethod.apply(this, arguments);\n          }};\n          window.RTCPeerConnection.prototype[method] = methodObj[method];\n        });\n  }\n}\n\n// Attempt to fix ONN in plan-b mode.\nexport function fixNegotiationNeeded(window, browserDetails) {\n  utils.wrapPeerConnectionEvent(window, 'negotiationneeded', e => {\n    const pc = e.target;\n    if (browserDetails.version < 72 || (pc.getConfiguration &&\n        pc.getConfiguration().sdpSemantics === 'plan-b')) {\n      if (pc.signalingState !== 'stable') {\n        return;\n      }\n    }\n    return e;\n  });\n}\n","/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\nexport function shimGetDisplayMedia(window, getSourceId) {\n  if (window.navigator.mediaDevices &&\n    'getDisplayMedia' in window.navigator.mediaDevices) {\n    return;\n  }\n  if (!(window.navigator.mediaDevices)) {\n    return;\n  }\n  // getSourceId is a function that returns a promise resolving with\n  // the sourceId of the screen/window/tab to be shared.\n  if (typeof getSourceId !== 'function') {\n    console.error('shimGetDisplayMedia: getSourceId argument is not ' +\n        'a function');\n    return;\n  }\n  window.navigator.mediaDevices.getDisplayMedia =\n    function getDisplayMedia(constraints) {\n      return getSourceId(constraints)\n        .then(sourceId => {\n          const widthSpecified = constraints.video && constraints.video.width;\n          const heightSpecified = constraints.video &&\n            constraints.video.height;\n          const frameRateSpecified = constraints.video &&\n            constraints.video.frameRate;\n          constraints.video = {\n            mandatory: {\n              chromeMediaSource: 'desktop',\n              chromeMediaSourceId: sourceId,\n              maxFrameRate: frameRateSpecified || 3\n            }\n          };\n          if (widthSpecified) {\n            constraints.video.mandatory.maxWidth = widthSpecified;\n          }\n          if (heightSpecified) {\n            constraints.video.mandatory.maxHeight = heightSpecified;\n          }\n          return window.navigator.mediaDevices.getUserMedia(constraints);\n        });\n    };\n}\n","/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\n\nimport * as utils from '../utils';\n\nexport function shimGetUserMedia(window, browserDetails) {\n  const navigator = window && window.navigator;\n  const MediaStreamTrack = window && window.MediaStreamTrack;\n\n  navigator.getUserMedia = function(constraints, onSuccess, onError) {\n    // Replace Firefox 44+'s deprecation warning with unprefixed version.\n    utils.deprecated('navigator.getUserMedia',\n        'navigator.mediaDevices.getUserMedia');\n    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n  };\n\n  if (!(browserDetails.version > 55 &&\n      'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {\n    const remap = function(obj, a, b) {\n      if (a in obj && !(b in obj)) {\n        obj[b] = obj[a];\n        delete obj[a];\n      }\n    };\n\n    const nativeGetUserMedia = navigator.mediaDevices.getUserMedia.\n        bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function(c) {\n      if (typeof c === 'object' && typeof c.audio === 'object') {\n        c = JSON.parse(JSON.stringify(c));\n        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');\n        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');\n      }\n      return nativeGetUserMedia(c);\n    };\n\n    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {\n      const nativeGetSettings = MediaStreamTrack.prototype.getSettings;\n      MediaStreamTrack.prototype.getSettings = function() {\n        const obj = nativeGetSettings.apply(this, arguments);\n        remap(obj, 'mozAutoGainControl', 'autoGainControl');\n        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');\n        return obj;\n      };\n    }\n\n    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {\n      const nativeApplyConstraints =\n        MediaStreamTrack.prototype.applyConstraints;\n      MediaStreamTrack.prototype.applyConstraints = function(c) {\n        if (this.kind === 'audio' && typeof c === 'object') {\n          c = JSON.parse(JSON.stringify(c));\n          remap(c, 'autoGainControl', 'mozAutoGainControl');\n          remap(c, 'noiseSuppression', 'mozNoiseSuppression');\n        }\n        return nativeApplyConstraints.apply(this, [c]);\n      };\n    }\n  }\n}\n","/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\n\nimport * as utils from '../utils';\nexport {shimGetUserMedia} from './getusermedia';\nexport {shimGetDisplayMedia} from './getdisplaymedia';\n\nexport function shimOnTrack(window) {\n  if (typeof window === 'object' && window.RTCTrackEvent &&\n      ('receiver' in window.RTCTrackEvent.prototype) &&\n      !('transceiver' in window.RTCTrackEvent.prototype)) {\n    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n      get() {\n        return {receiver: this.receiver};\n      }\n    });\n  }\n}\n\nexport function shimPeerConnection(window, browserDetails) {\n  if (typeof window !== 'object' ||\n      !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {\n    return; // probably media.peerconnection.enabled=false in about:config\n  }\n  if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {\n    // very basic support for old versions.\n    window.RTCPeerConnection = window.mozRTCPeerConnection;\n  }\n\n  if (browserDetails.version < 53) {\n    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n        .forEach(function(method) {\n          const nativeMethod = window.RTCPeerConnection.prototype[method];\n          const methodObj = {[method]() {\n            arguments[0] = new ((method === 'addIceCandidate') ?\n                window.RTCIceCandidate :\n                window.RTCSessionDescription)(arguments[0]);\n            return nativeMethod.apply(this, arguments);\n          }};\n          window.RTCPeerConnection.prototype[method] = methodObj[method];\n        });\n  }\n\n  const modernStatsTypes = {\n    inboundrtp: 'inbound-rtp',\n    outboundrtp: 'outbound-rtp',\n    candidatepair: 'candidate-pair',\n    localcandidate: 'local-candidate',\n    remotecandidate: 'remote-candidate'\n  };\n\n  const nativeGetStats = window.RTCPeerConnection.prototype.getStats;\n  window.RTCPeerConnection.prototype.getStats = function getStats() {\n    const [selector, onSucc, onErr] = arguments;\n    return nativeGetStats.apply(this, [selector || null])\n      .then(stats => {\n        if (browserDetails.version < 53 && !onSucc) {\n          // Shim only promise getStats with spec-hyphens in type names\n          // Leave callback version alone; misc old uses of forEach before Map\n          try {\n            stats.forEach(stat => {\n              stat.type = modernStatsTypes[stat.type] || stat.type;\n            });\n          } catch (e) {\n            if (e.name !== 'TypeError') {\n              throw e;\n            }\n            // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish\n            stats.forEach((stat, i) => {\n              stats.set(i, Object.assign({}, stat, {\n                type: modernStatsTypes[stat.type] || stat.type\n              }));\n            });\n          }\n        }\n        return stats;\n      })\n      .then(onSucc, onErr);\n  };\n}\n\nexport function shimSenderGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection &&\n      window.RTCRtpSender)) {\n    return;\n  }\n  if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {\n    return;\n  }\n  const origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n  if (origGetSenders) {\n    window.RTCPeerConnection.prototype.getSenders = function getSenders() {\n      const senders = origGetSenders.apply(this, []);\n      senders.forEach(sender => sender._pc = this);\n      return senders;\n    };\n  }\n\n  const origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n  if (origAddTrack) {\n    window.RTCPeerConnection.prototype.addTrack = function addTrack() {\n      const sender = origAddTrack.apply(this, arguments);\n      sender._pc = this;\n      return sender;\n    };\n  }\n  window.RTCRtpSender.prototype.getStats = function getStats() {\n    return this.track ? this._pc.getStats(this.track) :\n        Promise.resolve(new Map());\n  };\n}\n\nexport function shimReceiverGetStats(window) {\n  if (!(typeof window === 'object' && window.RTCPeerConnection &&\n      window.RTCRtpSender)) {\n    return;\n  }\n  if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {\n    return;\n  }\n  const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;\n  if (origGetReceivers) {\n    window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n      const receivers = origGetReceivers.apply(this, []);\n      receivers.forEach(receiver => receiver._pc = this);\n      return receivers;\n    };\n  }\n  utils.wrapPeerConnectionEvent(window, 'track', e => {\n    e.receiver._pc = e.srcElement;\n    return e;\n  });\n  window.RTCRtpReceiver.prototype.getStats = function getStats() {\n    return this._pc.getStats(this.track);\n  };\n}\n\nexport function shimRemoveStream(window) {\n  if (!window.RTCPeerConnection ||\n      'removeStream' in window.RTCPeerConnection.prototype) {\n    return;\n  }\n  window.RTCPeerConnection.prototype.removeStream =\n    function removeStream(stream) {\n      utils.deprecated('removeStream', 'removeTrack');\n      this.getSenders().forEach(sender => {\n        if (sender.track && stream.getTracks().includes(sender.track)) {\n          this.removeTrack(sender);\n        }\n      });\n    };\n}\n\nexport function shimRTCDataChannel(window) {\n  // rename DataChannel to RTCDataChannel (native fix in FF60):\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851\n  if (window.DataChannel && !window.RTCDataChannel) {\n    window.RTCDataChannel = window.DataChannel;\n  }\n}\n\nexport function shimAddTransceiver(window) {\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\n    return;\n  }\n  const origAddTransceiver = window.RTCPeerConnection.prototype.addTransceiver;\n  if (origAddTransceiver) {\n    window.RTCPeerConnection.prototype.addTransceiver =\n      function addTransceiver() {\n        this.setParametersPromises = [];\n        const initParameters = arguments[1];\n        const shouldPerformCheck = initParameters &&\n                                  'sendEncodings' in initParameters;\n        if (shouldPerformCheck) {\n          // If sendEncodings params are provided, validate grammar\n          initParameters.sendEncodings.forEach((encodingParam) => {\n            if ('rid' in encodingParam) {\n              const ridRegex = /^[a-z0-9]{0,16}$/i;\n              if (!ridRegex.test(encodingParam.rid)) {\n                throw new TypeError('Invalid RID value provided.');\n              }\n            }\n            if ('scaleResolutionDownBy' in encodingParam) {\n              if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {\n                throw new RangeError('scale_resolution_down_by must be >= 1.0');\n              }\n            }\n            if ('maxFramerate' in encodingParam) {\n              if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {\n                throw new RangeError('max_framerate must be >= 0.0');\n              }\n            }\n          });\n        }\n        const transceiver = origAddTransceiver.apply(this, arguments);\n        if (shouldPerformCheck) {\n          // Check if the init options were applied. If not we do this in an\n          // asynchronous way and save the promise reference in a global object.\n          // This is an ugly hack, but at the same time is way more robust than\n          // checking the sender parameters before and after the createOffer\n          // Also note that after the createoffer we are not 100% sure that\n          // the params were asynchronously applied so we might miss the\n          // opportunity to recreate offer.\n          const {sender} = transceiver;\n          const params = sender.getParameters();\n          if (!('encodings' in params) ||\n              // Avoid being fooled by patched getParameters() below.\n              (params.encodings.length === 1 &&\n               Object.keys(params.encodings[0]).length === 0)) {\n            params.encodings = initParameters.sendEncodings;\n            sender.sendEncodings = initParameters.sendEncodings;\n            this.setParametersPromises.push(sender.setParameters(params)\n              .then(() => {\n                delete sender.sendEncodings;\n              }).catch(() => {\n                delete sender.sendEncodings;\n              })\n            );\n          }\n        }\n        return transceiver;\n      };\n  }\n}\n\nexport function shimGetParameters(window) {\n  if (!(typeof window === 'object' && window.RTCRtpSender)) {\n    return;\n  }\n  const origGetParameters = window.RTCRtpSender.prototype.getParameters;\n  if (origGetParameters) {\n    window.RTCRtpSender.prototype.getParameters =\n      function getParameters() {\n        const params = origGetParameters.apply(this, arguments);\n        if (!('encodings' in params)) {\n          params.encodings = [].concat(this.sendEncodings || [{}]);\n        }\n        return params;\n      };\n  }\n}\n\nexport function shimCreateOffer(window) {\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\n    return;\n  }\n  const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\n  window.RTCPeerConnection.prototype.createOffer = function createOffer() {\n    if (this.setParametersPromises && this.setParametersPromises.length) {\n      return Promise.all(this.setParametersPromises)\n      .then(() => {\n        return origCreateOffer.apply(this, arguments);\n      })\n      .finally(() => {\n        this.setParametersPromises = [];\n      });\n    }\n    return origCreateOffer.apply(this, arguments);\n  };\n}\n\nexport function shimCreateAnswer(window) {\n  // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n  // Firefox ignores the init sendEncodings options passed to addTransceiver\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n  if (!(typeof window === 'object' && window.RTCPeerConnection)) {\n    return;\n  }\n  const origCreateAnswer = window.RTCPeerConnection.prototype.createAnswer;\n  window.RTCPeerConnection.prototype.createAnswer = function createAnswer() {\n    if (this.setParametersPromises && this.setParametersPromises.length) {\n      return Promise.all(this.setParametersPromises)\n      .then(() => {\n        return origCreateAnswer.apply(this, arguments);\n      })\n      .finally(() => {\n        this.setParametersPromises = [];\n      });\n    }\n    return origCreateAnswer.apply(this, arguments);\n  };\n}\n","/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\n\nexport function shimGetDisplayMedia(window, preferredMediaSource) {\n  if (window.navigator.mediaDevices &&\n    'getDisplayMedia' in window.navigator.mediaDevices) {\n    return;\n  }\n  if (!(window.navigator.mediaDevices)) {\n    return;\n  }\n  window.navigator.mediaDevices.getDisplayMedia =\n    function getDisplayMedia(constraints) {\n      if (!(constraints && constraints.video)) {\n        const err = new DOMException('getDisplayMedia without video ' +\n            'constraints is undefined');\n        err.name = 'NotFoundError';\n        // from https://heycam.github.io/webidl/#idl-DOMException-error-names\n        err.code = 8;\n        return Promise.reject(err);\n      }\n      if (constraints.video === true) {\n        constraints.video = {mediaSource: preferredMediaSource};\n      } else {\n        constraints.video.mediaSource = preferredMediaSource;\n      }\n      return window.navigator.mediaDevices.getUserMedia(constraints);\n    };\n}\n","/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n'use strict';\nimport * as utils from '../utils';\n\nexport function shimLocalStreamsAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.getLocalStreams =\n      function getLocalStreams() {\n        if (!this._localStreams) {\n          this._localStreams = [];\n        }\n        return this._localStreams;\n      };\n  }\n  if (!('addStream' in window.RTCPeerConnection.prototype)) {\n    const _addTrack = window.RTCPeerConnection.prototype.addTrack;\n    window.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n      if (!this._localStreams) {\n        this._localStreams = [];\n      }\n      if (!this._localStreams.includes(stream)) {\n        this._localStreams.push(stream);\n      }\n      // Try to emulate Chrome's behaviour of adding in audio-video order.\n      // Safari orders by track id.\n      stream.getAudioTracks().forEach(track => _addTrack.call(this, track,\n        stream));\n      stream.getVideoTracks().forEach(track => _addTrack.call(this, track,\n        stream));\n    };\n\n    window.RTCPeerConnection.prototype.addTrack =\n      function addTrack(track, ...streams) {\n        if (streams) {\n          streams.forEach((stream) => {\n            if (!this._localStreams) {\n              this._localStreams = [stream];\n            } else if (!this._localStreams.includes(stream)) {\n              this._localStreams.push(stream);\n            }\n          });\n        }\n        return _addTrack.apply(this, arguments);\n      };\n  }\n  if (!('removeStream' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.removeStream =\n      function removeStream(stream) {\n        if (!this._localStreams) {\n          this._localStreams = [];\n        }\n        const index = this._localStreams.indexOf(stream);\n        if (index === -1) {\n          return;\n        }\n        this._localStreams.splice(index, 1);\n        const tracks = stream.getTracks();\n        this.getSenders().forEach(sender => {\n          if (tracks.includes(sender.track)) {\n            this.removeTrack(sender);\n          }\n        });\n      };\n  }\n}\n\nexport function shimRemoteStreamsAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {\n    window.RTCPeerConnection.prototype.getRemoteStreams =\n      function getRemoteStreams() {\n        return this._remoteStreams ? this._remoteStreams : [];\n      };\n  }\n  if (!('onaddstream' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {\n      get() {\n        return this._onaddstream;\n      },\n      set(f) {\n        if (this._onaddstream) {\n          this.removeEventListener('addstream', this._onaddstream);\n          this.removeEventListener('track', this._onaddstreampoly);\n        }\n        this.addEventListener('addstream', this._onaddstream = f);\n        this.addEventListener('track', this._onaddstreampoly = (e) => {\n          e.streams.forEach(stream => {\n            if (!this._remoteStreams) {\n              this._remoteStreams = [];\n            }\n            if (this._remoteStreams.includes(stream)) {\n              return;\n            }\n            this._remoteStreams.push(stream);\n            const event = new Event('addstream');\n            event.stream = stream;\n            this.dispatchEvent(event);\n          });\n        });\n      }\n    });\n    const origSetRemoteDescription =\n      window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription =\n      function setRemoteDescription() {\n        const pc = this;\n        if (!this._onaddstreampoly) {\n          this.addEventListener('track', this._onaddstreampoly = function(e) {\n            e.streams.forEach(stream => {\n              if (!pc._remoteStreams) {\n                pc._remoteStreams = [];\n              }\n              if (pc._remoteStreams.indexOf(stream) >= 0) {\n                return;\n              }\n              pc._remoteStreams.push(stream);\n              const event = new Event('addstream');\n              event.stream = stream;\n              pc.dispatchEvent(event);\n            });\n          });\n        }\n        return origSetRemoteDescription.apply(pc, arguments);\n      };\n  }\n}\n\nexport function shimCallbacksAPI(window) {\n  if (typeof window !== 'object' || !window.RTCPeerConnection) {\n    return;\n  }\n  const prototype = window.RTCPeerConnection.prototype;\n  const origCreateOffer = prototype.createOffer;\n  const origCreateAnswer = prototype.createAnswer;\n  const setLocalDescription = prototype.setLocalDescription;\n  const setRemoteDescription = prototype.setRemoteDescription;\n  const addIceCandidate = prototype.addIceCandidate;\n\n  prototype.createOffer =\n    function createOffer(successCallback, failureCallback) {\n      const options = (arguments.length >= 2) ? arguments[2] : arguments[0];\n      const promise = origCreateOffer.apply(this, [options]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n\n  prototype.createAnswer =\n    function createAnswer(successCallback, failureCallback) {\n      const options = (arguments.length >= 2) ? arguments[2] : arguments[0];\n      const promise = origCreateAnswer.apply(this, [options]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n\n  let withCallback = function(description, successCallback, failureCallback) {\n    const promise = setLocalDescription.apply(this, [description]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.setLocalDescription = withCallback;\n\n  withCallback = function(description, successCallback, failureCallback) {\n    const promise = setRemoteDescription.apply(this, [description]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.setRemoteDescription = withCallback;\n\n  withCallback = function(candidate, successCallback, failureCallback) {\n    const promise = addIceCandidate.apply(this, [candidate]);\n    if (!failureCallback) {\n      return promise;\n    }\n    promise.then(successCallback, failureCallback);\n    return Promise.resolve();\n  };\n  prototype.addIceCandidate = withCallback;\n}\n\nexport function shimGetUserMedia(window) {\n  const navigator = window && window.navigator;\n\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    // shim not needed in Safari 12.1\n    const mediaDevices = navigator.mediaDevices;\n    const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);\n    navigator.mediaDevices.getUserMedia = (constraints) => {\n      return _getUserMedia(shimConstraints(constraints));\n    };\n  }\n\n  if (!navigator.getUserMedia && navigator.mediaDevices &&\n    navigator.mediaDevices.getUserMedia) {\n    navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {\n      navigator.mediaDevices.getUserMedia(constraints)\n      .then(cb, errcb);\n    }.bind(navigator);\n  }\n}\n\nexport function shimConstraints(constraints) {\n  if (constraints && constraints.video !== undefined) {\n    return Object.assign({},\n      constraints,\n      {video: utils.compactObject(constraints.video)}\n    );\n  }\n\n  return constraints;\n}\n\nexport function shimRTCIceServerUrls(window) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n  const OrigPeerConnection = window.RTCPeerConnection;\n  window.RTCPeerConnection =\n    function RTCPeerConnection(pcConfig, pcConstraints) {\n      if (pcConfig && pcConfig.iceServers) {\n        const newIceServers = [];\n        for (let i = 0; i < pcConfig.iceServers.length; i++) {\n          let server = pcConfig.iceServers[i];\n          if (!server.hasOwnProperty('urls') &&\n              server.hasOwnProperty('url')) {\n            utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');\n            server = JSON.parse(JSON.stringify(server));\n            server.urls = server.url;\n            delete server.url;\n            newIceServers.push(server);\n          } else {\n            newIceServers.push(pcConfig.iceServers[i]);\n          }\n        }\n        pcConfig.iceServers = newIceServers;\n      }\n      return new OrigPeerConnection(pcConfig, pcConstraints);\n    };\n  window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n  // wrap static methods. Currently just generateCertificate.\n  if ('generateCertificate' in OrigPeerConnection) {\n    Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n      get() {\n        return OrigPeerConnection.generateCertificate;\n      }\n    });\n  }\n}\n\nexport function shimTrackEventTransceiver(window) {\n  // Add event.transceiver member over deprecated event.receiver\n  if (typeof window === 'object' && window.RTCTrackEvent &&\n      'receiver' in window.RTCTrackEvent.prototype &&\n      !('transceiver' in window.RTCTrackEvent.prototype)) {\n    Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n      get() {\n        return {receiver: this.receiver};\n      }\n    });\n  }\n}\n\nexport function shimCreateOfferLegacy(window) {\n  const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\n  window.RTCPeerConnection.prototype.createOffer =\n    function createOffer(offerOptions) {\n      if (offerOptions) {\n        if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {\n          // support bit values\n          offerOptions.offerToReceiveAudio =\n            !!offerOptions.offerToReceiveAudio;\n        }\n        const audioTransceiver = this.getTransceivers().find(transceiver =>\n          transceiver.receiver.track.kind === 'audio');\n        if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\n          if (audioTransceiver.direction === 'sendrecv') {\n            if (audioTransceiver.setDirection) {\n              audioTransceiver.setDirection('sendonly');\n            } else {\n              audioTransceiver.direction = 'sendonly';\n            }\n          } else if (audioTransceiver.direction === 'recvonly') {\n            if (audioTransceiver.setDirection) {\n              audioTransceiver.setDirection('inactive');\n            } else {\n              audioTransceiver.direction = 'inactive';\n            }\n          }\n        } else if (offerOptions.offerToReceiveAudio === true &&\n            !audioTransceiver) {\n          this.addTransceiver('audio');\n        }\n\n        if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {\n          // support bit values\n          offerOptions.offerToReceiveVideo =\n            !!offerOptions.offerToReceiveVideo;\n        }\n        const videoTransceiver = this.getTransceivers().find(transceiver =>\n          transceiver.receiver.track.kind === 'video');\n        if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\n          if (videoTransceiver.direction === 'sendrecv') {\n            if (videoTransceiver.setDirection) {\n              videoTransceiver.setDirection('sendonly');\n            } else {\n              videoTransceiver.direction = 'sendonly';\n            }\n          } else if (videoTransceiver.direction === 'recvonly') {\n            if (videoTransceiver.setDirection) {\n              videoTransceiver.setDirection('inactive');\n            } else {\n              videoTransceiver.direction = 'inactive';\n            }\n          }\n        } else if (offerOptions.offerToReceiveVideo === true &&\n            !videoTransceiver) {\n          this.addTransceiver('video');\n        }\n      }\n      return origCreateOffer.apply(this, arguments);\n    };\n}\n\nexport function shimAudioContext(window) {\n  if (typeof window !== 'object' || window.AudioContext) {\n    return;\n  }\n  window.AudioContext = window.webkitAudioContext;\n}\n\n","/* eslint-env node */\n'use strict';\n\n// SDP helpers.\nconst SDPUtils = {};\n\n// Generate an alphanumeric identifier for cname or mids.\n// TODO: use UUIDs instead? https://gist.github.com/jed/982883\nSDPUtils.generateIdentifier = function() {\n  return Math.random().toString(36).substr(2, 10);\n};\n\n// The RTCP CNAME used by all peerconnections from the same JS.\nSDPUtils.localCName = SDPUtils.generateIdentifier();\n\n// Splits SDP into lines, dealing with both CRLF and LF.\nSDPUtils.splitLines = function(blob) {\n  return blob.trim().split('\\n').map(line => line.trim());\n};\n// Splits SDP into sessionpart and mediasections. Ensures CRLF.\nSDPUtils.splitSections = function(blob) {\n  const parts = blob.split('\\nm=');\n  return parts.map((part, index) => (index > 0 ?\n    'm=' + part : part).trim() + '\\r\\n');\n};\n\n// Returns the session description.\nSDPUtils.getDescription = function(blob) {\n  const sections = SDPUtils.splitSections(blob);\n  return sections && sections[0];\n};\n\n// Returns the individual media sections.\nSDPUtils.getMediaSections = function(blob) {\n  const sections = SDPUtils.splitSections(blob);\n  sections.shift();\n  return sections;\n};\n\n// Returns lines that start with a certain prefix.\nSDPUtils.matchPrefix = function(blob, prefix) {\n  return SDPUtils.splitLines(blob).filter(line => line.indexOf(prefix) === 0);\n};\n\n// Parses an ICE candidate line. Sample input:\n// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n// rport 55996\"\n// Input can be prefixed with a=.\nSDPUtils.parseCandidate = function(line) {\n  let parts;\n  // Parse both variants.\n  if (line.indexOf('a=candidate:') === 0) {\n    parts = line.substring(12).split(' ');\n  } else {\n    parts = line.substring(10).split(' ');\n  }\n\n  const candidate = {\n    foundation: parts[0],\n    component: {1: 'rtp', 2: 'rtcp'}[parts[1]] || parts[1],\n    protocol: parts[2].toLowerCase(),\n    priority: parseInt(parts[3], 10),\n    ip: parts[4],\n    address: parts[4], // address is an alias for ip.\n    port: parseInt(parts[5], 10),\n    // skip parts[6] == 'typ'\n    type: parts[7],\n  };\n\n  for (let i = 8; i < parts.length; i += 2) {\n    switch (parts[i]) {\n      case 'raddr':\n        candidate.relatedAddress = parts[i + 1];\n        break;\n      case 'rport':\n        candidate.relatedPort = parseInt(parts[i + 1], 10);\n        break;\n      case 'tcptype':\n        candidate.tcpType = parts[i + 1];\n        break;\n      case 'ufrag':\n        candidate.ufrag = parts[i + 1]; // for backward compatibility.\n        candidate.usernameFragment = parts[i + 1];\n        break;\n      default: // extension handling, in particular ufrag. Don't overwrite.\n        if (candidate[parts[i]] === undefined) {\n          candidate[parts[i]] = parts[i + 1];\n        }\n        break;\n    }\n  }\n  return candidate;\n};\n\n// Translates a candidate object into SDP candidate attribute.\n// This does not include the a= prefix!\nSDPUtils.writeCandidate = function(candidate) {\n  const sdp = [];\n  sdp.push(candidate.foundation);\n\n  const component = candidate.component;\n  if (component === 'rtp') {\n    sdp.push(1);\n  } else if (component === 'rtcp') {\n    sdp.push(2);\n  } else {\n    sdp.push(component);\n  }\n  sdp.push(candidate.protocol.toUpperCase());\n  sdp.push(candidate.priority);\n  sdp.push(candidate.address || candidate.ip);\n  sdp.push(candidate.port);\n\n  const type = candidate.type;\n  sdp.push('typ');\n  sdp.push(type);\n  if (type !== 'host' && candidate.relatedAddress &&\n      candidate.relatedPort) {\n    sdp.push('raddr');\n    sdp.push(candidate.relatedAddress);\n    sdp.push('rport');\n    sdp.push(candidate.relatedPort);\n  }\n  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n    sdp.push('tcptype');\n    sdp.push(candidate.tcpType);\n  }\n  if (candidate.usernameFragment || candidate.ufrag) {\n    sdp.push('ufrag');\n    sdp.push(candidate.usernameFragment || candidate.ufrag);\n  }\n  return 'candidate:' + sdp.join(' ');\n};\n\n// Parses an ice-options line, returns an array of option tags.\n// Sample input:\n// a=ice-options:foo bar\nSDPUtils.parseIceOptions = function(line) {\n  return line.substr(14).split(' ');\n};\n\n// Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n// a=rtpmap:111 opus/48000/2\nSDPUtils.parseRtpMap = function(line) {\n  let parts = line.substr(9).split(' ');\n  const parsed = {\n    payloadType: parseInt(parts.shift(), 10), // was: id\n  };\n\n  parts = parts[0].split('/');\n\n  parsed.name = parts[0];\n  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n  // legacy alias, got renamed back to channels in ORTC.\n  parsed.numChannels = parsed.channels;\n  return parsed;\n};\n\n// Generates a rtpmap line from RTCRtpCodecCapability or\n// RTCRtpCodecParameters.\nSDPUtils.writeRtpMap = function(codec) {\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  const channels = codec.channels || codec.numChannels || 1;\n  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +\n      (channels !== 1 ? '/' + channels : '') + '\\r\\n';\n};\n\n// Parses a extmap line (headerextension from RFC 5285). Sample input:\n// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\nSDPUtils.parseExtmap = function(line) {\n  const parts = line.substr(9).split(' ');\n  return {\n    id: parseInt(parts[0], 10),\n    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\n    uri: parts[1],\n  };\n};\n\n// Generates an extmap line from RTCRtpHeaderExtensionParameters or\n// RTCRtpHeaderExtension.\nSDPUtils.writeExtmap = function(headerExtension) {\n  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +\n      (headerExtension.direction && headerExtension.direction !== 'sendrecv'\n        ? '/' + headerExtension.direction\n        : '') +\n      ' ' + headerExtension.uri + '\\r\\n';\n};\n\n// Parses a fmtp line, returns dictionary. Sample input:\n// a=fmtp:96 vbr=on;cng=on\n// Also deals with vbr=on; cng=on\nSDPUtils.parseFmtp = function(line) {\n  const parsed = {};\n  let kv;\n  const parts = line.substr(line.indexOf(' ') + 1).split(';');\n  for (let j = 0; j < parts.length; j++) {\n    kv = parts[j].trim().split('=');\n    parsed[kv[0].trim()] = kv[1];\n  }\n  return parsed;\n};\n\n// Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeFmtp = function(codec) {\n  let line = '';\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.parameters && Object.keys(codec.parameters).length) {\n    const params = [];\n    Object.keys(codec.parameters).forEach(param => {\n      if (codec.parameters[param] !== undefined) {\n        params.push(param + '=' + codec.parameters[param]);\n      } else {\n        params.push(param);\n      }\n    });\n    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n  }\n  return line;\n};\n\n// Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n// a=rtcp-fb:98 nack rpsi\nSDPUtils.parseRtcpFb = function(line) {\n  const parts = line.substr(line.indexOf(' ') + 1).split(' ');\n  return {\n    type: parts.shift(),\n    parameter: parts.join(' '),\n  };\n};\n\n// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeRtcpFb = function(codec) {\n  let lines = '';\n  let pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n    // FIXME: special handling for trr-int?\n    codec.rtcpFeedback.forEach(fb => {\n      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +\n      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +\n          '\\r\\n';\n    });\n  }\n  return lines;\n};\n\n// Parses a RFC 5576 ssrc media attribute. Sample input:\n// a=ssrc:3735928559 cname:something\nSDPUtils.parseSsrcMedia = function(line) {\n  const sp = line.indexOf(' ');\n  const parts = {\n    ssrc: parseInt(line.substr(7, sp - 7), 10),\n  };\n  const colon = line.indexOf(':', sp);\n  if (colon > -1) {\n    parts.attribute = line.substr(sp + 1, colon - sp - 1);\n    parts.value = line.substr(colon + 1);\n  } else {\n    parts.attribute = line.substr(sp + 1);\n  }\n  return parts;\n};\n\n// Parse a ssrc-group line (see RFC 5576). Sample input:\n// a=ssrc-group:semantics 12 34\nSDPUtils.parseSsrcGroup = function(line) {\n  const parts = line.substr(13).split(' ');\n  return {\n    semantics: parts.shift(),\n    ssrcs: parts.map(ssrc => parseInt(ssrc, 10)),\n  };\n};\n\n// Extracts the MID (RFC 5888) from a media section.\n// Returns the MID or undefined if no mid line was found.\nSDPUtils.getMid = function(mediaSection) {\n  const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\n  if (mid) {\n    return mid.substr(6);\n  }\n};\n\n// Parses a fingerprint line for DTLS-SRTP.\nSDPUtils.parseFingerprint = function(line) {\n  const parts = line.substr(14).split(' ');\n  return {\n    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.\n    value: parts[1].toUpperCase(), // the definition is upper-case in RFC 4572.\n  };\n};\n\n// Extracts DTLS parameters from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the fingerprint line as input. See also getIceParameters.\nSDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\n  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=fingerprint:');\n  // Note: a=setup line is ignored since we use the 'auto' role in Edge.\n  return {\n    role: 'auto',\n    fingerprints: lines.map(SDPUtils.parseFingerprint),\n  };\n};\n\n// Serializes DTLS parameters to SDP.\nSDPUtils.writeDtlsParameters = function(params, setupType) {\n  let sdp = 'a=setup:' + setupType + '\\r\\n';\n  params.fingerprints.forEach(fp => {\n    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n  });\n  return sdp;\n};\n\n// Parses a=crypto lines into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members\nSDPUtils.parseCryptoLine = function(line) {\n  const parts = line.substr(9).split(' ');\n  return {\n    tag: parseInt(parts[0], 10),\n    cryptoSuite: parts[1],\n    keyParams: parts[2],\n    sessionParams: parts.slice(3),\n  };\n};\n\nSDPUtils.writeCryptoLine = function(parameters) {\n  return 'a=crypto:' + parameters.tag + ' ' +\n    parameters.cryptoSuite + ' ' +\n    (typeof parameters.keyParams === 'object'\n      ? SDPUtils.writeCryptoKeyParams(parameters.keyParams)\n      : parameters.keyParams) +\n    (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') +\n    '\\r\\n';\n};\n\n// Parses the crypto key parameters into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*\nSDPUtils.parseCryptoKeyParams = function(keyParams) {\n  if (keyParams.indexOf('inline:') !== 0) {\n    return null;\n  }\n  const parts = keyParams.substr(7).split('|');\n  return {\n    keyMethod: 'inline',\n    keySalt: parts[0],\n    lifeTime: parts[1],\n    mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,\n    mkiLength: parts[2] ? parts[2].split(':')[1] : undefined,\n  };\n};\n\nSDPUtils.writeCryptoKeyParams = function(keyParams) {\n  return keyParams.keyMethod + ':'\n    + keyParams.keySalt +\n    (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') +\n    (keyParams.mkiValue && keyParams.mkiLength\n      ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength\n      : '');\n};\n\n// Extracts all SDES parameters.\nSDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {\n  const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=crypto:');\n  return lines.map(SDPUtils.parseCryptoLine);\n};\n\n// Parses ICE information from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the ice-ufrag and ice-pwd lines as input.\nSDPUtils.getIceParameters = function(mediaSection, sessionpart) {\n  const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=ice-ufrag:')[0];\n  const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=ice-pwd:')[0];\n  if (!(ufrag && pwd)) {\n    return null;\n  }\n  return {\n    usernameFragment: ufrag.substr(12),\n    password: pwd.substr(10),\n  };\n};\n\n// Serializes ICE parameters to SDP.\nSDPUtils.writeIceParameters = function(params) {\n  let sdp = 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' +\n      'a=ice-pwd:' + params.password + '\\r\\n';\n  if (params.iceLite) {\n    sdp += 'a=ice-lite\\r\\n';\n  }\n  return sdp;\n};\n\n// Parses the SDP media section and returns RTCRtpParameters.\nSDPUtils.parseRtpParameters = function(mediaSection) {\n  const description = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: [],\n    rtcp: [],\n  };\n  const lines = SDPUtils.splitLines(mediaSection);\n  const mline = lines[0].split(' ');\n  for (let i = 3; i < mline.length; i++) { // find all codecs from mline[3..]\n    const pt = mline[i];\n    const rtpmapline = SDPUtils.matchPrefix(\n      mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n    if (rtpmapline) {\n      const codec = SDPUtils.parseRtpMap(rtpmapline);\n      const fmtps = SDPUtils.matchPrefix(\n        mediaSection, 'a=fmtp:' + pt + ' ');\n      // Only the first a=fmtp:<pt> is considered.\n      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n      codec.rtcpFeedback = SDPUtils.matchPrefix(\n        mediaSection, 'a=rtcp-fb:' + pt + ' ')\n        .map(SDPUtils.parseRtcpFb);\n      description.codecs.push(codec);\n      // parse FEC mechanisms from rtpmap lines.\n      switch (codec.name.toUpperCase()) {\n        case 'RED':\n        case 'ULPFEC':\n          description.fecMechanisms.push(codec.name.toUpperCase());\n          break;\n        default: // only RED and ULPFEC are recognized as FEC mechanisms.\n          break;\n      }\n    }\n  }\n  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(line => {\n    description.headerExtensions.push(SDPUtils.parseExtmap(line));\n  });\n  // FIXME: parse rtcp.\n  return description;\n};\n\n// Generates parts of the SDP media section describing the capabilities /\n// parameters.\nSDPUtils.writeRtpDescription = function(kind, caps) {\n  let sdp = '';\n\n  // Build the mline.\n  sdp += 'm=' + kind + ' ';\n  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n  sdp += ' UDP/TLS/RTP/SAVPF ';\n  sdp += caps.codecs.map(codec => {\n    if (codec.preferredPayloadType !== undefined) {\n      return codec.preferredPayloadType;\n    }\n    return codec.payloadType;\n  }).join(' ') + '\\r\\n';\n\n  sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\n\n  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n  caps.codecs.forEach(codec => {\n    sdp += SDPUtils.writeRtpMap(codec);\n    sdp += SDPUtils.writeFmtp(codec);\n    sdp += SDPUtils.writeRtcpFb(codec);\n  });\n  let maxptime = 0;\n  caps.codecs.forEach(codec => {\n    if (codec.maxptime > maxptime) {\n      maxptime = codec.maxptime;\n    }\n  });\n  if (maxptime > 0) {\n    sdp += 'a=maxptime:' + maxptime + '\\r\\n';\n  }\n\n  if (caps.headerExtensions) {\n    caps.headerExtensions.forEach(extension => {\n      sdp += SDPUtils.writeExtmap(extension);\n    });\n  }\n  // FIXME: write fecMechanisms.\n  return sdp;\n};\n\n// Parses the SDP media section and returns an array of\n// RTCRtpEncodingParameters.\nSDPUtils.parseRtpEncodingParameters = function(mediaSection) {\n  const encodingParameters = [];\n  const description = SDPUtils.parseRtpParameters(mediaSection);\n  const hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n  const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\n\n  // filter a=ssrc:... cname:, ignore PlanB-msid\n  const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(line => SDPUtils.parseSsrcMedia(line))\n    .filter(parts => parts.attribute === 'cname');\n  const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n  let secondarySsrc;\n\n  const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')\n    .map(line => {\n      const parts = line.substr(17).split(' ');\n      return parts.map(part => parseInt(part, 10));\n    });\n  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n    secondarySsrc = flows[0][1];\n  }\n\n  description.codecs.forEach(codec => {\n    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n      let encParam = {\n        ssrc: primarySsrc,\n        codecPayloadType: parseInt(codec.parameters.apt, 10),\n      };\n      if (primarySsrc && secondarySsrc) {\n        encParam.rtx = {ssrc: secondarySsrc};\n      }\n      encodingParameters.push(encParam);\n      if (hasRed) {\n        encParam = JSON.parse(JSON.stringify(encParam));\n        encParam.fec = {\n          ssrc: primarySsrc,\n          mechanism: hasUlpfec ? 'red+ulpfec' : 'red',\n        };\n        encodingParameters.push(encParam);\n      }\n    }\n  });\n  if (encodingParameters.length === 0 && primarySsrc) {\n    encodingParameters.push({\n      ssrc: primarySsrc,\n    });\n  }\n\n  // we support both b=AS and b=TIAS but interpret AS as TIAS.\n  let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n  if (bandwidth.length) {\n    if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n      bandwidth = parseInt(bandwidth[0].substr(7), 10);\n    } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n      // use formula from JSEP to convert b=AS to TIAS value.\n      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95\n          - (50 * 40 * 8);\n    } else {\n      bandwidth = undefined;\n    }\n    encodingParameters.forEach(params => {\n      params.maxBitrate = bandwidth;\n    });\n  }\n  return encodingParameters;\n};\n\n// parses http://draft.ortc.org/#rtcrtcpparameters*\nSDPUtils.parseRtcpParameters = function(mediaSection) {\n  const rtcpParameters = {};\n\n  // Gets the first SSRC. Note that with RTX there might be multiple\n  // SSRCs.\n  const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(line => SDPUtils.parseSsrcMedia(line))\n    .filter(obj => obj.attribute === 'cname')[0];\n  if (remoteSsrc) {\n    rtcpParameters.cname = remoteSsrc.value;\n    rtcpParameters.ssrc = remoteSsrc.ssrc;\n  }\n\n  // Edge uses the compound attribute instead of reducedSize\n  // compound is !reducedSize\n  const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\n  rtcpParameters.reducedSize = rsize.length > 0;\n  rtcpParameters.compound = rsize.length === 0;\n\n  // parses the rtcp-mux attrіbute.\n  // Note that Edge does not support unmuxed RTCP.\n  const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\n  rtcpParameters.mux = mux.length > 0;\n\n  return rtcpParameters;\n};\n\nSDPUtils.writeRtcpParameters = function(rtcpParameters) {\n  let sdp = '';\n  if (rtcpParameters.reducedSize) {\n    sdp += 'a=rtcp-rsize\\r\\n';\n  }\n  if (rtcpParameters.mux) {\n    sdp += 'a=rtcp-mux\\r\\n';\n  }\n  if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {\n    sdp += 'a=ssrc:' + rtcpParameters.ssrc +\n      ' cname:' + rtcpParameters.cname + '\\r\\n';\n  }\n  return sdp;\n};\n\n\n// parses either a=msid: or a=ssrc:... msid lines and returns\n// the id of the MediaStream and MediaStreamTrack.\nSDPUtils.parseMsid = function(mediaSection) {\n  let parts;\n  const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\n  if (spec.length === 1) {\n    parts = spec[0].substr(7).split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n  const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(line => SDPUtils.parseSsrcMedia(line))\n    .filter(msidParts => msidParts.attribute === 'msid');\n  if (planB.length > 0) {\n    parts = planB[0].value.split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n};\n\n// SCTP\n// parses draft-ietf-mmusic-sctp-sdp-26 first and falls back\n// to draft-ietf-mmusic-sctp-sdp-05\nSDPUtils.parseSctpDescription = function(mediaSection) {\n  const mline = SDPUtils.parseMLine(mediaSection);\n  const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');\n  let maxMessageSize;\n  if (maxSizeLine.length > 0) {\n    maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);\n  }\n  if (isNaN(maxMessageSize)) {\n    maxMessageSize = 65536;\n  }\n  const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');\n  if (sctpPort.length > 0) {\n    return {\n      port: parseInt(sctpPort[0].substr(12), 10),\n      protocol: mline.fmt,\n      maxMessageSize,\n    };\n  }\n  const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');\n  if (sctpMapLines.length > 0) {\n    const parts = sctpMapLines[0]\n      .substr(10)\n      .split(' ');\n    return {\n      port: parseInt(parts[0], 10),\n      protocol: parts[1],\n      maxMessageSize,\n    };\n  }\n};\n\n// SCTP\n// outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers\n// support by now receiving in this format, unless we originally parsed\n// as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line\n// protocol of DTLS/SCTP -- without UDP/ or TCP/)\nSDPUtils.writeSctpDescription = function(media, sctp) {\n  let output = [];\n  if (media.protocol !== 'DTLS/SCTP') {\n    output = [\n      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\\r\\n',\n      'c=IN IP4 0.0.0.0\\r\\n',\n      'a=sctp-port:' + sctp.port + '\\r\\n',\n    ];\n  } else {\n    output = [\n      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\\r\\n',\n      'c=IN IP4 0.0.0.0\\r\\n',\n      'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\\r\\n',\n    ];\n  }\n  if (sctp.maxMessageSize !== undefined) {\n    output.push('a=max-message-size:' + sctp.maxMessageSize + '\\r\\n');\n  }\n  return output.join('');\n};\n\n// Generate a session ID for SDP.\n// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n// recommends using a cryptographically random +ve 64-bit value\n// but right now this should be acceptable and within the right range\nSDPUtils.generateSessionId = function() {\n  return Math.random().toString().substr(2, 21);\n};\n\n// Write boiler plate for start of SDP\n// sessId argument is optional - if not supplied it will\n// be generated randomly\n// sessVersion is optional and defaults to 2\n// sessUser is optional and defaults to 'thisisadapterortc'\nSDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {\n  let sessionId;\n  const version = sessVer !== undefined ? sessVer : 2;\n  if (sessId) {\n    sessionId = sessId;\n  } else {\n    sessionId = SDPUtils.generateSessionId();\n  }\n  const user = sessUser || 'thisisadapterortc';\n  // FIXME: sess-id should be an NTP timestamp.\n  return 'v=0\\r\\n' +\n      'o=' + user + ' ' + sessionId + ' ' + version +\n        ' IN IP4 127.0.0.1\\r\\n' +\n      's=-\\r\\n' +\n      't=0 0\\r\\n';\n};\n\n// Gets the direction from the mediaSection or the sessionpart.\nSDPUtils.getDirection = function(mediaSection, sessionpart) {\n  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n  const lines = SDPUtils.splitLines(mediaSection);\n  for (let i = 0; i < lines.length; i++) {\n    switch (lines[i]) {\n      case 'a=sendrecv':\n      case 'a=sendonly':\n      case 'a=recvonly':\n      case 'a=inactive':\n        return lines[i].substr(2);\n      default:\n        // FIXME: What should happen here?\n    }\n  }\n  if (sessionpart) {\n    return SDPUtils.getDirection(sessionpart);\n  }\n  return 'sendrecv';\n};\n\nSDPUtils.getKind = function(mediaSection) {\n  const lines = SDPUtils.splitLines(mediaSection);\n  const mline = lines[0].split(' ');\n  return mline[0].substr(2);\n};\n\nSDPUtils.isRejected = function(mediaSection) {\n  return mediaSection.split(' ', 2)[1] === '0';\n};\n\nSDPUtils.parseMLine = function(mediaSection) {\n  const lines = SDPUtils.splitLines(mediaSection);\n  const parts = lines[0].substr(2).split(' ');\n  return {\n    kind: parts[0],\n    port: parseInt(parts[1], 10),\n    protocol: parts[2],\n    fmt: parts.slice(3).join(' '),\n  };\n};\n\nSDPUtils.parseOLine = function(mediaSection) {\n  const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\n  const parts = line.substr(2).split(' ');\n  return {\n    username: parts[0],\n    sessionId: parts[1],\n    sessionVersion: parseInt(parts[2], 10),\n    netType: parts[3],\n    addressType: parts[4],\n    address: parts[5],\n  };\n};\n\n// a very naive interpretation of a valid SDP.\nSDPUtils.isValidSDP = function(blob) {\n  if (typeof blob !== 'string' || blob.length === 0) {\n    return false;\n  }\n  const lines = SDPUtils.splitLines(blob);\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {\n      return false;\n    }\n    // TODO: check the modifier a bit more.\n  }\n  return true;\n};\n\n// Expose public methods.\nif (typeof module === 'object') {\n  module.exports = SDPUtils;\n}\n","/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n'use strict';\n\nimport SDPUtils from 'sdp';\nimport * as utils from './utils';\n\nexport function shimRTCIceCandidate(window) {\n  // foundation is arbitrarily chosen as an indicator for full support for\n  // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface\n  if (!window.RTCIceCandidate || (window.RTCIceCandidate && 'foundation' in\n      window.RTCIceCandidate.prototype)) {\n    return;\n  }\n\n  const NativeRTCIceCandidate = window.RTCIceCandidate;\n  window.RTCIceCandidate = function RTCIceCandidate(args) {\n    // Remove the a= which shouldn't be part of the candidate string.\n    if (typeof args === 'object' && args.candidate &&\n        args.candidate.indexOf('a=') === 0) {\n      args = JSON.parse(JSON.stringify(args));\n      args.candidate = args.candidate.substr(2);\n    }\n\n    if (args.candidate && args.candidate.length) {\n      // Augment the native candidate with the parsed fields.\n      const nativeCandidate = new NativeRTCIceCandidate(args);\n      const parsedCandidate = SDPUtils.parseCandidate(args.candidate);\n      const augmentedCandidate = Object.assign(nativeCandidate,\n          parsedCandidate);\n\n      // Add a serializer that does not serialize the extra attributes.\n      augmentedCandidate.toJSON = function toJSON() {\n        return {\n          candidate: augmentedCandidate.candidate,\n          sdpMid: augmentedCandidate.sdpMid,\n          sdpMLineIndex: augmentedCandidate.sdpMLineIndex,\n          usernameFragment: augmentedCandidate.usernameFragment,\n        };\n      };\n      return augmentedCandidate;\n    }\n    return new NativeRTCIceCandidate(args);\n  };\n  window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;\n\n  // Hook up the augmented candidate in onicecandidate and\n  // addEventListener('icecandidate', ...)\n  utils.wrapPeerConnectionEvent(window, 'icecandidate', e => {\n    if (e.candidate) {\n      Object.defineProperty(e, 'candidate', {\n        value: new window.RTCIceCandidate(e.candidate),\n        writable: 'false'\n      });\n    }\n    return e;\n  });\n}\n\nexport function shimMaxMessageSize(window, browserDetails) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n\n  if (!('sctp' in window.RTCPeerConnection.prototype)) {\n    Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {\n      get() {\n        return typeof this._sctp === 'undefined' ? null : this._sctp;\n      }\n    });\n  }\n\n  const sctpInDescription = function(description) {\n    if (!description || !description.sdp) {\n      return false;\n    }\n    const sections = SDPUtils.splitSections(description.sdp);\n    sections.shift();\n    return sections.some(mediaSection => {\n      const mLine = SDPUtils.parseMLine(mediaSection);\n      return mLine && mLine.kind === 'application'\n          && mLine.protocol.indexOf('SCTP') !== -1;\n    });\n  };\n\n  const getRemoteFirefoxVersion = function(description) {\n    // TODO: Is there a better solution for detecting Firefox?\n    const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n    if (match === null || match.length < 2) {\n      return -1;\n    }\n    const version = parseInt(match[1], 10);\n    // Test for NaN (yes, this is ugly)\n    return version !== version ? -1 : version;\n  };\n\n  const getCanSendMaxMessageSize = function(remoteIsFirefox) {\n    // Every implementation we know can send at least 64 KiB.\n    // Note: Although Chrome is technically able to send up to 256 KiB, the\n    //       data does not reach the other peer reliably.\n    //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419\n    let canSendMaxMessageSize = 65536;\n    if (browserDetails.browser === 'firefox') {\n      if (browserDetails.version < 57) {\n        if (remoteIsFirefox === -1) {\n          // FF < 57 will send in 16 KiB chunks using the deprecated PPID\n          // fragmentation.\n          canSendMaxMessageSize = 16384;\n        } else {\n          // However, other FF (and RAWRTC) can reassemble PPID-fragmented\n          // messages. Thus, supporting ~2 GiB when sending.\n          canSendMaxMessageSize = 2147483637;\n        }\n      } else if (browserDetails.version < 60) {\n        // Currently, all FF >= 57 will reset the remote maximum message size\n        // to the default value when a data channel is created at a later\n        // stage. :(\n        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n        canSendMaxMessageSize =\n          browserDetails.version === 57 ? 65535 : 65536;\n      } else {\n        // FF >= 60 supports sending ~2 GiB\n        canSendMaxMessageSize = 2147483637;\n      }\n    }\n    return canSendMaxMessageSize;\n  };\n\n  const getMaxMessageSize = function(description, remoteIsFirefox) {\n    // Note: 65536 bytes is the default value from the SDP spec. Also,\n    //       every implementation we know supports receiving 65536 bytes.\n    let maxMessageSize = 65536;\n\n    // FF 57 has a slightly incorrect default remote max message size, so\n    // we need to adjust it here to avoid a failure when sending.\n    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697\n    if (browserDetails.browser === 'firefox'\n         && browserDetails.version === 57) {\n      maxMessageSize = 65535;\n    }\n\n    const match = SDPUtils.matchPrefix(description.sdp,\n      'a=max-message-size:');\n    if (match.length > 0) {\n      maxMessageSize = parseInt(match[0].substr(19), 10);\n    } else if (browserDetails.browser === 'firefox' &&\n                remoteIsFirefox !== -1) {\n      // If the maximum message size is not present in the remote SDP and\n      // both local and remote are Firefox, the remote peer can receive\n      // ~2 GiB.\n      maxMessageSize = 2147483637;\n    }\n    return maxMessageSize;\n  };\n\n  const origSetRemoteDescription =\n      window.RTCPeerConnection.prototype.setRemoteDescription;\n  window.RTCPeerConnection.prototype.setRemoteDescription =\n    function setRemoteDescription() {\n      this._sctp = null;\n      // Chrome decided to not expose .sctp in plan-b mode.\n      // As usual, adapter.js has to do an 'ugly worakaround'\n      // to cover up the mess.\n      if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {\n        const {sdpSemantics} = this.getConfiguration();\n        if (sdpSemantics === 'plan-b') {\n          Object.defineProperty(this, 'sctp', {\n            get() {\n              return typeof this._sctp === 'undefined' ? null : this._sctp;\n            },\n            enumerable: true,\n            configurable: true,\n          });\n        }\n      }\n\n      if (sctpInDescription(arguments[0])) {\n        // Check if the remote is FF.\n        const isFirefox = getRemoteFirefoxVersion(arguments[0]);\n\n        // Get the maximum message size the local peer is capable of sending\n        const canSendMMS = getCanSendMaxMessageSize(isFirefox);\n\n        // Get the maximum message size of the remote peer.\n        const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);\n\n        // Determine final maximum message size\n        let maxMessageSize;\n        if (canSendMMS === 0 && remoteMMS === 0) {\n          maxMessageSize = Number.POSITIVE_INFINITY;\n        } else if (canSendMMS === 0 || remoteMMS === 0) {\n          maxMessageSize = Math.max(canSendMMS, remoteMMS);\n        } else {\n          maxMessageSize = Math.min(canSendMMS, remoteMMS);\n        }\n\n        // Create a dummy RTCSctpTransport object and the 'maxMessageSize'\n        // attribute.\n        const sctp = {};\n        Object.defineProperty(sctp, 'maxMessageSize', {\n          get() {\n            return maxMessageSize;\n          }\n        });\n        this._sctp = sctp;\n      }\n\n      return origSetRemoteDescription.apply(this, arguments);\n    };\n}\n\nexport function shimSendThrowTypeError(window) {\n  if (!(window.RTCPeerConnection &&\n      'createDataChannel' in window.RTCPeerConnection.prototype)) {\n    return;\n  }\n\n  // Note: Although Firefox >= 57 has a native implementation, the maximum\n  //       message size can be reset for all data channels at a later stage.\n  //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n\n  function wrapDcSend(dc, pc) {\n    const origDataChannelSend = dc.send;\n    dc.send = function send() {\n      const data = arguments[0];\n      const length = data.length || data.size || data.byteLength;\n      if (dc.readyState === 'open' &&\n          pc.sctp && length > pc.sctp.maxMessageSize) {\n        throw new TypeError('Message too large (can send a maximum of ' +\n          pc.sctp.maxMessageSize + ' bytes)');\n      }\n      return origDataChannelSend.apply(dc, arguments);\n    };\n  }\n  const origCreateDataChannel =\n    window.RTCPeerConnection.prototype.createDataChannel;\n  window.RTCPeerConnection.prototype.createDataChannel =\n    function createDataChannel() {\n      const dataChannel = origCreateDataChannel.apply(this, arguments);\n      wrapDcSend(dataChannel, this);\n      return dataChannel;\n    };\n  utils.wrapPeerConnectionEvent(window, 'datachannel', e => {\n    wrapDcSend(e.channel, e.target);\n    return e;\n  });\n}\n\n\n/* shims RTCConnectionState by pretending it is the same as iceConnectionState.\n * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12\n * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect\n * since DTLS failures would be hidden. See\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827\n * for the Firefox tracking bug.\n */\nexport function shimConnectionState(window) {\n  if (!window.RTCPeerConnection ||\n      'connectionState' in window.RTCPeerConnection.prototype) {\n    return;\n  }\n  const proto = window.RTCPeerConnection.prototype;\n  Object.defineProperty(proto, 'connectionState', {\n    get() {\n      return {\n        completed: 'connected',\n        checking: 'connecting'\n      }[this.iceConnectionState] || this.iceConnectionState;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(proto, 'onconnectionstatechange', {\n    get() {\n      return this._onconnectionstatechange || null;\n    },\n    set(cb) {\n      if (this._onconnectionstatechange) {\n        this.removeEventListener('connectionstatechange',\n            this._onconnectionstatechange);\n        delete this._onconnectionstatechange;\n      }\n      if (cb) {\n        this.addEventListener('connectionstatechange',\n            this._onconnectionstatechange = cb);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ['setLocalDescription', 'setRemoteDescription'].forEach((method) => {\n    const origMethod = proto[method];\n    proto[method] = function() {\n      if (!this._connectionstatechangepoly) {\n        this._connectionstatechangepoly = e => {\n          const pc = e.target;\n          if (pc._lastConnectionState !== pc.connectionState) {\n            pc._lastConnectionState = pc.connectionState;\n            const newEvent = new Event('connectionstatechange', e);\n            pc.dispatchEvent(newEvent);\n          }\n          return e;\n        };\n        this.addEventListener('iceconnectionstatechange',\n          this._connectionstatechangepoly);\n      }\n      return origMethod.apply(this, arguments);\n    };\n  });\n}\n\nexport function removeExtmapAllowMixed(window, browserDetails) {\n  /* remove a=extmap-allow-mixed for webrtc.org < M71 */\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {\n    return;\n  }\n  if (browserDetails.browser === 'safari' && browserDetails.version >= 605) {\n    return;\n  }\n  const nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;\n  window.RTCPeerConnection.prototype.setRemoteDescription =\n  function setRemoteDescription(desc) {\n    if (desc && desc.sdp && desc.sdp.indexOf('\\na=extmap-allow-mixed') !== -1) {\n      const sdp = desc.sdp.split('\\n').filter((line) => {\n        return line.trim() !== 'a=extmap-allow-mixed';\n      }).join('\\n');\n      // Safari enforces read-only-ness of RTCSessionDescription fields.\n      if (window.RTCSessionDescription &&\n          desc instanceof window.RTCSessionDescription) {\n        arguments[0] = new window.RTCSessionDescription({\n          type: desc.type,\n          sdp,\n        });\n      } else {\n        desc.sdp = sdp;\n      }\n    }\n    return nativeSRD.apply(this, arguments);\n  };\n}\n\nexport function shimAddIceCandidateNullOrEmpty(window, browserDetails) {\n  // Support for addIceCandidate(null or undefined)\n  // as well as addIceCandidate({candidate: \"\", ...})\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=978582\n  // Note: must be called before other polyfills which change the signature.\n  if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {\n    return;\n  }\n  const nativeAddIceCandidate =\n      window.RTCPeerConnection.prototype.addIceCandidate;\n  if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {\n    return;\n  }\n  window.RTCPeerConnection.prototype.addIceCandidate =\n    function addIceCandidate() {\n      if (!arguments[0]) {\n        if (arguments[1]) {\n          arguments[1].apply(null);\n        }\n        return Promise.resolve();\n      }\n      // Firefox 68+ emits and processes {candidate: \"\", ...}, ignore\n      // in older versions.\n      // Native support for ignoring exists for Chrome M77+.\n      // Safari ignores as well, exact version unknown but works in the same\n      // version that also ignores addIceCandidate(null).\n      if (((browserDetails.browser === 'chrome' && browserDetails.version < 78)\n           || (browserDetails.browser === 'firefox'\n               && browserDetails.version < 68)\n           || (browserDetails.browser === 'safari'))\n          && arguments[0] && arguments[0].candidate === '') {\n        return Promise.resolve();\n      }\n      return nativeAddIceCandidate.apply(this, arguments);\n    };\n}\n\n// Note: Make sure to call this ahead of APIs that modify\n// setLocalDescription.length\nexport function shimParameterlessSetLocalDescription(window, browserDetails) {\n  if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {\n    return;\n  }\n  const nativeSetLocalDescription =\n      window.RTCPeerConnection.prototype.setLocalDescription;\n  if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {\n    return;\n  }\n  window.RTCPeerConnection.prototype.setLocalDescription =\n    function setLocalDescription() {\n      let desc = arguments[0] || {};\n      if (typeof desc !== 'object' || (desc.type && desc.sdp)) {\n        return nativeSetLocalDescription.apply(this, arguments);\n      }\n      // The remaining steps should technically happen when SLD comes off the\n      // RTCPeerConnection's operations chain (not ahead of going on it), but\n      // this is too difficult to shim. Instead, this shim only covers the\n      // common case where the operations chain is empty. This is imperfect, but\n      // should cover many cases. Rationale: Even if we can't reduce the glare\n      // window to zero on imperfect implementations, there's value in tapping\n      // into the perfect negotiation pattern that several browsers support.\n      desc = {type: desc.type, sdp: desc.sdp};\n      if (!desc.type) {\n        switch (this.signalingState) {\n          case 'stable':\n          case 'have-local-offer':\n          case 'have-remote-pranswer':\n            desc.type = 'offer';\n            break;\n          default:\n            desc.type = 'answer';\n            break;\n        }\n      }\n      if (desc.sdp || (desc.type !== 'offer' && desc.type !== 'answer')) {\n        return nativeSetLocalDescription.apply(this, [desc]);\n      }\n      const func = desc.type === 'offer' ? this.createOffer : this.createAnswer;\n      return func.apply(this)\n        .then(d => nativeSetLocalDescription.apply(this, [d]));\n    };\n}\n","/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n/* eslint-env node */\n\n'use strict';\n\nimport {adapterFactory} from './adapter_factory.js';\n\nconst adapter =\n  adapterFactory({window: typeof window === 'undefined' ? undefined : window});\nexport default adapter;\n","/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\nimport * as utils from './utils';\n\n  // Browser shims.\nimport * as chromeShim from './chrome/chrome_shim';\nimport * as firefoxShim from './firefox/firefox_shim';\nimport * as safariShim from './safari/safari_shim';\nimport * as commonShim from './common_shim';\nimport * as sdp from 'sdp';\n\n// Shimming starts here.\nexport function adapterFactory({window} = {}, options = {\n  shimChrome: true,\n  shimFirefox: true,\n  shimSafari: true,\n}) {\n  // Utils.\n  const logging = utils.log;\n  const browserDetails = utils.detectBrowser(window);\n\n  const adapter = {\n    browserDetails,\n    commonShim,\n    extractVersion: utils.extractVersion,\n    disableLog: utils.disableLog,\n    disableWarnings: utils.disableWarnings,\n    // Expose sdp as a convenience. For production apps include directly.\n    sdp,\n  };\n\n  // Shim browser if found.\n  switch (browserDetails.browser) {\n    case 'chrome':\n      if (!chromeShim || !chromeShim.shimPeerConnection ||\n          !options.shimChrome) {\n        logging('Chrome shim is not included in this adapter release.');\n        return adapter;\n      }\n      if (browserDetails.version === null) {\n        logging('Chrome shim can not determine version, not shimming.');\n        return adapter;\n      }\n      logging('adapter.js shimming chrome.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = chromeShim;\n\n      // Must be called before shimPeerConnection.\n      commonShim.shimAddIceCandidateNullOrEmpty(window, browserDetails);\n      commonShim.shimParameterlessSetLocalDescription(window, browserDetails);\n\n      chromeShim.shimGetUserMedia(window, browserDetails);\n      chromeShim.shimMediaStream(window, browserDetails);\n      chromeShim.shimPeerConnection(window, browserDetails);\n      chromeShim.shimOnTrack(window, browserDetails);\n      chromeShim.shimAddTrackRemoveTrack(window, browserDetails);\n      chromeShim.shimGetSendersWithDtmf(window, browserDetails);\n      chromeShim.shimGetStats(window, browserDetails);\n      chromeShim.shimSenderReceiverGetStats(window, browserDetails);\n      chromeShim.fixNegotiationNeeded(window, browserDetails);\n\n      commonShim.shimRTCIceCandidate(window, browserDetails);\n      commonShim.shimConnectionState(window, browserDetails);\n      commonShim.shimMaxMessageSize(window, browserDetails);\n      commonShim.shimSendThrowTypeError(window, browserDetails);\n      commonShim.removeExtmapAllowMixed(window, browserDetails);\n      break;\n    case 'firefox':\n      if (!firefoxShim || !firefoxShim.shimPeerConnection ||\n          !options.shimFirefox) {\n        logging('Firefox shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming firefox.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = firefoxShim;\n\n      // Must be called before shimPeerConnection.\n      commonShim.shimAddIceCandidateNullOrEmpty(window, browserDetails);\n      commonShim.shimParameterlessSetLocalDescription(window, browserDetails);\n\n      firefoxShim.shimGetUserMedia(window, browserDetails);\n      firefoxShim.shimPeerConnection(window, browserDetails);\n      firefoxShim.shimOnTrack(window, browserDetails);\n      firefoxShim.shimRemoveStream(window, browserDetails);\n      firefoxShim.shimSenderGetStats(window, browserDetails);\n      firefoxShim.shimReceiverGetStats(window, browserDetails);\n      firefoxShim.shimRTCDataChannel(window, browserDetails);\n      firefoxShim.shimAddTransceiver(window, browserDetails);\n      firefoxShim.shimGetParameters(window, browserDetails);\n      firefoxShim.shimCreateOffer(window, browserDetails);\n      firefoxShim.shimCreateAnswer(window, browserDetails);\n\n      commonShim.shimRTCIceCandidate(window, browserDetails);\n      commonShim.shimConnectionState(window, browserDetails);\n      commonShim.shimMaxMessageSize(window, browserDetails);\n      commonShim.shimSendThrowTypeError(window, browserDetails);\n      break;\n    case 'safari':\n      if (!safariShim || !options.shimSafari) {\n        logging('Safari shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming safari.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = safariShim;\n\n      // Must be called before shimCallbackAPI.\n      commonShim.shimAddIceCandidateNullOrEmpty(window, browserDetails);\n      commonShim.shimParameterlessSetLocalDescription(window, browserDetails);\n\n      safariShim.shimRTCIceServerUrls(window, browserDetails);\n      safariShim.shimCreateOfferLegacy(window, browserDetails);\n      safariShim.shimCallbacksAPI(window, browserDetails);\n      safariShim.shimLocalStreamsAPI(window, browserDetails);\n      safariShim.shimRemoteStreamsAPI(window, browserDetails);\n      safariShim.shimTrackEventTransceiver(window, browserDetails);\n      safariShim.shimGetUserMedia(window, browserDetails);\n      safariShim.shimAudioContext(window, browserDetails);\n\n      commonShim.shimRTCIceCandidate(window, browserDetails);\n      commonShim.shimMaxMessageSize(window, browserDetails);\n      commonShim.shimSendThrowTypeError(window, browserDetails);\n      commonShim.removeExtmapAllowMixed(window, browserDetails);\n      break;\n    default:\n      logging('Unsupported browser!');\n      break;\n  }\n\n  return adapter;\n}\n","'use strict';\n\n// Last time updated: 2021-03-09 3:20:22 AM UTC\n\n// ________________\n// RecordRTC v5.6.2\n\n// Open-Sourced: https://github.com/muaz-khan/RecordRTC\n\n// --------------------------------------------------\n// Muaz Khan     - www.MuazKhan.com\n// MIT License   - www.WebRTC-Experiment.com/licence\n// --------------------------------------------------\n\n// ____________\n// RecordRTC.js\n\n/**\n * {@link https://github.com/muaz-khan/RecordRTC|RecordRTC} is a WebRTC JavaScript library for audio/video as well as screen activity recording. It supports Chrome, Firefox, Opera, Android, and Microsoft Edge. Platforms: Linux, Mac and Windows. \n * @summary Record audio, video or screen inside the browser.\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @typedef RecordRTC\n * @class\n * @example\n * var recorder = RecordRTC(mediaStream or [arrayOfMediaStream], {\n *     type: 'video', // audio or video or gif or canvas\n *     recorderType: MediaStreamRecorder || CanvasRecorder || StereoAudioRecorder || Etc\n * });\n * recorder.startRecording();\n * @see For further information:\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n * @param {MediaStream} mediaStream - Single media-stream object, array of media-streams, html-canvas-element, etc.\n * @param {object} config - {type:\"video\", recorderType: MediaStreamRecorder, disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, desiredSampRate: 16000, video: HTMLVideoElement, etc.}\n */\n\nfunction RecordRTC(mediaStream, config) {\n    if (!mediaStream) {\n        throw 'First parameter is required.';\n    }\n\n    config = config || {\n        type: 'video'\n    };\n\n    config = new RecordRTCConfiguration(mediaStream, config);\n\n    // a reference to user's recordRTC object\n    var self = this;\n\n    function startRecording(config2) {\n        if (!config.disableLogs) {\n            console.log('RecordRTC version: ', self.version);\n        }\n\n        if (!!config2) {\n            // allow users to set options using startRecording method\n            // config2 is similar to main \"config\" object (second parameter over RecordRTC constructor)\n            config = new RecordRTCConfiguration(mediaStream, config2);\n        }\n\n        if (!config.disableLogs) {\n            console.log('started recording ' + config.type + ' stream.');\n        }\n\n        if (mediaRecorder) {\n            mediaRecorder.clearRecordedData();\n            mediaRecorder.record();\n\n            setState('recording');\n\n            if (self.recordingDuration) {\n                handleRecordingDuration();\n            }\n            return self;\n        }\n\n        initRecorder(function() {\n            if (self.recordingDuration) {\n                handleRecordingDuration();\n            }\n        });\n\n        return self;\n    }\n\n    function initRecorder(initCallback) {\n        if (initCallback) {\n            config.initCallback = function() {\n                initCallback();\n                initCallback = config.initCallback = null; // recorder.initRecorder should be call-backed once.\n            };\n        }\n\n        var Recorder = new GetRecorderType(mediaStream, config);\n\n        mediaRecorder = new Recorder(mediaStream, config);\n        mediaRecorder.record();\n\n        setState('recording');\n\n        if (!config.disableLogs) {\n            console.log('Initialized recorderType:', mediaRecorder.constructor.name, 'for output-type:', config.type);\n        }\n    }\n\n    function stopRecording(callback) {\n        callback = callback || function() {};\n\n        if (!mediaRecorder) {\n            warningLog();\n            return;\n        }\n\n        if (self.state === 'paused') {\n            self.resumeRecording();\n\n            setTimeout(function() {\n                stopRecording(callback);\n            }, 1);\n            return;\n        }\n\n        if (self.state !== 'recording' && !config.disableLogs) {\n            console.warn('Recording state should be: \"recording\", however current state is: ', self.state);\n        }\n\n        if (!config.disableLogs) {\n            console.log('Stopped recording ' + config.type + ' stream.');\n        }\n\n        if (config.type !== 'gif') {\n            mediaRecorder.stop(_callback);\n        } else {\n            mediaRecorder.stop();\n            _callback();\n        }\n\n        setState('stopped');\n\n        function _callback(__blob) {\n            if (!mediaRecorder) {\n                if (typeof callback.call === 'function') {\n                    callback.call(self, '');\n                } else {\n                    callback('');\n                }\n                return;\n            }\n\n            Object.keys(mediaRecorder).forEach(function(key) {\n                if (typeof mediaRecorder[key] === 'function') {\n                    return;\n                }\n\n                self[key] = mediaRecorder[key];\n            });\n\n            var blob = mediaRecorder.blob;\n\n            if (!blob) {\n                if (__blob) {\n                    mediaRecorder.blob = blob = __blob;\n                } else {\n                    throw 'Recording failed.';\n                }\n            }\n\n            if (blob && !config.disableLogs) {\n                console.log(blob.type, '->', bytesToSize(blob.size));\n            }\n\n            if (callback) {\n                var url;\n\n                try {\n                    url = URL.createObjectURL(blob);\n                } catch (e) {}\n\n                if (typeof callback.call === 'function') {\n                    callback.call(self, url);\n                } else {\n                    callback(url);\n                }\n            }\n\n            if (!config.autoWriteToDisk) {\n                return;\n            }\n\n            getDataURL(function(dataURL) {\n                var parameter = {};\n                parameter[config.type + 'Blob'] = dataURL;\n                DiskStorage.Store(parameter);\n            });\n        }\n    }\n\n    function pauseRecording() {\n        if (!mediaRecorder) {\n            warningLog();\n            return;\n        }\n\n        if (self.state !== 'recording') {\n            if (!config.disableLogs) {\n                console.warn('Unable to pause the recording. Recording state: ', self.state);\n            }\n            return;\n        }\n\n        setState('paused');\n\n        mediaRecorder.pause();\n\n        if (!config.disableLogs) {\n            console.log('Paused recording.');\n        }\n    }\n\n    function resumeRecording() {\n        if (!mediaRecorder) {\n            warningLog();\n            return;\n        }\n\n        if (self.state !== 'paused') {\n            if (!config.disableLogs) {\n                console.warn('Unable to resume the recording. Recording state: ', self.state);\n            }\n            return;\n        }\n\n        setState('recording');\n\n        // not all libs have this method yet\n        mediaRecorder.resume();\n\n        if (!config.disableLogs) {\n            console.log('Resumed recording.');\n        }\n    }\n\n    function readFile(_blob) {\n        postMessage(new FileReaderSync().readAsDataURL(_blob));\n    }\n\n    function getDataURL(callback, _mediaRecorder) {\n        if (!callback) {\n            throw 'Pass a callback function over getDataURL.';\n        }\n\n        var blob = _mediaRecorder ? _mediaRecorder.blob : (mediaRecorder || {}).blob;\n\n        if (!blob) {\n            if (!config.disableLogs) {\n                console.warn('Blob encoder did not finish its job yet.');\n            }\n\n            setTimeout(function() {\n                getDataURL(callback, _mediaRecorder);\n            }, 1000);\n            return;\n        }\n\n        if (typeof Worker !== 'undefined' && !navigator.mozGetUserMedia) {\n            var webWorker = processInWebWorker(readFile);\n\n            webWorker.onmessage = function(event) {\n                callback(event.data);\n            };\n\n            webWorker.postMessage(blob);\n        } else {\n            var reader = new FileReader();\n            reader.readAsDataURL(blob);\n            reader.onload = function(event) {\n                callback(event.target.result);\n            };\n        }\n\n        function processInWebWorker(_function) {\n            try {\n                var blob = URL.createObjectURL(new Blob([_function.toString(),\n                    'this.onmessage =  function (eee) {' + _function.name + '(eee.data);}'\n                ], {\n                    type: 'application/javascript'\n                }));\n\n                var worker = new Worker(blob);\n                URL.revokeObjectURL(blob);\n                return worker;\n            } catch (e) {}\n        }\n    }\n\n    function handleRecordingDuration(counter) {\n        counter = counter || 0;\n\n        if (self.state === 'paused') {\n            setTimeout(function() {\n                handleRecordingDuration(counter);\n            }, 1000);\n            return;\n        }\n\n        if (self.state === 'stopped') {\n            return;\n        }\n\n        if (counter >= self.recordingDuration) {\n            stopRecording(self.onRecordingStopped);\n            return;\n        }\n\n        counter += 1000; // 1-second\n\n        setTimeout(function() {\n            handleRecordingDuration(counter);\n        }, 1000);\n    }\n\n    function setState(state) {\n        if (!self) {\n            return;\n        }\n\n        self.state = state;\n\n        if (typeof self.onStateChanged.call === 'function') {\n            self.onStateChanged.call(self, state);\n        } else {\n            self.onStateChanged(state);\n        }\n    }\n\n    var WARNING = 'It seems that recorder is destroyed or \"startRecording\" is not invoked for ' + config.type + ' recorder.';\n\n    function warningLog() {\n        if (config.disableLogs === true) {\n            return;\n        }\n\n        console.warn(WARNING);\n    }\n\n    var mediaRecorder;\n\n    var returnObject = {\n        /**\n         * This method starts the recording.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @example\n         * var recorder = RecordRTC(mediaStream, {\n         *     type: 'video'\n         * });\n         * recorder.startRecording();\n         */\n        startRecording: startRecording,\n\n        /**\n         * This method stops the recording. It is strongly recommended to get \"blob\" or \"URI\" inside the callback to make sure all recorders finished their job.\n         * @param {function} callback - Callback to get the recorded blob.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @example\n         * recorder.stopRecording(function() {\n         *     // use either \"this\" or \"recorder\" object; both are identical\n         *     video.src = this.toURL();\n         *     var blob = this.getBlob();\n         * });\n         */\n        stopRecording: stopRecording,\n\n        /**\n         * This method pauses the recording. You can resume recording using \"resumeRecording\" method.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @todo Firefox is unable to pause the recording. Fix it.\n         * @example\n         * recorder.pauseRecording();  // pause the recording\n         * recorder.resumeRecording(); // resume again\n         */\n        pauseRecording: pauseRecording,\n\n        /**\n         * This method resumes the recording.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @example\n         * recorder.pauseRecording();  // first of all, pause the recording\n         * recorder.resumeRecording(); // now resume it\n         */\n        resumeRecording: resumeRecording,\n\n        /**\n         * This method initializes the recording.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @todo This method should be deprecated.\n         * @example\n         * recorder.initRecorder();\n         */\n        initRecorder: initRecorder,\n\n        /**\n         * Ask RecordRTC to auto-stop the recording after 5 minutes.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @example\n         * var fiveMinutes = 5 * 1000 * 60;\n         * recorder.setRecordingDuration(fiveMinutes, function() {\n         *    var blob = this.getBlob();\n         *    video.src = this.toURL();\n         * });\n         * \n         * // or otherwise\n         * recorder.setRecordingDuration(fiveMinutes).onRecordingStopped(function() {\n         *    var blob = this.getBlob();\n         *    video.src = this.toURL();\n         * });\n         */\n        setRecordingDuration: function(recordingDuration, callback) {\n            if (typeof recordingDuration === 'undefined') {\n                throw 'recordingDuration is required.';\n            }\n\n            if (typeof recordingDuration !== 'number') {\n                throw 'recordingDuration must be a number.';\n            }\n\n            self.recordingDuration = recordingDuration;\n            self.onRecordingStopped = callback || function() {};\n\n            return {\n                onRecordingStopped: function(callback) {\n                    self.onRecordingStopped = callback;\n                }\n            };\n        },\n\n        /**\n         * This method can be used to clear/reset all the recorded data.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @todo Figure out the difference between \"reset\" and \"clearRecordedData\" methods.\n         * @example\n         * recorder.clearRecordedData();\n         */\n        clearRecordedData: function() {\n            if (!mediaRecorder) {\n                warningLog();\n                return;\n            }\n\n            mediaRecorder.clearRecordedData();\n\n            if (!config.disableLogs) {\n                console.log('Cleared old recorded data.');\n            }\n        },\n\n        /**\n         * Get the recorded blob. Use this method inside the \"stopRecording\" callback.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @example\n         * recorder.stopRecording(function() {\n         *     var blob = this.getBlob();\n         *\n         *     var file = new File([blob], 'filename.webm', {\n         *         type: 'video/webm'\n         *     });\n         *\n         *     var formData = new FormData();\n         *     formData.append('file', file); // upload \"File\" object rather than a \"Blob\"\n         *     uploadToServer(formData);\n         * });\n         * @returns {Blob} Returns recorded data as \"Blob\" object.\n         */\n        getBlob: function() {\n            if (!mediaRecorder) {\n                warningLog();\n                return;\n            }\n\n            return mediaRecorder.blob;\n        },\n\n        /**\n         * Get data-URI instead of Blob.\n         * @param {function} callback - Callback to get the Data-URI.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @example\n         * recorder.stopRecording(function() {\n         *     recorder.getDataURL(function(dataURI) {\n         *         video.src = dataURI;\n         *     });\n         * });\n         */\n        getDataURL: getDataURL,\n\n        /**\n         * Get virtual/temporary URL. Usage of this URL is limited to current tab.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @example\n         * recorder.stopRecording(function() {\n         *     video.src = this.toURL();\n         * });\n         * @returns {String} Returns a virtual/temporary URL for the recorded \"Blob\".\n         */\n        toURL: function() {\n            if (!mediaRecorder) {\n                warningLog();\n                return;\n            }\n\n            return URL.createObjectURL(mediaRecorder.blob);\n        },\n\n        /**\n         * Get internal recording object (i.e. internal module) e.g. MutliStreamRecorder, MediaStreamRecorder, StereoAudioRecorder or WhammyRecorder etc.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @example\n         * var internalRecorder = recorder.getInternalRecorder();\n         * if(internalRecorder instanceof MultiStreamRecorder) {\n         *     internalRecorder.addStreams([newAudioStream]);\n         *     internalRecorder.resetVideoStreams([screenStream]);\n         * }\n         * @returns {Object} Returns internal recording object.\n         */\n        getInternalRecorder: function() {\n            return mediaRecorder;\n        },\n\n        /**\n         * Invoke save-as dialog to save the recorded blob into your disk.\n         * @param {string} fileName - Set your own file name.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @example\n         * recorder.stopRecording(function() {\n         *     this.save('file-name');\n         *\n         *     // or manually:\n         *     invokeSaveAsDialog(this.getBlob(), 'filename.webm');\n         * });\n         */\n        save: function(fileName) {\n            if (!mediaRecorder) {\n                warningLog();\n                return;\n            }\n\n            invokeSaveAsDialog(mediaRecorder.blob, fileName);\n        },\n\n        /**\n         * This method gets a blob from indexed-DB storage.\n         * @param {function} callback - Callback to get the recorded blob.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @example\n         * recorder.getFromDisk(function(dataURL) {\n         *     video.src = dataURL;\n         * });\n         */\n        getFromDisk: function(callback) {\n            if (!mediaRecorder) {\n                warningLog();\n                return;\n            }\n\n            RecordRTC.getFromDisk(config.type, callback);\n        },\n\n        /**\n         * This method appends an array of webp images to the recorded video-blob. It takes an \"array\" object.\n         * @type {Array.<Array>}\n         * @param {Array} arrayOfWebPImages - Array of webp images.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @todo This method should be deprecated.\n         * @example\n         * var arrayOfWebPImages = [];\n         * arrayOfWebPImages.push({\n         *     duration: index,\n         *     image: 'data:image/webp;base64,...'\n         * });\n         * recorder.setAdvertisementArray(arrayOfWebPImages);\n         */\n        setAdvertisementArray: function(arrayOfWebPImages) {\n            config.advertisement = [];\n\n            var length = arrayOfWebPImages.length;\n            for (var i = 0; i < length; i++) {\n                config.advertisement.push({\n                    duration: i,\n                    image: arrayOfWebPImages[i]\n                });\n            }\n        },\n\n        /**\n         * It is equivalent to <code class=\"str\">\"recorder.getBlob()\"</code> method. Usage of \"getBlob\" is recommended, though.\n         * @property {Blob} blob - Recorded Blob can be accessed using this property.\n         * @memberof RecordRTC\n         * @instance\n         * @readonly\n         * @example\n         * recorder.stopRecording(function() {\n         *     var blob = this.blob;\n         *\n         *     // below one is recommended\n         *     var blob = this.getBlob();\n         * });\n         */\n        blob: null,\n\n        /**\n         * This works only with {recorderType:StereoAudioRecorder}. Use this property on \"stopRecording\" to verify the encoder's sample-rates.\n         * @property {number} bufferSize - Buffer-size used to encode the WAV container\n         * @memberof RecordRTC\n         * @instance\n         * @readonly\n         * @example\n         * recorder.stopRecording(function() {\n         *     alert('Recorder used this buffer-size: ' + this.bufferSize);\n         * });\n         */\n        bufferSize: 0,\n\n        /**\n         * This works only with {recorderType:StereoAudioRecorder}. Use this property on \"stopRecording\" to verify the encoder's sample-rates.\n         * @property {number} sampleRate - Sample-rates used to encode the WAV container\n         * @memberof RecordRTC\n         * @instance\n         * @readonly\n         * @example\n         * recorder.stopRecording(function() {\n         *     alert('Recorder used these sample-rates: ' + this.sampleRate);\n         * });\n         */\n        sampleRate: 0,\n\n        /**\n         * {recorderType:StereoAudioRecorder} returns ArrayBuffer object.\n         * @property {ArrayBuffer} buffer - Audio ArrayBuffer, supported only in Chrome.\n         * @memberof RecordRTC\n         * @instance\n         * @readonly\n         * @example\n         * recorder.stopRecording(function() {\n         *     var arrayBuffer = this.buffer;\n         *     alert(arrayBuffer.byteLength);\n         * });\n         */\n        buffer: null,\n\n        /**\n         * This method resets the recorder. So that you can reuse single recorder instance many times.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @example\n         * recorder.reset();\n         * recorder.startRecording();\n         */\n        reset: function() {\n            if (self.state === 'recording' && !config.disableLogs) {\n                console.warn('Stop an active recorder.');\n            }\n\n            if (mediaRecorder && typeof mediaRecorder.clearRecordedData === 'function') {\n                mediaRecorder.clearRecordedData();\n            }\n            mediaRecorder = null;\n            setState('inactive');\n            self.blob = null;\n        },\n\n        /**\n         * This method is called whenever recorder's state changes. Use this as an \"event\".\n         * @property {String} state - A recorder's state can be: recording, paused, stopped or inactive.\n         * @method\n         * @memberof RecordRTC\n         * @instance\n         * @example\n         * recorder.onStateChanged = function(state) {\n         *     console.log('Recorder state: ', state);\n         * };\n         */\n        onStateChanged: function(state) {\n            if (!config.disableLogs) {\n                console.log('Recorder state changed:', state);\n            }\n        },\n\n        /**\n         * A recorder can have inactive, recording, paused or stopped states.\n         * @property {String} state - A recorder's state can be: recording, paused, stopped or inactive.\n         * @memberof RecordRTC\n         * @static\n         * @readonly\n         * @example\n         * // this looper function will keep you updated about the recorder's states.\n         * (function looper() {\n         *     document.querySelector('h1').innerHTML = 'Recorder\\'s state is: ' + recorder.state;\n         *     if(recorder.state === 'stopped') return; // ignore+stop\n         *     setTimeout(looper, 1000); // update after every 3-seconds\n         * })();\n         * recorder.startRecording();\n         */\n        state: 'inactive',\n\n        /**\n         * Get recorder's readonly state.\n         * @method\n         * @memberof RecordRTC\n         * @example\n         * var state = recorder.getState();\n         * @returns {String} Returns recording state.\n         */\n        getState: function() {\n            return self.state;\n        },\n\n        /**\n         * Destroy RecordRTC instance. Clear all recorders and objects.\n         * @method\n         * @memberof RecordRTC\n         * @example\n         * recorder.destroy();\n         */\n        destroy: function() {\n            var disableLogsCache = config.disableLogs;\n\n            config = {\n                disableLogs: true\n            };\n            self.reset();\n            setState('destroyed');\n            returnObject = self = null;\n\n            if (Storage.AudioContextConstructor) {\n                Storage.AudioContextConstructor.close();\n                Storage.AudioContextConstructor = null;\n            }\n\n            config.disableLogs = disableLogsCache;\n\n            if (!config.disableLogs) {\n                console.log('RecordRTC is destroyed.');\n            }\n        },\n\n        /**\n         * RecordRTC version number\n         * @property {String} version - Release version number.\n         * @memberof RecordRTC\n         * @static\n         * @readonly\n         * @example\n         * alert(recorder.version);\n         */\n        version: '5.6.2'\n    };\n\n    if (!this) {\n        self = returnObject;\n        return returnObject;\n    }\n\n    // if someone wants to use RecordRTC with the \"new\" keyword.\n    for (var prop in returnObject) {\n        this[prop] = returnObject[prop];\n    }\n\n    self = this;\n\n    return returnObject;\n}\n\nRecordRTC.version = '5.6.2';\n\nif (typeof module !== 'undefined' /* && !!module.exports*/ ) {\n    module.exports = RecordRTC;\n}\n\nif (typeof define === 'function' && define.amd) {\n    define('RecordRTC', [], function() {\n        return RecordRTC;\n    });\n}\n\nRecordRTC.getFromDisk = function(type, callback) {\n    if (!callback) {\n        throw 'callback is mandatory.';\n    }\n\n    console.log('Getting recorded ' + (type === 'all' ? 'blobs' : type + ' blob ') + ' from disk!');\n    DiskStorage.Fetch(function(dataURL, _type) {\n        if (type !== 'all' && _type === type + 'Blob' && callback) {\n            callback(dataURL);\n        }\n\n        if (type === 'all' && callback) {\n            callback(dataURL, _type.replace('Blob', ''));\n        }\n    });\n};\n\n/**\n * This method can be used to store recorded blobs into IndexedDB storage.\n * @param {object} options - {audio: Blob, video: Blob, gif: Blob}\n * @method\n * @memberof RecordRTC\n * @example\n * RecordRTC.writeToDisk({\n *     audio: audioBlob,\n *     video: videoBlob,\n *     gif  : gifBlob\n * });\n */\nRecordRTC.writeToDisk = function(options) {\n    console.log('Writing recorded blob(s) to disk!');\n    options = options || {};\n    if (options.audio && options.video && options.gif) {\n        options.audio.getDataURL(function(audioDataURL) {\n            options.video.getDataURL(function(videoDataURL) {\n                options.gif.getDataURL(function(gifDataURL) {\n                    DiskStorage.Store({\n                        audioBlob: audioDataURL,\n                        videoBlob: videoDataURL,\n                        gifBlob: gifDataURL\n                    });\n                });\n            });\n        });\n    } else if (options.audio && options.video) {\n        options.audio.getDataURL(function(audioDataURL) {\n            options.video.getDataURL(function(videoDataURL) {\n                DiskStorage.Store({\n                    audioBlob: audioDataURL,\n                    videoBlob: videoDataURL\n                });\n            });\n        });\n    } else if (options.audio && options.gif) {\n        options.audio.getDataURL(function(audioDataURL) {\n            options.gif.getDataURL(function(gifDataURL) {\n                DiskStorage.Store({\n                    audioBlob: audioDataURL,\n                    gifBlob: gifDataURL\n                });\n            });\n        });\n    } else if (options.video && options.gif) {\n        options.video.getDataURL(function(videoDataURL) {\n            options.gif.getDataURL(function(gifDataURL) {\n                DiskStorage.Store({\n                    videoBlob: videoDataURL,\n                    gifBlob: gifDataURL\n                });\n            });\n        });\n    } else if (options.audio) {\n        options.audio.getDataURL(function(audioDataURL) {\n            DiskStorage.Store({\n                audioBlob: audioDataURL\n            });\n        });\n    } else if (options.video) {\n        options.video.getDataURL(function(videoDataURL) {\n            DiskStorage.Store({\n                videoBlob: videoDataURL\n            });\n        });\n    } else if (options.gif) {\n        options.gif.getDataURL(function(gifDataURL) {\n            DiskStorage.Store({\n                gifBlob: gifDataURL\n            });\n        });\n    }\n};\n\n// __________________________\n// RecordRTC-Configuration.js\n\n/**\n * {@link RecordRTCConfiguration} is an inner/private helper for {@link RecordRTC}.\n * @summary It configures the 2nd parameter passed over {@link RecordRTC} and returns a valid \"config\" object.\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @typedef RecordRTCConfiguration\n * @class\n * @example\n * var options = RecordRTCConfiguration(mediaStream, options);\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\n * @param {object} config - {type:\"video\", disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, getNativeBlob:true, etc.}\n */\n\nfunction RecordRTCConfiguration(mediaStream, config) {\n    if (!config.recorderType && !config.type) {\n        if (!!config.audio && !!config.video) {\n            config.type = 'video';\n        } else if (!!config.audio && !config.video) {\n            config.type = 'audio';\n        }\n    }\n\n    if (config.recorderType && !config.type) {\n        if (config.recorderType === WhammyRecorder || config.recorderType === CanvasRecorder || (typeof WebAssemblyRecorder !== 'undefined' && config.recorderType === WebAssemblyRecorder)) {\n            config.type = 'video';\n        } else if (config.recorderType === GifRecorder) {\n            config.type = 'gif';\n        } else if (config.recorderType === StereoAudioRecorder) {\n            config.type = 'audio';\n        } else if (config.recorderType === MediaStreamRecorder) {\n            if (getTracks(mediaStream, 'audio').length && getTracks(mediaStream, 'video').length) {\n                config.type = 'video';\n            } else if (!getTracks(mediaStream, 'audio').length && getTracks(mediaStream, 'video').length) {\n                config.type = 'video';\n            } else if (getTracks(mediaStream, 'audio').length && !getTracks(mediaStream, 'video').length) {\n                config.type = 'audio';\n            } else {\n                // config.type = 'UnKnown';\n            }\n        }\n    }\n\n    if (typeof MediaStreamRecorder !== 'undefined' && typeof MediaRecorder !== 'undefined' && 'requestData' in MediaRecorder.prototype) {\n        if (!config.mimeType) {\n            config.mimeType = 'video/webm';\n        }\n\n        if (!config.type) {\n            config.type = config.mimeType.split('/')[0];\n        }\n\n        if (!config.bitsPerSecond) {\n            // config.bitsPerSecond = 128000;\n        }\n    }\n\n    // consider default type=audio\n    if (!config.type) {\n        if (config.mimeType) {\n            config.type = config.mimeType.split('/')[0];\n        }\n        if (!config.type) {\n            config.type = 'audio';\n        }\n    }\n\n    return config;\n}\n\n// __________________\n// GetRecorderType.js\n\n/**\n * {@link GetRecorderType} is an inner/private helper for {@link RecordRTC}.\n * @summary It returns best recorder-type available for your browser.\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @typedef GetRecorderType\n * @class\n * @example\n * var RecorderType = GetRecorderType(options);\n * var recorder = new RecorderType(options);\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\n * @param {object} config - {type:\"video\", disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, etc.}\n */\n\nfunction GetRecorderType(mediaStream, config) {\n    var recorder;\n\n    // StereoAudioRecorder can work with all three: Edge, Firefox and Chrome\n    // todo: detect if it is Edge, then auto use: StereoAudioRecorder\n    if (isChrome || isEdge || isOpera) {\n        // Media Stream Recording API has not been implemented in chrome yet;\n        // That's why using WebAudio API to record stereo audio in WAV format\n        recorder = StereoAudioRecorder;\n    }\n\n    if (typeof MediaRecorder !== 'undefined' && 'requestData' in MediaRecorder.prototype && !isChrome) {\n        recorder = MediaStreamRecorder;\n    }\n\n    // video recorder (in WebM format)\n    if (config.type === 'video' && (isChrome || isOpera)) {\n        recorder = WhammyRecorder;\n\n        if (typeof WebAssemblyRecorder !== 'undefined' && typeof ReadableStream !== 'undefined') {\n            recorder = WebAssemblyRecorder;\n        }\n    }\n\n    // video recorder (in Gif format)\n    if (config.type === 'gif') {\n        recorder = GifRecorder;\n    }\n\n    // html2canvas recording!\n    if (config.type === 'canvas') {\n        recorder = CanvasRecorder;\n    }\n\n    if (isMediaRecorderCompatible() && recorder !== CanvasRecorder && recorder !== GifRecorder && typeof MediaRecorder !== 'undefined' && 'requestData' in MediaRecorder.prototype) {\n        if (getTracks(mediaStream, 'video').length || getTracks(mediaStream, 'audio').length) {\n            // audio-only recording\n            if (config.type === 'audio') {\n                if (typeof MediaRecorder.isTypeSupported === 'function' && MediaRecorder.isTypeSupported('audio/webm')) {\n                    recorder = MediaStreamRecorder;\n                }\n                // else recorder = StereoAudioRecorder;\n            } else {\n                // video or screen tracks\n                if (typeof MediaRecorder.isTypeSupported === 'function' && MediaRecorder.isTypeSupported('video/webm')) {\n                    recorder = MediaStreamRecorder;\n                }\n            }\n        }\n    }\n\n    if (mediaStream instanceof Array && mediaStream.length) {\n        recorder = MultiStreamRecorder;\n    }\n\n    if (config.recorderType) {\n        recorder = config.recorderType;\n    }\n\n    if (!config.disableLogs && !!recorder && !!recorder.name) {\n        console.log('Using recorderType:', recorder.name || recorder.constructor.name);\n    }\n\n    if (!recorder && isSafari) {\n        recorder = MediaStreamRecorder;\n    }\n\n    return recorder;\n}\n\n// _____________\n// MRecordRTC.js\n\n/**\n * MRecordRTC runs on top of {@link RecordRTC} to bring multiple recordings in a single place, by providing simple API.\n * @summary MRecordRTC stands for \"Multiple-RecordRTC\".\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @typedef MRecordRTC\n * @class\n * @example\n * var recorder = new MRecordRTC();\n * recorder.addStream(MediaStream);\n * recorder.mediaType = {\n *     audio: true, // or StereoAudioRecorder or MediaStreamRecorder\n *     video: true, // or WhammyRecorder or MediaStreamRecorder or WebAssemblyRecorder or CanvasRecorder\n *     gif: true    // or GifRecorder\n * };\n * // mimeType is optional and should be set only in advance cases.\n * recorder.mimeType = {\n *     audio: 'audio/wav',\n *     video: 'video/webm',\n *     gif:   'image/gif'\n * };\n * recorder.startRecording();\n * @see For further information:\n * @see {@link https://github.com/muaz-khan/RecordRTC/tree/master/MRecordRTC|MRecordRTC Source Code}\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\n * @requires {@link RecordRTC}\n */\n\nfunction MRecordRTC(mediaStream) {\n\n    /**\n     * This method attaches MediaStream object to {@link MRecordRTC}.\n     * @param {MediaStream} mediaStream - A MediaStream object, either fetched using getUserMedia API, or generated using captureStreamUntilEnded or WebAudio API.\n     * @method\n     * @memberof MRecordRTC\n     * @example\n     * recorder.addStream(MediaStream);\n     */\n    this.addStream = function(_mediaStream) {\n        if (_mediaStream) {\n            mediaStream = _mediaStream;\n        }\n    };\n\n    /**\n     * This property can be used to set the recording type e.g. audio, or video, or gif, or canvas.\n     * @property {object} mediaType - {audio: true, video: true, gif: true}\n     * @memberof MRecordRTC\n     * @example\n     * var recorder = new MRecordRTC();\n     * recorder.mediaType = {\n     *     audio: true, // TRUE or StereoAudioRecorder or MediaStreamRecorder\n     *     video: true, // TRUE or WhammyRecorder or MediaStreamRecorder or WebAssemblyRecorder or CanvasRecorder\n     *     gif  : true  // TRUE or GifRecorder\n     * };\n     */\n    this.mediaType = {\n        audio: true,\n        video: true\n    };\n\n    /**\n     * This method starts recording.\n     * @method\n     * @memberof MRecordRTC\n     * @example\n     * recorder.startRecording();\n     */\n    this.startRecording = function() {\n        var mediaType = this.mediaType;\n        var recorderType;\n        var mimeType = this.mimeType || {\n            audio: null,\n            video: null,\n            gif: null\n        };\n\n        if (typeof mediaType.audio !== 'function' && isMediaRecorderCompatible() && !getTracks(mediaStream, 'audio').length) {\n            mediaType.audio = false;\n        }\n\n        if (typeof mediaType.video !== 'function' && isMediaRecorderCompatible() && !getTracks(mediaStream, 'video').length) {\n            mediaType.video = false;\n        }\n\n        if (typeof mediaType.gif !== 'function' && isMediaRecorderCompatible() && !getTracks(mediaStream, 'video').length) {\n            mediaType.gif = false;\n        }\n\n        if (!mediaType.audio && !mediaType.video && !mediaType.gif) {\n            throw 'MediaStream must have either audio or video tracks.';\n        }\n\n        if (!!mediaType.audio) {\n            recorderType = null;\n            if (typeof mediaType.audio === 'function') {\n                recorderType = mediaType.audio;\n            }\n\n            this.audioRecorder = new RecordRTC(mediaStream, {\n                type: 'audio',\n                bufferSize: this.bufferSize,\n                sampleRate: this.sampleRate,\n                numberOfAudioChannels: this.numberOfAudioChannels || 2,\n                disableLogs: this.disableLogs,\n                recorderType: recorderType,\n                mimeType: mimeType.audio,\n                timeSlice: this.timeSlice,\n                onTimeStamp: this.onTimeStamp\n            });\n\n            if (!mediaType.video) {\n                this.audioRecorder.startRecording();\n            }\n        }\n\n        if (!!mediaType.video) {\n            recorderType = null;\n            if (typeof mediaType.video === 'function') {\n                recorderType = mediaType.video;\n            }\n\n            var newStream = mediaStream;\n\n            if (isMediaRecorderCompatible() && !!mediaType.audio && typeof mediaType.audio === 'function') {\n                var videoTrack = getTracks(mediaStream, 'video')[0];\n\n                if (isFirefox) {\n                    newStream = new MediaStream();\n                    newStream.addTrack(videoTrack);\n\n                    if (recorderType && recorderType === WhammyRecorder) {\n                        // Firefox does NOT supports webp-encoding yet\n                        // But Firefox do supports WebAssemblyRecorder\n                        recorderType = MediaStreamRecorder;\n                    }\n                } else {\n                    newStream = new MediaStream();\n                    newStream.addTrack(videoTrack);\n                }\n            }\n\n            this.videoRecorder = new RecordRTC(newStream, {\n                type: 'video',\n                video: this.video,\n                canvas: this.canvas,\n                frameInterval: this.frameInterval || 10,\n                disableLogs: this.disableLogs,\n                recorderType: recorderType,\n                mimeType: mimeType.video,\n                timeSlice: this.timeSlice,\n                onTimeStamp: this.onTimeStamp,\n                workerPath: this.workerPath,\n                webAssemblyPath: this.webAssemblyPath,\n                frameRate: this.frameRate, // used by WebAssemblyRecorder; values: usually 30; accepts any.\n                bitrate: this.bitrate // used by WebAssemblyRecorder; values: 0 to 1000+\n            });\n\n            if (!mediaType.audio) {\n                this.videoRecorder.startRecording();\n            }\n        }\n\n        if (!!mediaType.audio && !!mediaType.video) {\n            var self = this;\n\n            var isSingleRecorder = isMediaRecorderCompatible() === true;\n\n            if (mediaType.audio instanceof StereoAudioRecorder && !!mediaType.video) {\n                isSingleRecorder = false;\n            } else if (mediaType.audio !== true && mediaType.video !== true && mediaType.audio !== mediaType.video) {\n                isSingleRecorder = false;\n            }\n\n            if (isSingleRecorder === true) {\n                self.audioRecorder = null;\n                self.videoRecorder.startRecording();\n            } else {\n                self.videoRecorder.initRecorder(function() {\n                    self.audioRecorder.initRecorder(function() {\n                        // Both recorders are ready to record things accurately\n                        self.videoRecorder.startRecording();\n                        self.audioRecorder.startRecording();\n                    });\n                });\n            }\n        }\n\n        if (!!mediaType.gif) {\n            recorderType = null;\n            if (typeof mediaType.gif === 'function') {\n                recorderType = mediaType.gif;\n            }\n            this.gifRecorder = new RecordRTC(mediaStream, {\n                type: 'gif',\n                frameRate: this.frameRate || 200,\n                quality: this.quality || 10,\n                disableLogs: this.disableLogs,\n                recorderType: recorderType,\n                mimeType: mimeType.gif\n            });\n            this.gifRecorder.startRecording();\n        }\n    };\n\n    /**\n     * This method stops recording.\n     * @param {function} callback - Callback function is invoked when all encoders finished their jobs.\n     * @method\n     * @memberof MRecordRTC\n     * @example\n     * recorder.stopRecording(function(recording){\n     *     var audioBlob = recording.audio;\n     *     var videoBlob = recording.video;\n     *     var gifBlob   = recording.gif;\n     * });\n     */\n    this.stopRecording = function(callback) {\n        callback = callback || function() {};\n\n        if (this.audioRecorder) {\n            this.audioRecorder.stopRecording(function(blobURL) {\n                callback(blobURL, 'audio');\n            });\n        }\n\n        if (this.videoRecorder) {\n            this.videoRecorder.stopRecording(function(blobURL) {\n                callback(blobURL, 'video');\n            });\n        }\n\n        if (this.gifRecorder) {\n            this.gifRecorder.stopRecording(function(blobURL) {\n                callback(blobURL, 'gif');\n            });\n        }\n    };\n\n    /**\n     * This method pauses recording.\n     * @method\n     * @memberof MRecordRTC\n     * @example\n     * recorder.pauseRecording();\n     */\n    this.pauseRecording = function() {\n        if (this.audioRecorder) {\n            this.audioRecorder.pauseRecording();\n        }\n\n        if (this.videoRecorder) {\n            this.videoRecorder.pauseRecording();\n        }\n\n        if (this.gifRecorder) {\n            this.gifRecorder.pauseRecording();\n        }\n    };\n\n    /**\n     * This method resumes recording.\n     * @method\n     * @memberof MRecordRTC\n     * @example\n     * recorder.resumeRecording();\n     */\n    this.resumeRecording = function() {\n        if (this.audioRecorder) {\n            this.audioRecorder.resumeRecording();\n        }\n\n        if (this.videoRecorder) {\n            this.videoRecorder.resumeRecording();\n        }\n\n        if (this.gifRecorder) {\n            this.gifRecorder.resumeRecording();\n        }\n    };\n\n    /**\n     * This method can be used to manually get all recorded blobs.\n     * @param {function} callback - All recorded blobs are passed back to the \"callback\" function.\n     * @method\n     * @memberof MRecordRTC\n     * @example\n     * recorder.getBlob(function(recording){\n     *     var audioBlob = recording.audio;\n     *     var videoBlob = recording.video;\n     *     var gifBlob   = recording.gif;\n     * });\n     * // or\n     * var audioBlob = recorder.getBlob().audio;\n     * var videoBlob = recorder.getBlob().video;\n     */\n    this.getBlob = function(callback) {\n        var output = {};\n\n        if (this.audioRecorder) {\n            output.audio = this.audioRecorder.getBlob();\n        }\n\n        if (this.videoRecorder) {\n            output.video = this.videoRecorder.getBlob();\n        }\n\n        if (this.gifRecorder) {\n            output.gif = this.gifRecorder.getBlob();\n        }\n\n        if (callback) {\n            callback(output);\n        }\n\n        return output;\n    };\n\n    /**\n     * Destroy all recorder instances.\n     * @method\n     * @memberof MRecordRTC\n     * @example\n     * recorder.destroy();\n     */\n    this.destroy = function() {\n        if (this.audioRecorder) {\n            this.audioRecorder.destroy();\n            this.audioRecorder = null;\n        }\n\n        if (this.videoRecorder) {\n            this.videoRecorder.destroy();\n            this.videoRecorder = null;\n        }\n\n        if (this.gifRecorder) {\n            this.gifRecorder.destroy();\n            this.gifRecorder = null;\n        }\n    };\n\n    /**\n     * This method can be used to manually get all recorded blobs' DataURLs.\n     * @param {function} callback - All recorded blobs' DataURLs are passed back to the \"callback\" function.\n     * @method\n     * @memberof MRecordRTC\n     * @example\n     * recorder.getDataURL(function(recording){\n     *     var audioDataURL = recording.audio;\n     *     var videoDataURL = recording.video;\n     *     var gifDataURL   = recording.gif;\n     * });\n     */\n    this.getDataURL = function(callback) {\n        this.getBlob(function(blob) {\n            if (blob.audio && blob.video) {\n                getDataURL(blob.audio, function(_audioDataURL) {\n                    getDataURL(blob.video, function(_videoDataURL) {\n                        callback({\n                            audio: _audioDataURL,\n                            video: _videoDataURL\n                        });\n                    });\n                });\n            } else if (blob.audio) {\n                getDataURL(blob.audio, function(_audioDataURL) {\n                    callback({\n                        audio: _audioDataURL\n                    });\n                });\n            } else if (blob.video) {\n                getDataURL(blob.video, function(_videoDataURL) {\n                    callback({\n                        video: _videoDataURL\n                    });\n                });\n            }\n        });\n\n        function getDataURL(blob, callback00) {\n            if (typeof Worker !== 'undefined') {\n                var webWorker = processInWebWorker(function readFile(_blob) {\n                    postMessage(new FileReaderSync().readAsDataURL(_blob));\n                });\n\n                webWorker.onmessage = function(event) {\n                    callback00(event.data);\n                };\n\n                webWorker.postMessage(blob);\n            } else {\n                var reader = new FileReader();\n                reader.readAsDataURL(blob);\n                reader.onload = function(event) {\n                    callback00(event.target.result);\n                };\n            }\n        }\n\n        function processInWebWorker(_function) {\n            var blob = URL.createObjectURL(new Blob([_function.toString(),\n                'this.onmessage =  function (eee) {' + _function.name + '(eee.data);}'\n            ], {\n                type: 'application/javascript'\n            }));\n\n            var worker = new Worker(blob);\n            var url;\n            if (typeof URL !== 'undefined') {\n                url = URL;\n            } else if (typeof webkitURL !== 'undefined') {\n                url = webkitURL;\n            } else {\n                throw 'Neither URL nor webkitURL detected.';\n            }\n            url.revokeObjectURL(blob);\n            return worker;\n        }\n    };\n\n    /**\n     * This method can be used to ask {@link MRecordRTC} to write all recorded blobs into IndexedDB storage.\n     * @method\n     * @memberof MRecordRTC\n     * @example\n     * recorder.writeToDisk();\n     */\n    this.writeToDisk = function() {\n        RecordRTC.writeToDisk({\n            audio: this.audioRecorder,\n            video: this.videoRecorder,\n            gif: this.gifRecorder\n        });\n    };\n\n    /**\n     * This method can be used to invoke a save-as dialog for all recorded blobs.\n     * @param {object} args - {audio: 'audio-name', video: 'video-name', gif: 'gif-name'}\n     * @method\n     * @memberof MRecordRTC\n     * @example\n     * recorder.save({\n     *     audio: 'audio-file-name',\n     *     video: 'video-file-name',\n     *     gif  : 'gif-file-name'\n     * });\n     */\n    this.save = function(args) {\n        args = args || {\n            audio: true,\n            video: true,\n            gif: true\n        };\n\n        if (!!args.audio && this.audioRecorder) {\n            this.audioRecorder.save(typeof args.audio === 'string' ? args.audio : '');\n        }\n\n        if (!!args.video && this.videoRecorder) {\n            this.videoRecorder.save(typeof args.video === 'string' ? args.video : '');\n        }\n        if (!!args.gif && this.gifRecorder) {\n            this.gifRecorder.save(typeof args.gif === 'string' ? args.gif : '');\n        }\n    };\n}\n\n/**\n * This method can be used to get all recorded blobs from IndexedDB storage.\n * @param {string} type - 'all' or 'audio' or 'video' or 'gif'\n * @param {function} callback - Callback function to get all stored blobs.\n * @method\n * @memberof MRecordRTC\n * @example\n * MRecordRTC.getFromDisk('all', function(dataURL, type){\n *     if(type === 'audio') { }\n *     if(type === 'video') { }\n *     if(type === 'gif')   { }\n * });\n */\nMRecordRTC.getFromDisk = RecordRTC.getFromDisk;\n\n/**\n * This method can be used to store recorded blobs into IndexedDB storage.\n * @param {object} options - {audio: Blob, video: Blob, gif: Blob}\n * @method\n * @memberof MRecordRTC\n * @example\n * MRecordRTC.writeToDisk({\n *     audio: audioBlob,\n *     video: videoBlob,\n *     gif  : gifBlob\n * });\n */\nMRecordRTC.writeToDisk = RecordRTC.writeToDisk;\n\nif (typeof RecordRTC !== 'undefined') {\n    RecordRTC.MRecordRTC = MRecordRTC;\n}\n\nvar browserFakeUserAgent = 'Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45';\n\n(function(that) {\n    if (!that) {\n        return;\n    }\n\n    if (typeof window !== 'undefined') {\n        return;\n    }\n\n    if (typeof global === 'undefined') {\n        return;\n    }\n\n    global.navigator = {\n        userAgent: browserFakeUserAgent,\n        getUserMedia: function() {}\n    };\n\n    if (!global.console) {\n        global.console = {};\n    }\n\n    if (typeof global.console.log === 'undefined' || typeof global.console.error === 'undefined') {\n        global.console.error = global.console.log = global.console.log || function() {\n            console.log(arguments);\n        };\n    }\n\n    if (typeof document === 'undefined') {\n        /*global document:true */\n        that.document = {\n            documentElement: {\n                appendChild: function() {\n                    return '';\n                }\n            }\n        };\n\n        document.createElement = document.captureStream = document.mozCaptureStream = function() {\n            var obj = {\n                getContext: function() {\n                    return obj;\n                },\n                play: function() {},\n                pause: function() {},\n                drawImage: function() {},\n                toDataURL: function() {\n                    return '';\n                },\n                style: {}\n            };\n            return obj;\n        };\n\n        that.HTMLVideoElement = function() {};\n    }\n\n    if (typeof location === 'undefined') {\n        /*global location:true */\n        that.location = {\n            protocol: 'file:',\n            href: '',\n            hash: ''\n        };\n    }\n\n    if (typeof screen === 'undefined') {\n        /*global screen:true */\n        that.screen = {\n            width: 0,\n            height: 0\n        };\n    }\n\n    if (typeof URL === 'undefined') {\n        /*global screen:true */\n        that.URL = {\n            createObjectURL: function() {\n                return '';\n            },\n            revokeObjectURL: function() {\n                return '';\n            }\n        };\n    }\n\n    /*global window:true */\n    that.window = global;\n})(typeof global !== 'undefined' ? global : null);\n\n// _____________________________\n// Cross-Browser-Declarations.js\n\n// animation-frame used in WebM recording\n\n/*jshint -W079 */\nvar requestAnimationFrame = window.requestAnimationFrame;\nif (typeof requestAnimationFrame === 'undefined') {\n    if (typeof webkitRequestAnimationFrame !== 'undefined') {\n        /*global requestAnimationFrame:true */\n        requestAnimationFrame = webkitRequestAnimationFrame;\n    } else if (typeof mozRequestAnimationFrame !== 'undefined') {\n        /*global requestAnimationFrame:true */\n        requestAnimationFrame = mozRequestAnimationFrame;\n    } else if (typeof msRequestAnimationFrame !== 'undefined') {\n        /*global requestAnimationFrame:true */\n        requestAnimationFrame = msRequestAnimationFrame;\n    } else if (typeof requestAnimationFrame === 'undefined') {\n        // via: https://gist.github.com/paulirish/1579671\n        var lastTime = 0;\n\n        /*global requestAnimationFrame:true */\n        requestAnimationFrame = function(callback, element) {\n            var currTime = new Date().getTime();\n            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n            var id = setTimeout(function() {\n                callback(currTime + timeToCall);\n            }, timeToCall);\n            lastTime = currTime + timeToCall;\n            return id;\n        };\n    }\n}\n\n/*jshint -W079 */\nvar cancelAnimationFrame = window.cancelAnimationFrame;\nif (typeof cancelAnimationFrame === 'undefined') {\n    if (typeof webkitCancelAnimationFrame !== 'undefined') {\n        /*global cancelAnimationFrame:true */\n        cancelAnimationFrame = webkitCancelAnimationFrame;\n    } else if (typeof mozCancelAnimationFrame !== 'undefined') {\n        /*global cancelAnimationFrame:true */\n        cancelAnimationFrame = mozCancelAnimationFrame;\n    } else if (typeof msCancelAnimationFrame !== 'undefined') {\n        /*global cancelAnimationFrame:true */\n        cancelAnimationFrame = msCancelAnimationFrame;\n    } else if (typeof cancelAnimationFrame === 'undefined') {\n        /*global cancelAnimationFrame:true */\n        cancelAnimationFrame = function(id) {\n            clearTimeout(id);\n        };\n    }\n}\n\n// WebAudio API representer\nvar AudioContext = window.AudioContext;\n\nif (typeof AudioContext === 'undefined') {\n    if (typeof webkitAudioContext !== 'undefined') {\n        /*global AudioContext:true */\n        AudioContext = webkitAudioContext;\n    }\n\n    if (typeof mozAudioContext !== 'undefined') {\n        /*global AudioContext:true */\n        AudioContext = mozAudioContext;\n    }\n}\n\n/*jshint -W079 */\nvar URL = window.URL;\n\nif (typeof URL === 'undefined' && typeof webkitURL !== 'undefined') {\n    /*global URL:true */\n    URL = webkitURL;\n}\n\nif (typeof navigator !== 'undefined' && typeof navigator.getUserMedia === 'undefined') { // maybe window.navigator?\n    if (typeof navigator.webkitGetUserMedia !== 'undefined') {\n        navigator.getUserMedia = navigator.webkitGetUserMedia;\n    }\n\n    if (typeof navigator.mozGetUserMedia !== 'undefined') {\n        navigator.getUserMedia = navigator.mozGetUserMedia;\n    }\n}\n\nvar isEdge = navigator.userAgent.indexOf('Edge') !== -1 && (!!navigator.msSaveBlob || !!navigator.msSaveOrOpenBlob);\nvar isOpera = !!window.opera || navigator.userAgent.indexOf('OPR/') !== -1;\nvar isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1 && ('netscape' in window) && / rv:/.test(navigator.userAgent);\nvar isChrome = (!isOpera && !isEdge && !!navigator.webkitGetUserMedia) || isElectron() || navigator.userAgent.toLowerCase().indexOf('chrome/') !== -1;\n\nvar isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n\nif (isSafari && !isChrome && navigator.userAgent.indexOf('CriOS') !== -1) {\n    isSafari = false;\n    isChrome = true;\n}\n\nvar MediaStream = window.MediaStream;\n\nif (typeof MediaStream === 'undefined' && typeof webkitMediaStream !== 'undefined') {\n    MediaStream = webkitMediaStream;\n}\n\n/*global MediaStream:true */\nif (typeof MediaStream !== 'undefined') {\n    // override \"stop\" method for all browsers\n    if (typeof MediaStream.prototype.stop === 'undefined') {\n        MediaStream.prototype.stop = function() {\n            this.getTracks().forEach(function(track) {\n                track.stop();\n            });\n        };\n    }\n}\n\n// below function via: http://goo.gl/B3ae8c\n/**\n * Return human-readable file size.\n * @param {number} bytes - Pass bytes and get formatted string.\n * @returns {string} - formatted string\n * @example\n * bytesToSize(1024*1024*5) === '5 GB'\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n */\nfunction bytesToSize(bytes) {\n    var k = 1000;\n    var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n    if (bytes === 0) {\n        return '0 Bytes';\n    }\n    var i = parseInt(Math.floor(Math.log(bytes) / Math.log(k)), 10);\n    return (bytes / Math.pow(k, i)).toPrecision(3) + ' ' + sizes[i];\n}\n\n/**\n * @param {Blob} file - File or Blob object. This parameter is required.\n * @param {string} fileName - Optional file name e.g. \"Recorded-Video.webm\"\n * @example\n * invokeSaveAsDialog(blob or file, [optional] fileName);\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n */\nfunction invokeSaveAsDialog(file, fileName) {\n    if (!file) {\n        throw 'Blob object is required.';\n    }\n\n    if (!file.type) {\n        try {\n            file.type = 'video/webm';\n        } catch (e) {}\n    }\n\n    var fileExtension = (file.type || 'video/webm').split('/')[1];\n    if (fileExtension.indexOf(';') !== -1) {\n        // extended mimetype, e.g. 'video/webm;codecs=vp8,opus'\n        fileExtension = fileExtension.split(';')[0];\n    }\n    if (fileName && fileName.indexOf('.') !== -1) {\n        var splitted = fileName.split('.');\n        fileName = splitted[0];\n        fileExtension = splitted[1];\n    }\n\n    var fileFullName = (fileName || (Math.round(Math.random() * 9999999999) + 888888888)) + '.' + fileExtension;\n\n    if (typeof navigator.msSaveOrOpenBlob !== 'undefined') {\n        return navigator.msSaveOrOpenBlob(file, fileFullName);\n    } else if (typeof navigator.msSaveBlob !== 'undefined') {\n        return navigator.msSaveBlob(file, fileFullName);\n    }\n\n    var hyperlink = document.createElement('a');\n    hyperlink.href = URL.createObjectURL(file);\n    hyperlink.download = fileFullName;\n\n    hyperlink.style = 'display:none;opacity:0;color:transparent;';\n    (document.body || document.documentElement).appendChild(hyperlink);\n\n    if (typeof hyperlink.click === 'function') {\n        hyperlink.click();\n    } else {\n        hyperlink.target = '_blank';\n        hyperlink.dispatchEvent(new MouseEvent('click', {\n            view: window,\n            bubbles: true,\n            cancelable: true\n        }));\n    }\n\n    URL.revokeObjectURL(hyperlink.href);\n}\n\n/**\n * from: https://github.com/cheton/is-electron/blob/master/index.js\n **/\nfunction isElectron() {\n    // Renderer process\n    if (typeof window !== 'undefined' && typeof window.process === 'object' && window.process.type === 'renderer') {\n        return true;\n    }\n\n    // Main process\n    if (typeof process !== 'undefined' && typeof process.versions === 'object' && !!process.versions.electron) {\n        return true;\n    }\n\n    // Detect the user agent when the `nodeIntegration` option is set to true\n    if (typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent.indexOf('Electron') >= 0) {\n        return true;\n    }\n\n    return false;\n}\n\nfunction getTracks(stream, kind) {\n    if (!stream || !stream.getTracks) {\n        return [];\n    }\n\n    return stream.getTracks().filter(function(t) {\n        return t.kind === (kind || 'audio');\n    });\n}\n\nfunction setSrcObject(stream, element) {\n    if ('srcObject' in element) {\n        element.srcObject = stream;\n    } else if ('mozSrcObject' in element) {\n        element.mozSrcObject = stream;\n    } else {\n        element.srcObject = stream;\n    }\n}\n\n/**\n * @param {Blob} file - File or Blob object.\n * @param {function} callback - Callback function.\n * @example\n * getSeekableBlob(blob or file, callback);\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n */\nfunction getSeekableBlob(inputBlob, callback) {\n    // EBML.js copyrights goes to: https://github.com/legokichi/ts-ebml\n    if (typeof EBML === 'undefined') {\n        throw new Error('Please link: https://www.webrtc-experiment.com/EBML.js');\n    }\n\n    var reader = new EBML.Reader();\n    var decoder = new EBML.Decoder();\n    var tools = EBML.tools;\n\n    var fileReader = new FileReader();\n    fileReader.onload = function(e) {\n        var ebmlElms = decoder.decode(this.result);\n        ebmlElms.forEach(function(element) {\n            reader.read(element);\n        });\n        reader.stop();\n        var refinedMetadataBuf = tools.makeMetadataSeekable(reader.metadatas, reader.duration, reader.cues);\n        var body = this.result.slice(reader.metadataSize);\n        var newBlob = new Blob([refinedMetadataBuf, body], {\n            type: 'video/webm'\n        });\n\n        callback(newBlob);\n    };\n    fileReader.readAsArrayBuffer(inputBlob);\n}\n\nif (typeof RecordRTC !== 'undefined') {\n    RecordRTC.invokeSaveAsDialog = invokeSaveAsDialog;\n    RecordRTC.getTracks = getTracks;\n    RecordRTC.getSeekableBlob = getSeekableBlob;\n    RecordRTC.bytesToSize = bytesToSize;\n    RecordRTC.isElectron = isElectron;\n}\n\n// __________ (used to handle stuff like http://goo.gl/xmE5eg) issue #129\n// Storage.js\n\n/**\n * Storage is a standalone object used by {@link RecordRTC} to store reusable objects e.g. \"new AudioContext\".\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @example\n * Storage.AudioContext === webkitAudioContext\n * @property {webkitAudioContext} AudioContext - Keeps a reference to AudioContext object.\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n */\n\nvar Storage = {};\n\nif (typeof AudioContext !== 'undefined') {\n    Storage.AudioContext = AudioContext;\n} else if (typeof webkitAudioContext !== 'undefined') {\n    Storage.AudioContext = webkitAudioContext;\n}\n\nif (typeof RecordRTC !== 'undefined') {\n    RecordRTC.Storage = Storage;\n}\n\nfunction isMediaRecorderCompatible() {\n    if (isFirefox || isSafari || isEdge) {\n        return true;\n    }\n\n    var nVer = navigator.appVersion;\n    var nAgt = navigator.userAgent;\n    var fullVersion = '' + parseFloat(navigator.appVersion);\n    var majorVersion = parseInt(navigator.appVersion, 10);\n    var nameOffset, verOffset, ix;\n\n    if (isChrome || isOpera) {\n        verOffset = nAgt.indexOf('Chrome');\n        fullVersion = nAgt.substring(verOffset + 7);\n    }\n\n    // trim the fullVersion string at semicolon/space if present\n    if ((ix = fullVersion.indexOf(';')) !== -1) {\n        fullVersion = fullVersion.substring(0, ix);\n    }\n\n    if ((ix = fullVersion.indexOf(' ')) !== -1) {\n        fullVersion = fullVersion.substring(0, ix);\n    }\n\n    majorVersion = parseInt('' + fullVersion, 10);\n\n    if (isNaN(majorVersion)) {\n        fullVersion = '' + parseFloat(navigator.appVersion);\n        majorVersion = parseInt(navigator.appVersion, 10);\n    }\n\n    return majorVersion >= 49;\n}\n\n// ______________________\n// MediaStreamRecorder.js\n\n/**\n * MediaStreamRecorder is an abstraction layer for {@link https://w3c.github.io/mediacapture-record/MediaRecorder.html|MediaRecorder API}. It is used by {@link RecordRTC} to record MediaStream(s) in both Chrome and Firefox.\n * @summary Runs top over {@link https://w3c.github.io/mediacapture-record/MediaRecorder.html|MediaRecorder API}.\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://github.com/muaz-khan|Muaz Khan}\n * @typedef MediaStreamRecorder\n * @class\n * @example\n * var config = {\n *     mimeType: 'video/webm', // vp8, vp9, h264, mkv, opus/vorbis\n *     audioBitsPerSecond : 256 * 8 * 1024,\n *     videoBitsPerSecond : 256 * 8 * 1024,\n *     bitsPerSecond: 256 * 8 * 1024,  // if this is provided, skip above two\n *     checkForInactiveTracks: true,\n *     timeSlice: 1000, // concatenate intervals based blobs\n *     ondataavailable: function() {} // get intervals based blobs\n * }\n * var recorder = new MediaStreamRecorder(mediaStream, config);\n * recorder.record();\n * recorder.stop(function(blob) {\n *     video.src = URL.createObjectURL(blob);\n *\n *     // or\n *     var blob = recorder.blob;\n * });\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\n * @param {object} config - {disableLogs:true, initCallback: function, mimeType: \"video/webm\", timeSlice: 1000}\n * @throws Will throw an error if first argument \"MediaStream\" is missing. Also throws error if \"MediaRecorder API\" are not supported by the browser.\n */\n\nfunction MediaStreamRecorder(mediaStream, config) {\n    var self = this;\n\n    if (typeof mediaStream === 'undefined') {\n        throw 'First argument \"MediaStream\" is required.';\n    }\n\n    if (typeof MediaRecorder === 'undefined') {\n        throw 'Your browser does not support the Media Recorder API. Please try other modules e.g. WhammyRecorder or StereoAudioRecorder.';\n    }\n\n    config = config || {\n        // bitsPerSecond: 256 * 8 * 1024,\n        mimeType: 'video/webm'\n    };\n\n    if (config.type === 'audio') {\n        if (getTracks(mediaStream, 'video').length && getTracks(mediaStream, 'audio').length) {\n            var stream;\n            if (!!navigator.mozGetUserMedia) {\n                stream = new MediaStream();\n                stream.addTrack(getTracks(mediaStream, 'audio')[0]);\n            } else {\n                // webkitMediaStream\n                stream = new MediaStream(getTracks(mediaStream, 'audio'));\n            }\n            mediaStream = stream;\n        }\n\n        if (!config.mimeType || config.mimeType.toString().toLowerCase().indexOf('audio') === -1) {\n            config.mimeType = isChrome ? 'audio/webm' : 'audio/ogg';\n        }\n\n        if (config.mimeType && config.mimeType.toString().toLowerCase() !== 'audio/ogg' && !!navigator.mozGetUserMedia) {\n            // forcing better codecs on Firefox (via #166)\n            config.mimeType = 'audio/ogg';\n        }\n    }\n\n    var arrayOfBlobs = [];\n\n    /**\n     * This method returns array of blobs. Use only with \"timeSlice\". Its useful to preview recording anytime, without using the \"stop\" method.\n     * @method\n     * @memberof MediaStreamRecorder\n     * @example\n     * var arrayOfBlobs = recorder.getArrayOfBlobs();\n     * @returns {Array} Returns array of recorded blobs.\n     */\n    this.getArrayOfBlobs = function() {\n        return arrayOfBlobs;\n    };\n\n    /**\n     * This method records MediaStream.\n     * @method\n     * @memberof MediaStreamRecorder\n     * @example\n     * recorder.record();\n     */\n    this.record = function() {\n        // set defaults\n        self.blob = null;\n        self.clearRecordedData();\n        self.timestamps = [];\n        allStates = [];\n        arrayOfBlobs = [];\n\n        var recorderHints = config;\n\n        if (!config.disableLogs) {\n            console.log('Passing following config over MediaRecorder API.', recorderHints);\n        }\n\n        if (mediaRecorder) {\n            // mandatory to make sure Firefox doesn't fails to record streams 3-4 times without reloading the page.\n            mediaRecorder = null;\n        }\n\n        if (isChrome && !isMediaRecorderCompatible()) {\n            // to support video-only recording on stable\n            recorderHints = 'video/vp8';\n        }\n\n        if (typeof MediaRecorder.isTypeSupported === 'function' && recorderHints.mimeType) {\n            if (!MediaRecorder.isTypeSupported(recorderHints.mimeType)) {\n                if (!config.disableLogs) {\n                    console.warn('MediaRecorder API seems unable to record mimeType:', recorderHints.mimeType);\n                }\n\n                recorderHints.mimeType = config.type === 'audio' ? 'audio/webm' : 'video/webm';\n            }\n        }\n\n        // using MediaRecorder API here\n        try {\n            mediaRecorder = new MediaRecorder(mediaStream, recorderHints);\n\n            // reset\n            config.mimeType = recorderHints.mimeType;\n        } catch (e) {\n            // chrome-based fallback\n            mediaRecorder = new MediaRecorder(mediaStream);\n        }\n\n        // old hack?\n        if (recorderHints.mimeType && !MediaRecorder.isTypeSupported && 'canRecordMimeType' in mediaRecorder && mediaRecorder.canRecordMimeType(recorderHints.mimeType) === false) {\n            if (!config.disableLogs) {\n                console.warn('MediaRecorder API seems unable to record mimeType:', recorderHints.mimeType);\n            }\n        }\n\n        // Dispatching OnDataAvailable Handler\n        mediaRecorder.ondataavailable = function(e) {\n            if (e.data) {\n                allStates.push('ondataavailable: ' + bytesToSize(e.data.size));\n            }\n\n            if (typeof config.timeSlice === 'number') {\n                if (e.data && e.data.size) {\n                    arrayOfBlobs.push(e.data);\n                    updateTimeStamp();\n\n                    if (typeof config.ondataavailable === 'function') {\n                        // intervals based blobs\n                        var blob = config.getNativeBlob ? e.data : new Blob([e.data], {\n                            type: getMimeType(recorderHints)\n                        });\n                        config.ondataavailable(blob);\n                    }\n                }\n                return;\n            }\n\n            if (!e.data || !e.data.size || e.data.size < 100 || self.blob) {\n                // make sure that stopRecording always getting fired\n                // even if there is invalid data\n                if (self.recordingCallback) {\n                    self.recordingCallback(new Blob([], {\n                        type: getMimeType(recorderHints)\n                    }));\n                    self.recordingCallback = null;\n                }\n                return;\n            }\n\n            self.blob = config.getNativeBlob ? e.data : new Blob([e.data], {\n                type: getMimeType(recorderHints)\n            });\n\n            if (self.recordingCallback) {\n                self.recordingCallback(self.blob);\n                self.recordingCallback = null;\n            }\n        };\n\n        mediaRecorder.onstart = function() {\n            allStates.push('started');\n        };\n\n        mediaRecorder.onpause = function() {\n            allStates.push('paused');\n        };\n\n        mediaRecorder.onresume = function() {\n            allStates.push('resumed');\n        };\n\n        mediaRecorder.onstop = function() {\n            allStates.push('stopped');\n        };\n\n        mediaRecorder.onerror = function(error) {\n            if (!error) {\n                return;\n            }\n\n            if (!error.name) {\n                error.name = 'UnknownError';\n            }\n\n            allStates.push('error: ' + error);\n\n            if (!config.disableLogs) {\n                // via: https://w3c.github.io/mediacapture-record/MediaRecorder.html#exception-summary\n                if (error.name.toString().toLowerCase().indexOf('invalidstate') !== -1) {\n                    console.error('The MediaRecorder is not in a state in which the proposed operation is allowed to be executed.', error);\n                } else if (error.name.toString().toLowerCase().indexOf('notsupported') !== -1) {\n                    console.error('MIME type (', recorderHints.mimeType, ') is not supported.', error);\n                } else if (error.name.toString().toLowerCase().indexOf('security') !== -1) {\n                    console.error('MediaRecorder security error', error);\n                }\n\n                // older code below\n                else if (error.name === 'OutOfMemory') {\n                    console.error('The UA has exhaused the available memory. User agents SHOULD provide as much additional information as possible in the message attribute.', error);\n                } else if (error.name === 'IllegalStreamModification') {\n                    console.error('A modification to the stream has occurred that makes it impossible to continue recording. An example would be the addition of a Track while recording is occurring. User agents SHOULD provide as much additional information as possible in the message attribute.', error);\n                } else if (error.name === 'OtherRecordingError') {\n                    console.error('Used for an fatal error other than those listed above. User agents SHOULD provide as much additional information as possible in the message attribute.', error);\n                } else if (error.name === 'GenericError') {\n                    console.error('The UA cannot provide the codec or recording option that has been requested.', error);\n                } else {\n                    console.error('MediaRecorder Error', error);\n                }\n            }\n\n            (function(looper) {\n                if (!self.manuallyStopped && mediaRecorder && mediaRecorder.state === 'inactive') {\n                    delete config.timeslice;\n\n                    // 10 minutes, enough?\n                    mediaRecorder.start(10 * 60 * 1000);\n                    return;\n                }\n\n                setTimeout(looper, 1000);\n            })();\n\n            if (mediaRecorder.state !== 'inactive' && mediaRecorder.state !== 'stopped') {\n                mediaRecorder.stop();\n            }\n        };\n\n        if (typeof config.timeSlice === 'number') {\n            updateTimeStamp();\n            mediaRecorder.start(config.timeSlice);\n        } else {\n            // default is 60 minutes; enough?\n            // use config => {timeSlice: 1000} otherwise\n\n            mediaRecorder.start(3.6e+6);\n        }\n\n        if (config.initCallback) {\n            config.initCallback(); // old code\n        }\n    };\n\n    /**\n     * @property {Array} timestamps - Array of time stamps\n     * @memberof MediaStreamRecorder\n     * @example\n     * console.log(recorder.timestamps);\n     */\n    this.timestamps = [];\n\n    function updateTimeStamp() {\n        self.timestamps.push(new Date().getTime());\n\n        if (typeof config.onTimeStamp === 'function') {\n            config.onTimeStamp(self.timestamps[self.timestamps.length - 1], self.timestamps);\n        }\n    }\n\n    function getMimeType(secondObject) {\n        if (mediaRecorder && mediaRecorder.mimeType) {\n            return mediaRecorder.mimeType;\n        }\n\n        return secondObject.mimeType || 'video/webm';\n    }\n\n    /**\n     * This method stops recording MediaStream.\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\n     * @method\n     * @memberof MediaStreamRecorder\n     * @example\n     * recorder.stop(function(blob) {\n     *     video.src = URL.createObjectURL(blob);\n     * });\n     */\n    this.stop = function(callback) {\n        callback = callback || function() {};\n\n        self.manuallyStopped = true; // used inside the mediaRecorder.onerror\n\n        if (!mediaRecorder) {\n            return;\n        }\n\n        this.recordingCallback = callback;\n\n        if (mediaRecorder.state === 'recording') {\n            mediaRecorder.stop();\n        }\n\n        if (typeof config.timeSlice === 'number') {\n            setTimeout(function() {\n                self.blob = new Blob(arrayOfBlobs, {\n                    type: getMimeType(config)\n                });\n\n                self.recordingCallback(self.blob);\n            }, 100);\n        }\n    };\n\n    /**\n     * This method pauses the recording process.\n     * @method\n     * @memberof MediaStreamRecorder\n     * @example\n     * recorder.pause();\n     */\n    this.pause = function() {\n        if (!mediaRecorder) {\n            return;\n        }\n\n        if (mediaRecorder.state === 'recording') {\n            mediaRecorder.pause();\n        }\n    };\n\n    /**\n     * This method resumes the recording process.\n     * @method\n     * @memberof MediaStreamRecorder\n     * @example\n     * recorder.resume();\n     */\n    this.resume = function() {\n        if (!mediaRecorder) {\n            return;\n        }\n\n        if (mediaRecorder.state === 'paused') {\n            mediaRecorder.resume();\n        }\n    };\n\n    /**\n     * This method resets currently recorded data.\n     * @method\n     * @memberof MediaStreamRecorder\n     * @example\n     * recorder.clearRecordedData();\n     */\n    this.clearRecordedData = function() {\n        if (mediaRecorder && mediaRecorder.state === 'recording') {\n            self.stop(clearRecordedDataCB);\n        }\n\n        clearRecordedDataCB();\n    };\n\n    function clearRecordedDataCB() {\n        arrayOfBlobs = [];\n        mediaRecorder = null;\n        self.timestamps = [];\n    }\n\n    // Reference to \"MediaRecorder\" object\n    var mediaRecorder;\n\n    /**\n     * Access to native MediaRecorder API\n     * @method\n     * @memberof MediaStreamRecorder\n     * @instance\n     * @example\n     * var internal = recorder.getInternalRecorder();\n     * internal.ondataavailable = function() {}; // override\n     * internal.stream, internal.onpause, internal.onstop, etc.\n     * @returns {Object} Returns internal recording object.\n     */\n    this.getInternalRecorder = function() {\n        return mediaRecorder;\n    };\n\n    function isMediaStreamActive() {\n        if ('active' in mediaStream) {\n            if (!mediaStream.active) {\n                return false;\n            }\n        } else if ('ended' in mediaStream) { // old hack\n            if (mediaStream.ended) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @property {Blob} blob - Recorded data as \"Blob\" object.\n     * @memberof MediaStreamRecorder\n     * @example\n     * recorder.stop(function() {\n     *     var blob = recorder.blob;\n     * });\n     */\n    this.blob = null;\n\n\n    /**\n     * Get MediaRecorder readonly state.\n     * @method\n     * @memberof MediaStreamRecorder\n     * @example\n     * var state = recorder.getState();\n     * @returns {String} Returns recording state.\n     */\n    this.getState = function() {\n        if (!mediaRecorder) {\n            return 'inactive';\n        }\n\n        return mediaRecorder.state || 'inactive';\n    };\n\n    // list of all recording states\n    var allStates = [];\n\n    /**\n     * Get MediaRecorder all recording states.\n     * @method\n     * @memberof MediaStreamRecorder\n     * @example\n     * var state = recorder.getAllStates();\n     * @returns {Array} Returns all recording states\n     */\n    this.getAllStates = function() {\n        return allStates;\n    };\n\n    // if any Track within the MediaStream is muted or not enabled at any time, \n    // the browser will only record black frames \n    // or silence since that is the content produced by the Track\n    // so we need to stopRecording as soon as any single track ends.\n    if (typeof config.checkForInactiveTracks === 'undefined') {\n        config.checkForInactiveTracks = false; // disable to minimize CPU usage\n    }\n\n    var self = this;\n\n    // this method checks if media stream is stopped\n    // or if any track is ended.\n    (function looper() {\n        if (!mediaRecorder || config.checkForInactiveTracks === false) {\n            return;\n        }\n\n        if (isMediaStreamActive() === false) {\n            if (!config.disableLogs) {\n                console.log('MediaStream seems stopped.');\n            }\n            self.stop();\n            return;\n        }\n\n        setTimeout(looper, 1000); // check every second\n    })();\n\n    // for debugging\n    this.name = 'MediaStreamRecorder';\n    this.toString = function() {\n        return this.name;\n    };\n}\n\nif (typeof RecordRTC !== 'undefined') {\n    RecordRTC.MediaStreamRecorder = MediaStreamRecorder;\n}\n\n// source code from: http://typedarray.org/wp-content/projects/WebAudioRecorder/script.js\n// https://github.com/mattdiamond/Recorderjs#license-mit\n// ______________________\n// StereoAudioRecorder.js\n\n/**\n * StereoAudioRecorder is a standalone class used by {@link RecordRTC} to bring \"stereo\" audio-recording in chrome.\n * @summary JavaScript standalone object for stereo audio recording.\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @typedef StereoAudioRecorder\n * @class\n * @example\n * var recorder = new StereoAudioRecorder(MediaStream, {\n *     sampleRate: 44100,\n *     bufferSize: 4096\n * });\n * recorder.record();\n * recorder.stop(function(blob) {\n *     video.src = URL.createObjectURL(blob);\n * });\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\n * @param {object} config - {sampleRate: 44100, bufferSize: 4096, numberOfAudioChannels: 1, etc.}\n */\n\nfunction StereoAudioRecorder(mediaStream, config) {\n    if (!getTracks(mediaStream, 'audio').length) {\n        throw 'Your stream has no audio tracks.';\n    }\n\n    config = config || {};\n\n    var self = this;\n\n    // variables\n    var leftchannel = [];\n    var rightchannel = [];\n    var recording = false;\n    var recordingLength = 0;\n    var jsAudioNode;\n\n    var numberOfAudioChannels = 2;\n\n    /**\n     * Set sample rates such as 8K or 16K. Reference: http://stackoverflow.com/a/28977136/552182\n     * @property {number} desiredSampRate - Desired Bits per sample * 1000\n     * @memberof StereoAudioRecorder\n     * @instance\n     * @example\n     * var recorder = StereoAudioRecorder(mediaStream, {\n     *   desiredSampRate: 16 * 1000 // bits-per-sample * 1000\n     * });\n     */\n    var desiredSampRate = config.desiredSampRate;\n\n    // backward compatibility\n    if (config.leftChannel === true) {\n        numberOfAudioChannels = 1;\n    }\n\n    if (config.numberOfAudioChannels === 1) {\n        numberOfAudioChannels = 1;\n    }\n\n    if (!numberOfAudioChannels || numberOfAudioChannels < 1) {\n        numberOfAudioChannels = 2;\n    }\n\n    if (!config.disableLogs) {\n        console.log('StereoAudioRecorder is set to record number of channels: ' + numberOfAudioChannels);\n    }\n\n    // if any Track within the MediaStream is muted or not enabled at any time, \n    // the browser will only record black frames \n    // or silence since that is the content produced by the Track\n    // so we need to stopRecording as soon as any single track ends.\n    if (typeof config.checkForInactiveTracks === 'undefined') {\n        config.checkForInactiveTracks = true;\n    }\n\n    function isMediaStreamActive() {\n        if (config.checkForInactiveTracks === false) {\n            // always return \"true\"\n            return true;\n        }\n\n        if ('active' in mediaStream) {\n            if (!mediaStream.active) {\n                return false;\n            }\n        } else if ('ended' in mediaStream) { // old hack\n            if (mediaStream.ended) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * This method records MediaStream.\n     * @method\n     * @memberof StereoAudioRecorder\n     * @example\n     * recorder.record();\n     */\n    this.record = function() {\n        if (isMediaStreamActive() === false) {\n            throw 'Please make sure MediaStream is active.';\n        }\n\n        resetVariables();\n\n        isAudioProcessStarted = isPaused = false;\n        recording = true;\n\n        if (typeof config.timeSlice !== 'undefined') {\n            looper();\n        }\n    };\n\n    function mergeLeftRightBuffers(config, callback) {\n        function mergeAudioBuffers(config, cb) {\n            var numberOfAudioChannels = config.numberOfAudioChannels;\n\n            // todo: \"slice(0)\" --- is it causes loop? Should be removed?\n            var leftBuffers = config.leftBuffers.slice(0);\n            var rightBuffers = config.rightBuffers.slice(0);\n            var sampleRate = config.sampleRate;\n            var internalInterleavedLength = config.internalInterleavedLength;\n            var desiredSampRate = config.desiredSampRate;\n\n            if (numberOfAudioChannels === 2) {\n                leftBuffers = mergeBuffers(leftBuffers, internalInterleavedLength);\n                rightBuffers = mergeBuffers(rightBuffers, internalInterleavedLength);\n\n                if (desiredSampRate) {\n                    leftBuffers = interpolateArray(leftBuffers, desiredSampRate, sampleRate);\n                    rightBuffers = interpolateArray(rightBuffers, desiredSampRate, sampleRate);\n                }\n            }\n\n            if (numberOfAudioChannels === 1) {\n                leftBuffers = mergeBuffers(leftBuffers, internalInterleavedLength);\n\n                if (desiredSampRate) {\n                    leftBuffers = interpolateArray(leftBuffers, desiredSampRate, sampleRate);\n                }\n            }\n\n            // set sample rate as desired sample rate\n            if (desiredSampRate) {\n                sampleRate = desiredSampRate;\n            }\n\n            // for changing the sampling rate, reference:\n            // http://stackoverflow.com/a/28977136/552182\n            function interpolateArray(data, newSampleRate, oldSampleRate) {\n                var fitCount = Math.round(data.length * (newSampleRate / oldSampleRate));\n                var newData = [];\n                var springFactor = Number((data.length - 1) / (fitCount - 1));\n                newData[0] = data[0];\n                for (var i = 1; i < fitCount - 1; i++) {\n                    var tmp = i * springFactor;\n                    var before = Number(Math.floor(tmp)).toFixed();\n                    var after = Number(Math.ceil(tmp)).toFixed();\n                    var atPoint = tmp - before;\n                    newData[i] = linearInterpolate(data[before], data[after], atPoint);\n                }\n                newData[fitCount - 1] = data[data.length - 1];\n                return newData;\n            }\n\n            function linearInterpolate(before, after, atPoint) {\n                return before + (after - before) * atPoint;\n            }\n\n            function mergeBuffers(channelBuffer, rLength) {\n                var result = new Float64Array(rLength);\n                var offset = 0;\n                var lng = channelBuffer.length;\n\n                for (var i = 0; i < lng; i++) {\n                    var buffer = channelBuffer[i];\n                    result.set(buffer, offset);\n                    offset += buffer.length;\n                }\n\n                return result;\n            }\n\n            function interleave(leftChannel, rightChannel) {\n                var length = leftChannel.length + rightChannel.length;\n\n                var result = new Float64Array(length);\n\n                var inputIndex = 0;\n\n                for (var index = 0; index < length;) {\n                    result[index++] = leftChannel[inputIndex];\n                    result[index++] = rightChannel[inputIndex];\n                    inputIndex++;\n                }\n                return result;\n            }\n\n            function writeUTFBytes(view, offset, string) {\n                var lng = string.length;\n                for (var i = 0; i < lng; i++) {\n                    view.setUint8(offset + i, string.charCodeAt(i));\n                }\n            }\n\n            // interleave both channels together\n            var interleaved;\n\n            if (numberOfAudioChannels === 2) {\n                interleaved = interleave(leftBuffers, rightBuffers);\n            }\n\n            if (numberOfAudioChannels === 1) {\n                interleaved = leftBuffers;\n            }\n\n            var interleavedLength = interleaved.length;\n\n            // create wav file\n            var resultingBufferLength = 44 + interleavedLength * 2;\n\n            var buffer = new ArrayBuffer(resultingBufferLength);\n\n            var view = new DataView(buffer);\n\n            // RIFF chunk descriptor/identifier \n            writeUTFBytes(view, 0, 'RIFF');\n\n            // RIFF chunk length\n            // changed \"44\" to \"36\" via #401\n            view.setUint32(4, 36 + interleavedLength * 2, true);\n\n            // RIFF type \n            writeUTFBytes(view, 8, 'WAVE');\n\n            // format chunk identifier \n            // FMT sub-chunk\n            writeUTFBytes(view, 12, 'fmt ');\n\n            // format chunk length \n            view.setUint32(16, 16, true);\n\n            // sample format (raw)\n            view.setUint16(20, 1, true);\n\n            // stereo (2 channels)\n            view.setUint16(22, numberOfAudioChannels, true);\n\n            // sample rate \n            view.setUint32(24, sampleRate, true);\n\n            // byte rate (sample rate * block align)\n            view.setUint32(28, sampleRate * numberOfAudioChannels * 2, true);\n\n            // block align (channel count * bytes per sample) \n            view.setUint16(32, numberOfAudioChannels * 2, true);\n\n            // bits per sample \n            view.setUint16(34, 16, true);\n\n            // data sub-chunk\n            // data chunk identifier \n            writeUTFBytes(view, 36, 'data');\n\n            // data chunk length \n            view.setUint32(40, interleavedLength * 2, true);\n\n            // write the PCM samples\n            var lng = interleavedLength;\n            var index = 44;\n            var volume = 1;\n            for (var i = 0; i < lng; i++) {\n                view.setInt16(index, interleaved[i] * (0x7FFF * volume), true);\n                index += 2;\n            }\n\n            if (cb) {\n                return cb({\n                    buffer: buffer,\n                    view: view\n                });\n            }\n\n            postMessage({\n                buffer: buffer,\n                view: view\n            });\n        }\n\n        if (config.noWorker) {\n            mergeAudioBuffers(config, function(data) {\n                callback(data.buffer, data.view);\n            });\n            return;\n        }\n\n\n        var webWorker = processInWebWorker(mergeAudioBuffers);\n\n        webWorker.onmessage = function(event) {\n            callback(event.data.buffer, event.data.view);\n\n            // release memory\n            URL.revokeObjectURL(webWorker.workerURL);\n\n            // kill webworker (or Chrome will kill your page after ~25 calls)\n            webWorker.terminate();\n        };\n\n        webWorker.postMessage(config);\n    }\n\n    function processInWebWorker(_function) {\n        var workerURL = URL.createObjectURL(new Blob([_function.toString(),\n            ';this.onmessage =  function (eee) {' + _function.name + '(eee.data);}'\n        ], {\n            type: 'application/javascript'\n        }));\n\n        var worker = new Worker(workerURL);\n        worker.workerURL = workerURL;\n        return worker;\n    }\n\n    /**\n     * This method stops recording MediaStream.\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\n     * @method\n     * @memberof StereoAudioRecorder\n     * @example\n     * recorder.stop(function(blob) {\n     *     video.src = URL.createObjectURL(blob);\n     * });\n     */\n    this.stop = function(callback) {\n        callback = callback || function() {};\n\n        // stop recording\n        recording = false;\n\n        mergeLeftRightBuffers({\n            desiredSampRate: desiredSampRate,\n            sampleRate: sampleRate,\n            numberOfAudioChannels: numberOfAudioChannels,\n            internalInterleavedLength: recordingLength,\n            leftBuffers: leftchannel,\n            rightBuffers: numberOfAudioChannels === 1 ? [] : rightchannel,\n            noWorker: config.noWorker\n        }, function(buffer, view) {\n            /**\n             * @property {Blob} blob - The recorded blob object.\n             * @memberof StereoAudioRecorder\n             * @example\n             * recorder.stop(function(){\n             *     var blob = recorder.blob;\n             * });\n             */\n            self.blob = new Blob([view], {\n                type: 'audio/wav'\n            });\n\n            /**\n             * @property {ArrayBuffer} buffer - The recorded buffer object.\n             * @memberof StereoAudioRecorder\n             * @example\n             * recorder.stop(function(){\n             *     var buffer = recorder.buffer;\n             * });\n             */\n            self.buffer = new ArrayBuffer(view.buffer.byteLength);\n\n            /**\n             * @property {DataView} view - The recorded data-view object.\n             * @memberof StereoAudioRecorder\n             * @example\n             * recorder.stop(function(){\n             *     var view = recorder.view;\n             * });\n             */\n            self.view = view;\n\n            self.sampleRate = desiredSampRate || sampleRate;\n            self.bufferSize = bufferSize;\n\n            // recorded audio length\n            self.length = recordingLength;\n\n            isAudioProcessStarted = false;\n\n            if (callback) {\n                callback(self.blob);\n            }\n        });\n    };\n\n    if (typeof RecordRTC.Storage === 'undefined') {\n        RecordRTC.Storage = {\n            AudioContextConstructor: null,\n            AudioContext: window.AudioContext || window.webkitAudioContext\n        };\n    }\n\n    if (!RecordRTC.Storage.AudioContextConstructor || RecordRTC.Storage.AudioContextConstructor.state === 'closed') {\n        RecordRTC.Storage.AudioContextConstructor = new RecordRTC.Storage.AudioContext();\n    }\n\n    var context = RecordRTC.Storage.AudioContextConstructor;\n\n    // creates an audio node from the microphone incoming stream\n    var audioInput = context.createMediaStreamSource(mediaStream);\n\n    var legalBufferValues = [0, 256, 512, 1024, 2048, 4096, 8192, 16384];\n\n    /**\n     * From the spec: This value controls how frequently the audioprocess event is\n     * dispatched and how many sample-frames need to be processed each call.\n     * Lower values for buffer size will result in a lower (better) latency.\n     * Higher values will be necessary to avoid audio breakup and glitches\n     * The size of the buffer (in sample-frames) which needs to\n     * be processed each time onprocessaudio is called.\n     * Legal values are (256, 512, 1024, 2048, 4096, 8192, 16384).\n     * @property {number} bufferSize - Buffer-size for how frequently the audioprocess event is dispatched.\n     * @memberof StereoAudioRecorder\n     * @example\n     * recorder = new StereoAudioRecorder(mediaStream, {\n     *     bufferSize: 4096\n     * });\n     */\n\n    // \"0\" means, let chrome decide the most accurate buffer-size for current platform.\n    var bufferSize = typeof config.bufferSize === 'undefined' ? 4096 : config.bufferSize;\n\n    if (legalBufferValues.indexOf(bufferSize) === -1) {\n        if (!config.disableLogs) {\n            console.log('Legal values for buffer-size are ' + JSON.stringify(legalBufferValues, null, '\\t'));\n        }\n    }\n\n    if (context.createJavaScriptNode) {\n        jsAudioNode = context.createJavaScriptNode(bufferSize, numberOfAudioChannels, numberOfAudioChannels);\n    } else if (context.createScriptProcessor) {\n        jsAudioNode = context.createScriptProcessor(bufferSize, numberOfAudioChannels, numberOfAudioChannels);\n    } else {\n        throw 'WebAudio API has no support on this browser.';\n    }\n\n    // connect the stream to the script processor\n    audioInput.connect(jsAudioNode);\n\n    if (!config.bufferSize) {\n        bufferSize = jsAudioNode.bufferSize; // device buffer-size\n    }\n\n    /**\n     * The sample rate (in sample-frames per second) at which the\n     * AudioContext handles audio. It is assumed that all AudioNodes\n     * in the context run at this rate. In making this assumption,\n     * sample-rate converters or \"varispeed\" processors are not supported\n     * in real-time processing.\n     * The sampleRate parameter describes the sample-rate of the\n     * linear PCM audio data in the buffer in sample-frames per second.\n     * An implementation must support sample-rates in at least\n     * the range 22050 to 96000.\n     * @property {number} sampleRate - Buffer-size for how frequently the audioprocess event is dispatched.\n     * @memberof StereoAudioRecorder\n     * @example\n     * recorder = new StereoAudioRecorder(mediaStream, {\n     *     sampleRate: 44100\n     * });\n     */\n    var sampleRate = typeof config.sampleRate !== 'undefined' ? config.sampleRate : context.sampleRate || 44100;\n\n    if (sampleRate < 22050 || sampleRate > 96000) {\n        // Ref: http://stackoverflow.com/a/26303918/552182\n        if (!config.disableLogs) {\n            console.log('sample-rate must be under range 22050 and 96000.');\n        }\n    }\n\n    if (!config.disableLogs) {\n        if (config.desiredSampRate) {\n            console.log('Desired sample-rate: ' + config.desiredSampRate);\n        }\n    }\n\n    var isPaused = false;\n    /**\n     * This method pauses the recording process.\n     * @method\n     * @memberof StereoAudioRecorder\n     * @example\n     * recorder.pause();\n     */\n    this.pause = function() {\n        isPaused = true;\n    };\n\n    /**\n     * This method resumes the recording process.\n     * @method\n     * @memberof StereoAudioRecorder\n     * @example\n     * recorder.resume();\n     */\n    this.resume = function() {\n        if (isMediaStreamActive() === false) {\n            throw 'Please make sure MediaStream is active.';\n        }\n\n        if (!recording) {\n            if (!config.disableLogs) {\n                console.log('Seems recording has been restarted.');\n            }\n            this.record();\n            return;\n        }\n\n        isPaused = false;\n    };\n\n    /**\n     * This method resets currently recorded data.\n     * @method\n     * @memberof StereoAudioRecorder\n     * @example\n     * recorder.clearRecordedData();\n     */\n    this.clearRecordedData = function() {\n        config.checkForInactiveTracks = false;\n\n        if (recording) {\n            this.stop(clearRecordedDataCB);\n        }\n\n        clearRecordedDataCB();\n    };\n\n    function resetVariables() {\n        leftchannel = [];\n        rightchannel = [];\n        recordingLength = 0;\n        isAudioProcessStarted = false;\n        recording = false;\n        isPaused = false;\n        context = null;\n\n        self.leftchannel = leftchannel;\n        self.rightchannel = rightchannel;\n        self.numberOfAudioChannels = numberOfAudioChannels;\n        self.desiredSampRate = desiredSampRate;\n        self.sampleRate = sampleRate;\n        self.recordingLength = recordingLength;\n\n        intervalsBasedBuffers = {\n            left: [],\n            right: [],\n            recordingLength: 0\n        };\n    }\n\n    function clearRecordedDataCB() {\n        if (jsAudioNode) {\n            jsAudioNode.onaudioprocess = null;\n            jsAudioNode.disconnect();\n            jsAudioNode = null;\n        }\n\n        if (audioInput) {\n            audioInput.disconnect();\n            audioInput = null;\n        }\n\n        resetVariables();\n    }\n\n    // for debugging\n    this.name = 'StereoAudioRecorder';\n    this.toString = function() {\n        return this.name;\n    };\n\n    var isAudioProcessStarted = false;\n\n    function onAudioProcessDataAvailable(e) {\n        if (isPaused) {\n            return;\n        }\n\n        if (isMediaStreamActive() === false) {\n            if (!config.disableLogs) {\n                console.log('MediaStream seems stopped.');\n            }\n            jsAudioNode.disconnect();\n            recording = false;\n        }\n\n        if (!recording) {\n            if (audioInput) {\n                audioInput.disconnect();\n                audioInput = null;\n            }\n            return;\n        }\n\n        /**\n         * This method is called on \"onaudioprocess\" event's first invocation.\n         * @method {function} onAudioProcessStarted\n         * @memberof StereoAudioRecorder\n         * @example\n         * recorder.onAudioProcessStarted: function() { };\n         */\n        if (!isAudioProcessStarted) {\n            isAudioProcessStarted = true;\n            if (config.onAudioProcessStarted) {\n                config.onAudioProcessStarted();\n            }\n\n            if (config.initCallback) {\n                config.initCallback();\n            }\n        }\n\n        var left = e.inputBuffer.getChannelData(0);\n\n        // we clone the samples\n        var chLeft = new Float32Array(left);\n        leftchannel.push(chLeft);\n\n        if (numberOfAudioChannels === 2) {\n            var right = e.inputBuffer.getChannelData(1);\n            var chRight = new Float32Array(right);\n            rightchannel.push(chRight);\n        }\n\n        recordingLength += bufferSize;\n\n        // export raw PCM\n        self.recordingLength = recordingLength;\n\n        if (typeof config.timeSlice !== 'undefined') {\n            intervalsBasedBuffers.recordingLength += bufferSize;\n            intervalsBasedBuffers.left.push(chLeft);\n\n            if (numberOfAudioChannels === 2) {\n                intervalsBasedBuffers.right.push(chRight);\n            }\n        }\n    }\n\n    jsAudioNode.onaudioprocess = onAudioProcessDataAvailable;\n\n    // to prevent self audio to be connected with speakers\n    if (context.createMediaStreamDestination) {\n        jsAudioNode.connect(context.createMediaStreamDestination());\n    } else {\n        jsAudioNode.connect(context.destination);\n    }\n\n    // export raw PCM\n    this.leftchannel = leftchannel;\n    this.rightchannel = rightchannel;\n    this.numberOfAudioChannels = numberOfAudioChannels;\n    this.desiredSampRate = desiredSampRate;\n    this.sampleRate = sampleRate;\n    self.recordingLength = recordingLength;\n\n    // helper for intervals based blobs\n    var intervalsBasedBuffers = {\n        left: [],\n        right: [],\n        recordingLength: 0\n    };\n\n    // this looper is used to support intervals based blobs (via timeSlice+ondataavailable)\n    function looper() {\n        if (!recording || typeof config.ondataavailable !== 'function' || typeof config.timeSlice === 'undefined') {\n            return;\n        }\n\n        if (intervalsBasedBuffers.left.length) {\n            mergeLeftRightBuffers({\n                desiredSampRate: desiredSampRate,\n                sampleRate: sampleRate,\n                numberOfAudioChannels: numberOfAudioChannels,\n                internalInterleavedLength: intervalsBasedBuffers.recordingLength,\n                leftBuffers: intervalsBasedBuffers.left,\n                rightBuffers: numberOfAudioChannels === 1 ? [] : intervalsBasedBuffers.right\n            }, function(buffer, view) {\n                var blob = new Blob([view], {\n                    type: 'audio/wav'\n                });\n                config.ondataavailable(blob);\n\n                setTimeout(looper, config.timeSlice);\n            });\n\n            intervalsBasedBuffers = {\n                left: [],\n                right: [],\n                recordingLength: 0\n            };\n        } else {\n            setTimeout(looper, config.timeSlice);\n        }\n    }\n}\n\nif (typeof RecordRTC !== 'undefined') {\n    RecordRTC.StereoAudioRecorder = StereoAudioRecorder;\n}\n\n// _________________\n// CanvasRecorder.js\n\n/**\n * CanvasRecorder is a standalone class used by {@link RecordRTC} to bring HTML5-Canvas recording into video WebM. It uses HTML2Canvas library and runs top over {@link Whammy}.\n * @summary HTML2Canvas recording into video WebM.\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @typedef CanvasRecorder\n * @class\n * @example\n * var recorder = new CanvasRecorder(htmlElement, { disableLogs: true, useWhammyRecorder: true });\n * recorder.record();\n * recorder.stop(function(blob) {\n *     video.src = URL.createObjectURL(blob);\n * });\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n * @param {HTMLElement} htmlElement - querySelector/getElementById/getElementsByTagName[0]/etc.\n * @param {object} config - {disableLogs:true, initCallback: function}\n */\n\nfunction CanvasRecorder(htmlElement, config) {\n    if (typeof html2canvas === 'undefined') {\n        throw 'Please link: https://www.webrtc-experiment.com/screenshot.js';\n    }\n\n    config = config || {};\n    if (!config.frameInterval) {\n        config.frameInterval = 10;\n    }\n\n    // via DetectRTC.js\n    var isCanvasSupportsStreamCapturing = false;\n    ['captureStream', 'mozCaptureStream', 'webkitCaptureStream'].forEach(function(item) {\n        if (item in document.createElement('canvas')) {\n            isCanvasSupportsStreamCapturing = true;\n        }\n    });\n\n    var _isChrome = (!!window.webkitRTCPeerConnection || !!window.webkitGetUserMedia) && !!window.chrome;\n\n    var chromeVersion = 50;\n    var matchArray = navigator.userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./);\n    if (_isChrome && matchArray && matchArray[2]) {\n        chromeVersion = parseInt(matchArray[2], 10);\n    }\n\n    if (_isChrome && chromeVersion < 52) {\n        isCanvasSupportsStreamCapturing = false;\n    }\n\n    if (config.useWhammyRecorder) {\n        isCanvasSupportsStreamCapturing = false;\n    }\n\n    var globalCanvas, mediaStreamRecorder;\n\n    if (isCanvasSupportsStreamCapturing) {\n        if (!config.disableLogs) {\n            console.log('Your browser supports both MediRecorder API and canvas.captureStream!');\n        }\n\n        if (htmlElement instanceof HTMLCanvasElement) {\n            globalCanvas = htmlElement;\n        } else if (htmlElement instanceof CanvasRenderingContext2D) {\n            globalCanvas = htmlElement.canvas;\n        } else {\n            throw 'Please pass either HTMLCanvasElement or CanvasRenderingContext2D.';\n        }\n    } else if (!!navigator.mozGetUserMedia) {\n        if (!config.disableLogs) {\n            console.error('Canvas recording is NOT supported in Firefox.');\n        }\n    }\n\n    var isRecording;\n\n    /**\n     * This method records Canvas.\n     * @method\n     * @memberof CanvasRecorder\n     * @example\n     * recorder.record();\n     */\n    this.record = function() {\n        isRecording = true;\n\n        if (isCanvasSupportsStreamCapturing && !config.useWhammyRecorder) {\n            // CanvasCaptureMediaStream\n            var canvasMediaStream;\n            if ('captureStream' in globalCanvas) {\n                canvasMediaStream = globalCanvas.captureStream(25); // 25 FPS\n            } else if ('mozCaptureStream' in globalCanvas) {\n                canvasMediaStream = globalCanvas.mozCaptureStream(25);\n            } else if ('webkitCaptureStream' in globalCanvas) {\n                canvasMediaStream = globalCanvas.webkitCaptureStream(25);\n            }\n\n            try {\n                var mdStream = new MediaStream();\n                mdStream.addTrack(getTracks(canvasMediaStream, 'video')[0]);\n                canvasMediaStream = mdStream;\n            } catch (e) {}\n\n            if (!canvasMediaStream) {\n                throw 'captureStream API are NOT available.';\n            }\n\n            // Note: Jan 18, 2016 status is that, \n            // Firefox MediaRecorder API can't record CanvasCaptureMediaStream object.\n            mediaStreamRecorder = new MediaStreamRecorder(canvasMediaStream, {\n                mimeType: config.mimeType || 'video/webm'\n            });\n            mediaStreamRecorder.record();\n        } else {\n            whammy.frames = [];\n            lastTime = new Date().getTime();\n            drawCanvasFrame();\n        }\n\n        if (config.initCallback) {\n            config.initCallback();\n        }\n    };\n\n    this.getWebPImages = function(callback) {\n        if (htmlElement.nodeName.toLowerCase() !== 'canvas') {\n            callback();\n            return;\n        }\n\n        var framesLength = whammy.frames.length;\n        whammy.frames.forEach(function(frame, idx) {\n            var framesRemaining = framesLength - idx;\n            if (!config.disableLogs) {\n                console.log(framesRemaining + '/' + framesLength + ' frames remaining');\n            }\n\n            if (config.onEncodingCallback) {\n                config.onEncodingCallback(framesRemaining, framesLength);\n            }\n\n            var webp = frame.image.toDataURL('image/webp', 1);\n            whammy.frames[idx].image = webp;\n        });\n\n        if (!config.disableLogs) {\n            console.log('Generating WebM');\n        }\n\n        callback();\n    };\n\n    /**\n     * This method stops recording Canvas.\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\n     * @method\n     * @memberof CanvasRecorder\n     * @example\n     * recorder.stop(function(blob) {\n     *     video.src = URL.createObjectURL(blob);\n     * });\n     */\n    this.stop = function(callback) {\n        isRecording = false;\n\n        var that = this;\n\n        if (isCanvasSupportsStreamCapturing && mediaStreamRecorder) {\n            mediaStreamRecorder.stop(callback);\n            return;\n        }\n\n        this.getWebPImages(function() {\n            /**\n             * @property {Blob} blob - Recorded frames in video/webm blob.\n             * @memberof CanvasRecorder\n             * @example\n             * recorder.stop(function() {\n             *     var blob = recorder.blob;\n             * });\n             */\n            whammy.compile(function(blob) {\n                if (!config.disableLogs) {\n                    console.log('Recording finished!');\n                }\n\n                that.blob = blob;\n\n                if (that.blob.forEach) {\n                    that.blob = new Blob([], {\n                        type: 'video/webm'\n                    });\n                }\n\n                if (callback) {\n                    callback(that.blob);\n                }\n\n                whammy.frames = [];\n            });\n        });\n    };\n\n    var isPausedRecording = false;\n\n    /**\n     * This method pauses the recording process.\n     * @method\n     * @memberof CanvasRecorder\n     * @example\n     * recorder.pause();\n     */\n    this.pause = function() {\n        isPausedRecording = true;\n\n        if (mediaStreamRecorder instanceof MediaStreamRecorder) {\n            mediaStreamRecorder.pause();\n            return;\n        }\n    };\n\n    /**\n     * This method resumes the recording process.\n     * @method\n     * @memberof CanvasRecorder\n     * @example\n     * recorder.resume();\n     */\n    this.resume = function() {\n        isPausedRecording = false;\n\n        if (mediaStreamRecorder instanceof MediaStreamRecorder) {\n            mediaStreamRecorder.resume();\n            return;\n        }\n\n        if (!isRecording) {\n            this.record();\n        }\n    };\n\n    /**\n     * This method resets currently recorded data.\n     * @method\n     * @memberof CanvasRecorder\n     * @example\n     * recorder.clearRecordedData();\n     */\n    this.clearRecordedData = function() {\n        if (isRecording) {\n            this.stop(clearRecordedDataCB);\n        }\n        clearRecordedDataCB();\n    };\n\n    function clearRecordedDataCB() {\n        whammy.frames = [];\n        isRecording = false;\n        isPausedRecording = false;\n    }\n\n    // for debugging\n    this.name = 'CanvasRecorder';\n    this.toString = function() {\n        return this.name;\n    };\n\n    function cloneCanvas() {\n        //create a new canvas\n        var newCanvas = document.createElement('canvas');\n        var context = newCanvas.getContext('2d');\n\n        //set dimensions\n        newCanvas.width = htmlElement.width;\n        newCanvas.height = htmlElement.height;\n\n        //apply the old canvas to the new one\n        context.drawImage(htmlElement, 0, 0);\n\n        //return the new canvas\n        return newCanvas;\n    }\n\n    function drawCanvasFrame() {\n        if (isPausedRecording) {\n            lastTime = new Date().getTime();\n            return setTimeout(drawCanvasFrame, 500);\n        }\n\n        if (htmlElement.nodeName.toLowerCase() === 'canvas') {\n            var duration = new Date().getTime() - lastTime;\n            // via #206, by Jack i.e. @Seymourr\n            lastTime = new Date().getTime();\n\n            whammy.frames.push({\n                image: cloneCanvas(),\n                duration: duration\n            });\n\n            if (isRecording) {\n                setTimeout(drawCanvasFrame, config.frameInterval);\n            }\n            return;\n        }\n\n        html2canvas(htmlElement, {\n            grabMouse: typeof config.showMousePointer === 'undefined' || config.showMousePointer,\n            onrendered: function(canvas) {\n                var duration = new Date().getTime() - lastTime;\n                if (!duration) {\n                    return setTimeout(drawCanvasFrame, config.frameInterval);\n                }\n\n                // via #206, by Jack i.e. @Seymourr\n                lastTime = new Date().getTime();\n\n                whammy.frames.push({\n                    image: canvas.toDataURL('image/webp', 1),\n                    duration: duration\n                });\n\n                if (isRecording) {\n                    setTimeout(drawCanvasFrame, config.frameInterval);\n                }\n            }\n        });\n    }\n\n    var lastTime = new Date().getTime();\n\n    var whammy = new Whammy.Video(100);\n}\n\nif (typeof RecordRTC !== 'undefined') {\n    RecordRTC.CanvasRecorder = CanvasRecorder;\n}\n\n// _________________\n// WhammyRecorder.js\n\n/**\n * WhammyRecorder is a standalone class used by {@link RecordRTC} to bring video recording in Chrome. It runs top over {@link Whammy}.\n * @summary Video recording feature in Chrome.\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @typedef WhammyRecorder\n * @class\n * @example\n * var recorder = new WhammyRecorder(mediaStream);\n * recorder.record();\n * recorder.stop(function(blob) {\n *     video.src = URL.createObjectURL(blob);\n * });\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\n * @param {object} config - {disableLogs: true, initCallback: function, video: HTMLVideoElement, etc.}\n */\n\nfunction WhammyRecorder(mediaStream, config) {\n\n    config = config || {};\n\n    if (!config.frameInterval) {\n        config.frameInterval = 10;\n    }\n\n    if (!config.disableLogs) {\n        console.log('Using frames-interval:', config.frameInterval);\n    }\n\n    /**\n     * This method records video.\n     * @method\n     * @memberof WhammyRecorder\n     * @example\n     * recorder.record();\n     */\n    this.record = function() {\n        if (!config.width) {\n            config.width = 320;\n        }\n\n        if (!config.height) {\n            config.height = 240;\n        }\n\n        if (!config.video) {\n            config.video = {\n                width: config.width,\n                height: config.height\n            };\n        }\n\n        if (!config.canvas) {\n            config.canvas = {\n                width: config.width,\n                height: config.height\n            };\n        }\n\n        canvas.width = config.canvas.width || 320;\n        canvas.height = config.canvas.height || 240;\n\n        context = canvas.getContext('2d');\n\n        // setting defaults\n        if (config.video && config.video instanceof HTMLVideoElement) {\n            video = config.video.cloneNode();\n\n            if (config.initCallback) {\n                config.initCallback();\n            }\n        } else {\n            video = document.createElement('video');\n\n            setSrcObject(mediaStream, video);\n\n            video.onloadedmetadata = function() { // \"onloadedmetadata\" may NOT work in FF?\n                if (config.initCallback) {\n                    config.initCallback();\n                }\n            };\n\n            video.width = config.video.width;\n            video.height = config.video.height;\n        }\n\n        video.muted = true;\n        video.play();\n\n        lastTime = new Date().getTime();\n        whammy = new Whammy.Video();\n\n        if (!config.disableLogs) {\n            console.log('canvas resolutions', canvas.width, '*', canvas.height);\n            console.log('video width/height', video.width || canvas.width, '*', video.height || canvas.height);\n        }\n\n        drawFrames(config.frameInterval);\n    };\n\n    /**\n     * Draw and push frames to Whammy\n     * @param {integer} frameInterval - set minimum interval (in milliseconds) between each time we push a frame to Whammy\n     */\n    function drawFrames(frameInterval) {\n        frameInterval = typeof frameInterval !== 'undefined' ? frameInterval : 10;\n\n        var duration = new Date().getTime() - lastTime;\n        if (!duration) {\n            return setTimeout(drawFrames, frameInterval, frameInterval);\n        }\n\n        if (isPausedRecording) {\n            lastTime = new Date().getTime();\n            return setTimeout(drawFrames, 100);\n        }\n\n        // via #206, by Jack i.e. @Seymourr\n        lastTime = new Date().getTime();\n\n        if (video.paused) {\n            // via: https://github.com/muaz-khan/WebRTC-Experiment/pull/316\n            // Tweak for Android Chrome\n            video.play();\n        }\n\n        context.drawImage(video, 0, 0, canvas.width, canvas.height);\n        whammy.frames.push({\n            duration: duration,\n            image: canvas.toDataURL('image/webp')\n        });\n\n        if (!isStopDrawing) {\n            setTimeout(drawFrames, frameInterval, frameInterval);\n        }\n    }\n\n    function asyncLoop(o) {\n        var i = -1,\n            length = o.length;\n\n        (function loop() {\n            i++;\n            if (i === length) {\n                o.callback();\n                return;\n            }\n\n            // \"setTimeout\" added by Jim McLeod\n            setTimeout(function() {\n                o.functionToLoop(loop, i);\n            }, 1);\n        })();\n    }\n\n\n    /**\n     * remove black frames from the beginning to the specified frame\n     * @param {Array} _frames - array of frames to be checked\n     * @param {number} _framesToCheck - number of frame until check will be executed (-1 - will drop all frames until frame not matched will be found)\n     * @param {number} _pixTolerance - 0 - very strict (only black pixel color) ; 1 - all\n     * @param {number} _frameTolerance - 0 - very strict (only black frame color) ; 1 - all\n     * @returns {Array} - array of frames\n     */\n    // pull#293 by @volodalexey\n    function dropBlackFrames(_frames, _framesToCheck, _pixTolerance, _frameTolerance, callback) {\n        var localCanvas = document.createElement('canvas');\n        localCanvas.width = canvas.width;\n        localCanvas.height = canvas.height;\n        var context2d = localCanvas.getContext('2d');\n        var resultFrames = [];\n\n        var checkUntilNotBlack = _framesToCheck === -1;\n        var endCheckFrame = (_framesToCheck && _framesToCheck > 0 && _framesToCheck <= _frames.length) ?\n            _framesToCheck : _frames.length;\n        var sampleColor = {\n            r: 0,\n            g: 0,\n            b: 0\n        };\n        var maxColorDifference = Math.sqrt(\n            Math.pow(255, 2) +\n            Math.pow(255, 2) +\n            Math.pow(255, 2)\n        );\n        var pixTolerance = _pixTolerance && _pixTolerance >= 0 && _pixTolerance <= 1 ? _pixTolerance : 0;\n        var frameTolerance = _frameTolerance && _frameTolerance >= 0 && _frameTolerance <= 1 ? _frameTolerance : 0;\n        var doNotCheckNext = false;\n\n        asyncLoop({\n            length: endCheckFrame,\n            functionToLoop: function(loop, f) {\n                var matchPixCount, endPixCheck, maxPixCount;\n\n                var finishImage = function() {\n                    if (!doNotCheckNext && maxPixCount - matchPixCount <= maxPixCount * frameTolerance) {\n                        // console.log('removed black frame : ' + f + ' ; frame duration ' + _frames[f].duration);\n                    } else {\n                        // console.log('frame is passed : ' + f);\n                        if (checkUntilNotBlack) {\n                            doNotCheckNext = true;\n                        }\n                        resultFrames.push(_frames[f]);\n                    }\n                    loop();\n                };\n\n                if (!doNotCheckNext) {\n                    var image = new Image();\n                    image.onload = function() {\n                        context2d.drawImage(image, 0, 0, canvas.width, canvas.height);\n                        var imageData = context2d.getImageData(0, 0, canvas.width, canvas.height);\n                        matchPixCount = 0;\n                        endPixCheck = imageData.data.length;\n                        maxPixCount = imageData.data.length / 4;\n\n                        for (var pix = 0; pix < endPixCheck; pix += 4) {\n                            var currentColor = {\n                                r: imageData.data[pix],\n                                g: imageData.data[pix + 1],\n                                b: imageData.data[pix + 2]\n                            };\n                            var colorDifference = Math.sqrt(\n                                Math.pow(currentColor.r - sampleColor.r, 2) +\n                                Math.pow(currentColor.g - sampleColor.g, 2) +\n                                Math.pow(currentColor.b - sampleColor.b, 2)\n                            );\n                            // difference in color it is difference in color vectors (r1,g1,b1) <=> (r2,g2,b2)\n                            if (colorDifference <= maxColorDifference * pixTolerance) {\n                                matchPixCount++;\n                            }\n                        }\n                        finishImage();\n                    };\n                    image.src = _frames[f].image;\n                } else {\n                    finishImage();\n                }\n            },\n            callback: function() {\n                resultFrames = resultFrames.concat(_frames.slice(endCheckFrame));\n\n                if (resultFrames.length <= 0) {\n                    // at least one last frame should be available for next manipulation\n                    // if total duration of all frames will be < 1000 than ffmpeg doesn't work well...\n                    resultFrames.push(_frames[_frames.length - 1]);\n                }\n                callback(resultFrames);\n            }\n        });\n    }\n\n    var isStopDrawing = false;\n\n    /**\n     * This method stops recording video.\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\n     * @method\n     * @memberof WhammyRecorder\n     * @example\n     * recorder.stop(function(blob) {\n     *     video.src = URL.createObjectURL(blob);\n     * });\n     */\n    this.stop = function(callback) {\n        callback = callback || function() {};\n\n        isStopDrawing = true;\n\n        var _this = this;\n        // analyse of all frames takes some time!\n        setTimeout(function() {\n            // e.g. dropBlackFrames(frames, 10, 1, 1) - will cut all 10 frames\n            // e.g. dropBlackFrames(frames, 10, 0.5, 0.5) - will analyse 10 frames\n            // e.g. dropBlackFrames(frames, 10) === dropBlackFrames(frames, 10, 0, 0) - will analyse 10 frames with strict black color\n            dropBlackFrames(whammy.frames, -1, null, null, function(frames) {\n                whammy.frames = frames;\n\n                // to display advertisement images!\n                if (config.advertisement && config.advertisement.length) {\n                    whammy.frames = config.advertisement.concat(whammy.frames);\n                }\n\n                /**\n                 * @property {Blob} blob - Recorded frames in video/webm blob.\n                 * @memberof WhammyRecorder\n                 * @example\n                 * recorder.stop(function() {\n                 *     var blob = recorder.blob;\n                 * });\n                 */\n                whammy.compile(function(blob) {\n                    _this.blob = blob;\n\n                    if (_this.blob.forEach) {\n                        _this.blob = new Blob([], {\n                            type: 'video/webm'\n                        });\n                    }\n\n                    if (callback) {\n                        callback(_this.blob);\n                    }\n                });\n            });\n        }, 10);\n    };\n\n    var isPausedRecording = false;\n\n    /**\n     * This method pauses the recording process.\n     * @method\n     * @memberof WhammyRecorder\n     * @example\n     * recorder.pause();\n     */\n    this.pause = function() {\n        isPausedRecording = true;\n    };\n\n    /**\n     * This method resumes the recording process.\n     * @method\n     * @memberof WhammyRecorder\n     * @example\n     * recorder.resume();\n     */\n    this.resume = function() {\n        isPausedRecording = false;\n\n        if (isStopDrawing) {\n            this.record();\n        }\n    };\n\n    /**\n     * This method resets currently recorded data.\n     * @method\n     * @memberof WhammyRecorder\n     * @example\n     * recorder.clearRecordedData();\n     */\n    this.clearRecordedData = function() {\n        if (!isStopDrawing) {\n            this.stop(clearRecordedDataCB);\n        }\n        clearRecordedDataCB();\n    };\n\n    function clearRecordedDataCB() {\n        whammy.frames = [];\n        isStopDrawing = true;\n        isPausedRecording = false;\n    }\n\n    // for debugging\n    this.name = 'WhammyRecorder';\n    this.toString = function() {\n        return this.name;\n    };\n\n    var canvas = document.createElement('canvas');\n    var context = canvas.getContext('2d');\n\n    var video;\n    var lastTime;\n    var whammy;\n}\n\nif (typeof RecordRTC !== 'undefined') {\n    RecordRTC.WhammyRecorder = WhammyRecorder;\n}\n\n// https://github.com/antimatter15/whammy/blob/master/LICENSE\n// _________\n// Whammy.js\n\n// todo: Firefox now supports webp for webm containers!\n// their MediaRecorder implementation works well!\n// should we provide an option to record via Whammy.js or MediaRecorder API is a better solution?\n\n/**\n * Whammy is a standalone class used by {@link RecordRTC} to bring video recording in Chrome. It is written by {@link https://github.com/antimatter15|antimatter15}\n * @summary A real time javascript webm encoder based on a canvas hack.\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @typedef Whammy\n * @class\n * @example\n * var recorder = new Whammy().Video(15);\n * recorder.add(context || canvas || dataURL);\n * var output = recorder.compile();\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n */\n\nvar Whammy = (function() {\n    // a more abstract-ish API\n\n    function WhammyVideo(duration) {\n        this.frames = [];\n        this.duration = duration || 1;\n        this.quality = 0.8;\n    }\n\n    /**\n     * Pass Canvas or Context or image/webp(string) to {@link Whammy} encoder.\n     * @method\n     * @memberof Whammy\n     * @example\n     * recorder = new Whammy().Video(0.8, 100);\n     * recorder.add(canvas || context || 'image/webp');\n     * @param {string} frame - Canvas || Context || image/webp\n     * @param {number} duration - Stick a duration (in milliseconds)\n     */\n    WhammyVideo.prototype.add = function(frame, duration) {\n        if ('canvas' in frame) { //CanvasRenderingContext2D\n            frame = frame.canvas;\n        }\n\n        if ('toDataURL' in frame) {\n            frame = frame.toDataURL('image/webp', this.quality);\n        }\n\n        if (!(/^data:image\\/webp;base64,/ig).test(frame)) {\n            throw 'Input must be formatted properly as a base64 encoded DataURI of type image/webp';\n        }\n        this.frames.push({\n            image: frame,\n            duration: duration || this.duration\n        });\n    };\n\n    function processInWebWorker(_function) {\n        var blob = URL.createObjectURL(new Blob([_function.toString(),\n            'this.onmessage =  function (eee) {' + _function.name + '(eee.data);}'\n        ], {\n            type: 'application/javascript'\n        }));\n\n        var worker = new Worker(blob);\n        URL.revokeObjectURL(blob);\n        return worker;\n    }\n\n    function whammyInWebWorker(frames) {\n        function ArrayToWebM(frames) {\n            var info = checkFrames(frames);\n            if (!info) {\n                return [];\n            }\n\n            var clusterMaxDuration = 30000;\n\n            var EBML = [{\n                'id': 0x1a45dfa3, // EBML\n                'data': [{\n                    'data': 1,\n                    'id': 0x4286 // EBMLVersion\n                }, {\n                    'data': 1,\n                    'id': 0x42f7 // EBMLReadVersion\n                }, {\n                    'data': 4,\n                    'id': 0x42f2 // EBMLMaxIDLength\n                }, {\n                    'data': 8,\n                    'id': 0x42f3 // EBMLMaxSizeLength\n                }, {\n                    'data': 'webm',\n                    'id': 0x4282 // DocType\n                }, {\n                    'data': 2,\n                    'id': 0x4287 // DocTypeVersion\n                }, {\n                    'data': 2,\n                    'id': 0x4285 // DocTypeReadVersion\n                }]\n            }, {\n                'id': 0x18538067, // Segment\n                'data': [{\n                    'id': 0x1549a966, // Info\n                    'data': [{\n                        'data': 1e6, //do things in millisecs (num of nanosecs for duration scale)\n                        'id': 0x2ad7b1 // TimecodeScale\n                    }, {\n                        'data': 'whammy',\n                        'id': 0x4d80 // MuxingApp\n                    }, {\n                        'data': 'whammy',\n                        'id': 0x5741 // WritingApp\n                    }, {\n                        'data': doubleToString(info.duration),\n                        'id': 0x4489 // Duration\n                    }]\n                }, {\n                    'id': 0x1654ae6b, // Tracks\n                    'data': [{\n                        'id': 0xae, // TrackEntry\n                        'data': [{\n                            'data': 1,\n                            'id': 0xd7 // TrackNumber\n                        }, {\n                            'data': 1,\n                            'id': 0x73c5 // TrackUID\n                        }, {\n                            'data': 0,\n                            'id': 0x9c // FlagLacing\n                        }, {\n                            'data': 'und',\n                            'id': 0x22b59c // Language\n                        }, {\n                            'data': 'V_VP8',\n                            'id': 0x86 // CodecID\n                        }, {\n                            'data': 'VP8',\n                            'id': 0x258688 // CodecName\n                        }, {\n                            'data': 1,\n                            'id': 0x83 // TrackType\n                        }, {\n                            'id': 0xe0, // Video\n                            'data': [{\n                                'data': info.width,\n                                'id': 0xb0 // PixelWidth\n                            }, {\n                                'data': info.height,\n                                'id': 0xba // PixelHeight\n                            }]\n                        }]\n                    }]\n                }]\n            }];\n\n            //Generate clusters (max duration)\n            var frameNumber = 0;\n            var clusterTimecode = 0;\n            while (frameNumber < frames.length) {\n\n                var clusterFrames = [];\n                var clusterDuration = 0;\n                do {\n                    clusterFrames.push(frames[frameNumber]);\n                    clusterDuration += frames[frameNumber].duration;\n                    frameNumber++;\n                } while (frameNumber < frames.length && clusterDuration < clusterMaxDuration);\n\n                var clusterCounter = 0;\n                var cluster = {\n                    'id': 0x1f43b675, // Cluster\n                    'data': getClusterData(clusterTimecode, clusterCounter, clusterFrames)\n                }; //Add cluster to segment\n                EBML[1].data.push(cluster);\n                clusterTimecode += clusterDuration;\n            }\n\n            return generateEBML(EBML);\n        }\n\n        function getClusterData(clusterTimecode, clusterCounter, clusterFrames) {\n            return [{\n                'data': clusterTimecode,\n                'id': 0xe7 // Timecode\n            }].concat(clusterFrames.map(function(webp) {\n                var block = makeSimpleBlock({\n                    discardable: 0,\n                    frame: webp.data.slice(4),\n                    invisible: 0,\n                    keyframe: 1,\n                    lacing: 0,\n                    trackNum: 1,\n                    timecode: Math.round(clusterCounter)\n                });\n                clusterCounter += webp.duration;\n                return {\n                    data: block,\n                    id: 0xa3\n                };\n            }));\n        }\n\n        // sums the lengths of all the frames and gets the duration\n\n        function checkFrames(frames) {\n            if (!frames[0]) {\n                postMessage({\n                    error: 'Something went wrong. Maybe WebP format is not supported in the current browser.'\n                });\n                return;\n            }\n\n            var width = frames[0].width,\n                height = frames[0].height,\n                duration = frames[0].duration;\n\n            for (var i = 1; i < frames.length; i++) {\n                duration += frames[i].duration;\n            }\n            return {\n                duration: duration,\n                width: width,\n                height: height\n            };\n        }\n\n        function numToBuffer(num) {\n            var parts = [];\n            while (num > 0) {\n                parts.push(num & 0xff);\n                num = num >> 8;\n            }\n            return new Uint8Array(parts.reverse());\n        }\n\n        function strToBuffer(str) {\n            return new Uint8Array(str.split('').map(function(e) {\n                return e.charCodeAt(0);\n            }));\n        }\n\n        function bitsToBuffer(bits) {\n            var data = [];\n            var pad = (bits.length % 8) ? (new Array(1 + 8 - (bits.length % 8))).join('0') : '';\n            bits = pad + bits;\n            for (var i = 0; i < bits.length; i += 8) {\n                data.push(parseInt(bits.substr(i, 8), 2));\n            }\n            return new Uint8Array(data);\n        }\n\n        function generateEBML(json) {\n            var ebml = [];\n            for (var i = 0; i < json.length; i++) {\n                var data = json[i].data;\n\n                if (typeof data === 'object') {\n                    data = generateEBML(data);\n                }\n\n                if (typeof data === 'number') {\n                    data = bitsToBuffer(data.toString(2));\n                }\n\n                if (typeof data === 'string') {\n                    data = strToBuffer(data);\n                }\n\n                var len = data.size || data.byteLength || data.length;\n                var zeroes = Math.ceil(Math.ceil(Math.log(len) / Math.log(2)) / 8);\n                var sizeToString = len.toString(2);\n                var padded = (new Array((zeroes * 7 + 7 + 1) - sizeToString.length)).join('0') + sizeToString;\n                var size = (new Array(zeroes)).join('0') + '1' + padded;\n\n                ebml.push(numToBuffer(json[i].id));\n                ebml.push(bitsToBuffer(size));\n                ebml.push(data);\n            }\n\n            return new Blob(ebml, {\n                type: 'video/webm'\n            });\n        }\n\n        function toBinStrOld(bits) {\n            var data = '';\n            var pad = (bits.length % 8) ? (new Array(1 + 8 - (bits.length % 8))).join('0') : '';\n            bits = pad + bits;\n            for (var i = 0; i < bits.length; i += 8) {\n                data += String.fromCharCode(parseInt(bits.substr(i, 8), 2));\n            }\n            return data;\n        }\n\n        function makeSimpleBlock(data) {\n            var flags = 0;\n\n            if (data.keyframe) {\n                flags |= 128;\n            }\n\n            if (data.invisible) {\n                flags |= 8;\n            }\n\n            if (data.lacing) {\n                flags |= (data.lacing << 1);\n            }\n\n            if (data.discardable) {\n                flags |= 1;\n            }\n\n            if (data.trackNum > 127) {\n                throw 'TrackNumber > 127 not supported';\n            }\n\n            var out = [data.trackNum | 0x80, data.timecode >> 8, data.timecode & 0xff, flags].map(function(e) {\n                return String.fromCharCode(e);\n            }).join('') + data.frame;\n\n            return out;\n        }\n\n        function parseWebP(riff) {\n            var VP8 = riff.RIFF[0].WEBP[0];\n\n            var frameStart = VP8.indexOf('\\x9d\\x01\\x2a'); // A VP8 keyframe starts with the 0x9d012a header\n            for (var i = 0, c = []; i < 4; i++) {\n                c[i] = VP8.charCodeAt(frameStart + 3 + i);\n            }\n\n            var width, height, tmp;\n\n            //the code below is literally copied verbatim from the bitstream spec\n            tmp = (c[1] << 8) | c[0];\n            width = tmp & 0x3FFF;\n            tmp = (c[3] << 8) | c[2];\n            height = tmp & 0x3FFF;\n            return {\n                width: width,\n                height: height,\n                data: VP8,\n                riff: riff\n            };\n        }\n\n        function getStrLength(string, offset) {\n            return parseInt(string.substr(offset + 4, 4).split('').map(function(i) {\n                var unpadded = i.charCodeAt(0).toString(2);\n                return (new Array(8 - unpadded.length + 1)).join('0') + unpadded;\n            }).join(''), 2);\n        }\n\n        function parseRIFF(string) {\n            var offset = 0;\n            var chunks = {};\n\n            while (offset < string.length) {\n                var id = string.substr(offset, 4);\n                var len = getStrLength(string, offset);\n                var data = string.substr(offset + 4 + 4, len);\n                offset += 4 + 4 + len;\n                chunks[id] = chunks[id] || [];\n\n                if (id === 'RIFF' || id === 'LIST') {\n                    chunks[id].push(parseRIFF(data));\n                } else {\n                    chunks[id].push(data);\n                }\n            }\n            return chunks;\n        }\n\n        function doubleToString(num) {\n            return [].slice.call(\n                new Uint8Array((new Float64Array([num])).buffer), 0).map(function(e) {\n                return String.fromCharCode(e);\n            }).reverse().join('');\n        }\n\n        var webm = new ArrayToWebM(frames.map(function(frame) {\n            var webp = parseWebP(parseRIFF(atob(frame.image.slice(23))));\n            webp.duration = frame.duration;\n            return webp;\n        }));\n\n        postMessage(webm);\n    }\n\n    /**\n     * Encodes frames in WebM container. It uses WebWorkinvoke to invoke 'ArrayToWebM' method.\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\n     * @method\n     * @memberof Whammy\n     * @example\n     * recorder = new Whammy().Video(0.8, 100);\n     * recorder.compile(function(blob) {\n     *    // blob.size - blob.type\n     * });\n     */\n    WhammyVideo.prototype.compile = function(callback) {\n        var webWorker = processInWebWorker(whammyInWebWorker);\n\n        webWorker.onmessage = function(event) {\n            if (event.data.error) {\n                console.error(event.data.error);\n                return;\n            }\n            callback(event.data);\n        };\n\n        webWorker.postMessage(this.frames);\n    };\n\n    return {\n        /**\n         * A more abstract-ish API.\n         * @method\n         * @memberof Whammy\n         * @example\n         * recorder = new Whammy().Video(0.8, 100);\n         * @param {?number} speed - 0.8\n         * @param {?number} quality - 100\n         */\n        Video: WhammyVideo\n    };\n})();\n\nif (typeof RecordRTC !== 'undefined') {\n    RecordRTC.Whammy = Whammy;\n}\n\n// ______________ (indexed-db)\n// DiskStorage.js\n\n/**\n * DiskStorage is a standalone object used by {@link RecordRTC} to store recorded blobs in IndexedDB storage.\n * @summary Writing blobs into IndexedDB.\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @example\n * DiskStorage.Store({\n *     audioBlob: yourAudioBlob,\n *     videoBlob: yourVideoBlob,\n *     gifBlob  : yourGifBlob\n * });\n * DiskStorage.Fetch(function(dataURL, type) {\n *     if(type === 'audioBlob') { }\n *     if(type === 'videoBlob') { }\n *     if(type === 'gifBlob')   { }\n * });\n * // DiskStorage.dataStoreName = 'recordRTC';\n * // DiskStorage.onError = function(error) { };\n * @property {function} init - This method must be called once to initialize IndexedDB ObjectStore. Though, it is auto-used internally.\n * @property {function} Fetch - This method fetches stored blobs from IndexedDB.\n * @property {function} Store - This method stores blobs in IndexedDB.\n * @property {function} onError - This function is invoked for any known/unknown error.\n * @property {string} dataStoreName - Name of the ObjectStore created in IndexedDB storage.\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n */\n\n\nvar DiskStorage = {\n    /**\n     * This method must be called once to initialize IndexedDB ObjectStore. Though, it is auto-used internally.\n     * @method\n     * @memberof DiskStorage\n     * @internal\n     * @example\n     * DiskStorage.init();\n     */\n    init: function() {\n        var self = this;\n\n        if (typeof indexedDB === 'undefined' || typeof indexedDB.open === 'undefined') {\n            console.error('IndexedDB API are not available in this browser.');\n            return;\n        }\n\n        var dbVersion = 1;\n        var dbName = this.dbName || location.href.replace(/\\/|:|#|%|\\.|\\[|\\]/g, ''),\n            db;\n        var request = indexedDB.open(dbName, dbVersion);\n\n        function createObjectStore(dataBase) {\n            dataBase.createObjectStore(self.dataStoreName);\n        }\n\n        function putInDB() {\n            var transaction = db.transaction([self.dataStoreName], 'readwrite');\n\n            if (self.videoBlob) {\n                transaction.objectStore(self.dataStoreName).put(self.videoBlob, 'videoBlob');\n            }\n\n            if (self.gifBlob) {\n                transaction.objectStore(self.dataStoreName).put(self.gifBlob, 'gifBlob');\n            }\n\n            if (self.audioBlob) {\n                transaction.objectStore(self.dataStoreName).put(self.audioBlob, 'audioBlob');\n            }\n\n            function getFromStore(portionName) {\n                transaction.objectStore(self.dataStoreName).get(portionName).onsuccess = function(event) {\n                    if (self.callback) {\n                        self.callback(event.target.result, portionName);\n                    }\n                };\n            }\n\n            getFromStore('audioBlob');\n            getFromStore('videoBlob');\n            getFromStore('gifBlob');\n        }\n\n        request.onerror = self.onError;\n\n        request.onsuccess = function() {\n            db = request.result;\n            db.onerror = self.onError;\n\n            if (db.setVersion) {\n                if (db.version !== dbVersion) {\n                    var setVersion = db.setVersion(dbVersion);\n                    setVersion.onsuccess = function() {\n                        createObjectStore(db);\n                        putInDB();\n                    };\n                } else {\n                    putInDB();\n                }\n            } else {\n                putInDB();\n            }\n        };\n        request.onupgradeneeded = function(event) {\n            createObjectStore(event.target.result);\n        };\n    },\n    /**\n     * This method fetches stored blobs from IndexedDB.\n     * @method\n     * @memberof DiskStorage\n     * @internal\n     * @example\n     * DiskStorage.Fetch(function(dataURL, type) {\n     *     if(type === 'audioBlob') { }\n     *     if(type === 'videoBlob') { }\n     *     if(type === 'gifBlob')   { }\n     * });\n     */\n    Fetch: function(callback) {\n        this.callback = callback;\n        this.init();\n\n        return this;\n    },\n    /**\n     * This method stores blobs in IndexedDB.\n     * @method\n     * @memberof DiskStorage\n     * @internal\n     * @example\n     * DiskStorage.Store({\n     *     audioBlob: yourAudioBlob,\n     *     videoBlob: yourVideoBlob,\n     *     gifBlob  : yourGifBlob\n     * });\n     */\n    Store: function(config) {\n        this.audioBlob = config.audioBlob;\n        this.videoBlob = config.videoBlob;\n        this.gifBlob = config.gifBlob;\n\n        this.init();\n\n        return this;\n    },\n    /**\n     * This function is invoked for any known/unknown error.\n     * @method\n     * @memberof DiskStorage\n     * @internal\n     * @example\n     * DiskStorage.onError = function(error){\n     *     alerot( JSON.stringify(error) );\n     * };\n     */\n    onError: function(error) {\n        console.error(JSON.stringify(error, null, '\\t'));\n    },\n\n    /**\n     * @property {string} dataStoreName - Name of the ObjectStore created in IndexedDB storage.\n     * @memberof DiskStorage\n     * @internal\n     * @example\n     * DiskStorage.dataStoreName = 'recordRTC';\n     */\n    dataStoreName: 'recordRTC',\n    dbName: null\n};\n\nif (typeof RecordRTC !== 'undefined') {\n    RecordRTC.DiskStorage = DiskStorage;\n}\n\n// ______________\n// GifRecorder.js\n\n/**\n * GifRecorder is standalone calss used by {@link RecordRTC} to record video or canvas into animated gif.\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @typedef GifRecorder\n * @class\n * @example\n * var recorder = new GifRecorder(mediaStream || canvas || context, { onGifPreview: function, onGifRecordingStarted: function, width: 1280, height: 720, frameRate: 200, quality: 10 });\n * recorder.record();\n * recorder.stop(function(blob) {\n *     img.src = URL.createObjectURL(blob);\n * });\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n * @param {MediaStream} mediaStream - MediaStream object or HTMLCanvasElement or CanvasRenderingContext2D.\n * @param {object} config - {disableLogs:true, initCallback: function, width: 320, height: 240, frameRate: 200, quality: 10}\n */\n\nfunction GifRecorder(mediaStream, config) {\n    if (typeof GIFEncoder === 'undefined') {\n        var script = document.createElement('script');\n        script.src = 'https://www.webrtc-experiment.com/gif-recorder.js';\n        (document.body || document.documentElement).appendChild(script);\n    }\n\n    config = config || {};\n\n    var isHTMLObject = mediaStream instanceof CanvasRenderingContext2D || mediaStream instanceof HTMLCanvasElement;\n\n    /**\n     * This method records MediaStream.\n     * @method\n     * @memberof GifRecorder\n     * @example\n     * recorder.record();\n     */\n    this.record = function() {\n        if (typeof GIFEncoder === 'undefined') {\n            setTimeout(self.record, 1000);\n            return;\n        }\n\n        if (!isLoadedMetaData) {\n            setTimeout(self.record, 1000);\n            return;\n        }\n\n        if (!isHTMLObject) {\n            if (!config.width) {\n                config.width = video.offsetWidth || 320;\n            }\n\n            if (!config.height) {\n                config.height = video.offsetHeight || 240;\n            }\n\n            if (!config.video) {\n                config.video = {\n                    width: config.width,\n                    height: config.height\n                };\n            }\n\n            if (!config.canvas) {\n                config.canvas = {\n                    width: config.width,\n                    height: config.height\n                };\n            }\n\n            canvas.width = config.canvas.width || 320;\n            canvas.height = config.canvas.height || 240;\n\n            video.width = config.video.width || 320;\n            video.height = config.video.height || 240;\n        }\n\n        // external library to record as GIF images\n        gifEncoder = new GIFEncoder();\n\n        // void setRepeat(int iter) \n        // Sets the number of times the set of GIF frames should be played. \n        // Default is 1; 0 means play indefinitely.\n        gifEncoder.setRepeat(0);\n\n        // void setFrameRate(Number fps) \n        // Sets frame rate in frames per second. \n        // Equivalent to setDelay(1000/fps).\n        // Using \"setDelay\" instead of \"setFrameRate\"\n        gifEncoder.setDelay(config.frameRate || 200);\n\n        // void setQuality(int quality) \n        // Sets quality of color quantization (conversion of images to the \n        // maximum 256 colors allowed by the GIF specification). \n        // Lower values (minimum = 1) produce better colors, \n        // but slow processing significantly. 10 is the default, \n        // and produces good color mapping at reasonable speeds. \n        // Values greater than 20 do not yield significant improvements in speed.\n        gifEncoder.setQuality(config.quality || 10);\n\n        // Boolean start() \n        // This writes the GIF Header and returns false if it fails.\n        gifEncoder.start();\n\n        if (typeof config.onGifRecordingStarted === 'function') {\n            config.onGifRecordingStarted();\n        }\n\n        startTime = Date.now();\n\n        function drawVideoFrame(time) {\n            if (self.clearedRecordedData === true) {\n                return;\n            }\n\n            if (isPausedRecording) {\n                return setTimeout(function() {\n                    drawVideoFrame(time);\n                }, 100);\n            }\n\n            lastAnimationFrame = requestAnimationFrame(drawVideoFrame);\n\n            if (typeof lastFrameTime === undefined) {\n                lastFrameTime = time;\n            }\n\n            // ~10 fps\n            if (time - lastFrameTime < 90) {\n                return;\n            }\n\n            if (!isHTMLObject && video.paused) {\n                // via: https://github.com/muaz-khan/WebRTC-Experiment/pull/316\n                // Tweak for Android Chrome\n                video.play();\n            }\n\n            if (!isHTMLObject) {\n                context.drawImage(video, 0, 0, canvas.width, canvas.height);\n            }\n\n            if (config.onGifPreview) {\n                config.onGifPreview(canvas.toDataURL('image/png'));\n            }\n\n            gifEncoder.addFrame(context);\n            lastFrameTime = time;\n        }\n\n        lastAnimationFrame = requestAnimationFrame(drawVideoFrame);\n\n        if (config.initCallback) {\n            config.initCallback();\n        }\n    };\n\n    /**\n     * This method stops recording MediaStream.\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\n     * @method\n     * @memberof GifRecorder\n     * @example\n     * recorder.stop(function(blob) {\n     *     img.src = URL.createObjectURL(blob);\n     * });\n     */\n    this.stop = function(callback) {\n        callback = callback || function() {};\n\n        if (lastAnimationFrame) {\n            cancelAnimationFrame(lastAnimationFrame);\n        }\n\n        endTime = Date.now();\n\n        /**\n         * @property {Blob} blob - The recorded blob object.\n         * @memberof GifRecorder\n         * @example\n         * recorder.stop(function(){\n         *     var blob = recorder.blob;\n         * });\n         */\n        this.blob = new Blob([new Uint8Array(gifEncoder.stream().bin)], {\n            type: 'image/gif'\n        });\n\n        callback(this.blob);\n\n        // bug: find a way to clear old recorded blobs\n        gifEncoder.stream().bin = [];\n    };\n\n    var isPausedRecording = false;\n\n    /**\n     * This method pauses the recording process.\n     * @method\n     * @memberof GifRecorder\n     * @example\n     * recorder.pause();\n     */\n    this.pause = function() {\n        isPausedRecording = true;\n    };\n\n    /**\n     * This method resumes the recording process.\n     * @method\n     * @memberof GifRecorder\n     * @example\n     * recorder.resume();\n     */\n    this.resume = function() {\n        isPausedRecording = false;\n    };\n\n    /**\n     * This method resets currently recorded data.\n     * @method\n     * @memberof GifRecorder\n     * @example\n     * recorder.clearRecordedData();\n     */\n    this.clearRecordedData = function() {\n        self.clearedRecordedData = true;\n        clearRecordedDataCB();\n    };\n\n    function clearRecordedDataCB() {\n        if (gifEncoder) {\n            gifEncoder.stream().bin = [];\n        }\n    }\n\n    // for debugging\n    this.name = 'GifRecorder';\n    this.toString = function() {\n        return this.name;\n    };\n\n    var canvas = document.createElement('canvas');\n    var context = canvas.getContext('2d');\n\n    if (isHTMLObject) {\n        if (mediaStream instanceof CanvasRenderingContext2D) {\n            context = mediaStream;\n            canvas = context.canvas;\n        } else if (mediaStream instanceof HTMLCanvasElement) {\n            context = mediaStream.getContext('2d');\n            canvas = mediaStream;\n        }\n    }\n\n    var isLoadedMetaData = true;\n\n    if (!isHTMLObject) {\n        var video = document.createElement('video');\n        video.muted = true;\n        video.autoplay = true;\n        video.playsInline = true;\n\n        isLoadedMetaData = false;\n        video.onloadedmetadata = function() {\n            isLoadedMetaData = true;\n        };\n\n        setSrcObject(mediaStream, video);\n\n        video.play();\n    }\n\n    var lastAnimationFrame = null;\n    var startTime, endTime, lastFrameTime;\n\n    var gifEncoder;\n\n    var self = this;\n}\n\nif (typeof RecordRTC !== 'undefined') {\n    RecordRTC.GifRecorder = GifRecorder;\n}\n\n// Last time updated: 2019-06-21 4:09:42 AM UTC\n\n// ________________________\n// MultiStreamsMixer v1.2.2\n\n// Open-Sourced: https://github.com/muaz-khan/MultiStreamsMixer\n\n// --------------------------------------------------\n// Muaz Khan     - www.MuazKhan.com\n// MIT License   - www.WebRTC-Experiment.com/licence\n// --------------------------------------------------\n\nfunction MultiStreamsMixer(arrayOfMediaStreams, elementClass) {\n\n    var browserFakeUserAgent = 'Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45';\n\n    (function(that) {\n        if (typeof RecordRTC !== 'undefined') {\n            return;\n        }\n\n        if (!that) {\n            return;\n        }\n\n        if (typeof window !== 'undefined') {\n            return;\n        }\n\n        if (typeof global === 'undefined') {\n            return;\n        }\n\n        global.navigator = {\n            userAgent: browserFakeUserAgent,\n            getUserMedia: function() {}\n        };\n\n        if (!global.console) {\n            global.console = {};\n        }\n\n        if (typeof global.console.log === 'undefined' || typeof global.console.error === 'undefined') {\n            global.console.error = global.console.log = global.console.log || function() {\n                console.log(arguments);\n            };\n        }\n\n        if (typeof document === 'undefined') {\n            /*global document:true */\n            that.document = {\n                documentElement: {\n                    appendChild: function() {\n                        return '';\n                    }\n                }\n            };\n\n            document.createElement = document.captureStream = document.mozCaptureStream = function() {\n                var obj = {\n                    getContext: function() {\n                        return obj;\n                    },\n                    play: function() {},\n                    pause: function() {},\n                    drawImage: function() {},\n                    toDataURL: function() {\n                        return '';\n                    },\n                    style: {}\n                };\n                return obj;\n            };\n\n            that.HTMLVideoElement = function() {};\n        }\n\n        if (typeof location === 'undefined') {\n            /*global location:true */\n            that.location = {\n                protocol: 'file:',\n                href: '',\n                hash: ''\n            };\n        }\n\n        if (typeof screen === 'undefined') {\n            /*global screen:true */\n            that.screen = {\n                width: 0,\n                height: 0\n            };\n        }\n\n        if (typeof URL === 'undefined') {\n            /*global screen:true */\n            that.URL = {\n                createObjectURL: function() {\n                    return '';\n                },\n                revokeObjectURL: function() {\n                    return '';\n                }\n            };\n        }\n\n        /*global window:true */\n        that.window = global;\n    })(typeof global !== 'undefined' ? global : null);\n\n    // requires: chrome://flags/#enable-experimental-web-platform-features\n\n    elementClass = elementClass || 'multi-streams-mixer';\n\n    var videos = [];\n    var isStopDrawingFrames = false;\n\n    var canvas = document.createElement('canvas');\n    var context = canvas.getContext('2d');\n    canvas.style.opacity = 0;\n    canvas.style.position = 'absolute';\n    canvas.style.zIndex = -1;\n    canvas.style.top = '-1000em';\n    canvas.style.left = '-1000em';\n    canvas.className = elementClass;\n    (document.body || document.documentElement).appendChild(canvas);\n\n    this.disableLogs = false;\n    this.frameInterval = 10;\n\n    this.width = 360;\n    this.height = 240;\n\n    // use gain node to prevent echo\n    this.useGainNode = true;\n\n    var self = this;\n\n    // _____________________________\n    // Cross-Browser-Declarations.js\n\n    // WebAudio API representer\n    var AudioContext = window.AudioContext;\n\n    if (typeof AudioContext === 'undefined') {\n        if (typeof webkitAudioContext !== 'undefined') {\n            /*global AudioContext:true */\n            AudioContext = webkitAudioContext;\n        }\n\n        if (typeof mozAudioContext !== 'undefined') {\n            /*global AudioContext:true */\n            AudioContext = mozAudioContext;\n        }\n    }\n\n    /*jshint -W079 */\n    var URL = window.URL;\n\n    if (typeof URL === 'undefined' && typeof webkitURL !== 'undefined') {\n        /*global URL:true */\n        URL = webkitURL;\n    }\n\n    if (typeof navigator !== 'undefined' && typeof navigator.getUserMedia === 'undefined') { // maybe window.navigator?\n        if (typeof navigator.webkitGetUserMedia !== 'undefined') {\n            navigator.getUserMedia = navigator.webkitGetUserMedia;\n        }\n\n        if (typeof navigator.mozGetUserMedia !== 'undefined') {\n            navigator.getUserMedia = navigator.mozGetUserMedia;\n        }\n    }\n\n    var MediaStream = window.MediaStream;\n\n    if (typeof MediaStream === 'undefined' && typeof webkitMediaStream !== 'undefined') {\n        MediaStream = webkitMediaStream;\n    }\n\n    /*global MediaStream:true */\n    if (typeof MediaStream !== 'undefined') {\n        // override \"stop\" method for all browsers\n        if (typeof MediaStream.prototype.stop === 'undefined') {\n            MediaStream.prototype.stop = function() {\n                this.getTracks().forEach(function(track) {\n                    track.stop();\n                });\n            };\n        }\n    }\n\n    var Storage = {};\n\n    if (typeof AudioContext !== 'undefined') {\n        Storage.AudioContext = AudioContext;\n    } else if (typeof webkitAudioContext !== 'undefined') {\n        Storage.AudioContext = webkitAudioContext;\n    }\n\n    function setSrcObject(stream, element) {\n        if ('srcObject' in element) {\n            element.srcObject = stream;\n        } else if ('mozSrcObject' in element) {\n            element.mozSrcObject = stream;\n        } else {\n            element.srcObject = stream;\n        }\n    }\n\n    this.startDrawingFrames = function() {\n        drawVideosToCanvas();\n    };\n\n    function drawVideosToCanvas() {\n        if (isStopDrawingFrames) {\n            return;\n        }\n\n        var videosLength = videos.length;\n\n        var fullcanvas = false;\n        var remaining = [];\n        videos.forEach(function(video) {\n            if (!video.stream) {\n                video.stream = {};\n            }\n\n            if (video.stream.fullcanvas) {\n                fullcanvas = video;\n            } else {\n                // todo: video.stream.active or video.stream.live to fix blank frames issues?\n                remaining.push(video);\n            }\n        });\n\n        if (fullcanvas) {\n            canvas.width = fullcanvas.stream.width;\n            canvas.height = fullcanvas.stream.height;\n        } else if (remaining.length) {\n            canvas.width = videosLength > 1 ? remaining[0].width * 2 : remaining[0].width;\n\n            var height = 1;\n            if (videosLength === 3 || videosLength === 4) {\n                height = 2;\n            }\n            if (videosLength === 5 || videosLength === 6) {\n                height = 3;\n            }\n            if (videosLength === 7 || videosLength === 8) {\n                height = 4;\n            }\n            if (videosLength === 9 || videosLength === 10) {\n                height = 5;\n            }\n            canvas.height = remaining[0].height * height;\n        } else {\n            canvas.width = self.width || 360;\n            canvas.height = self.height || 240;\n        }\n\n        if (fullcanvas && fullcanvas instanceof HTMLVideoElement) {\n            drawImage(fullcanvas);\n        }\n\n        remaining.forEach(function(video, idx) {\n            drawImage(video, idx);\n        });\n\n        setTimeout(drawVideosToCanvas, self.frameInterval);\n    }\n\n    function drawImage(video, idx) {\n        if (isStopDrawingFrames) {\n            return;\n        }\n\n        var x = 0;\n        var y = 0;\n        var width = video.width;\n        var height = video.height;\n\n        if (idx === 1) {\n            x = video.width;\n        }\n\n        if (idx === 2) {\n            y = video.height;\n        }\n\n        if (idx === 3) {\n            x = video.width;\n            y = video.height;\n        }\n\n        if (idx === 4) {\n            y = video.height * 2;\n        }\n\n        if (idx === 5) {\n            x = video.width;\n            y = video.height * 2;\n        }\n\n        if (idx === 6) {\n            y = video.height * 3;\n        }\n\n        if (idx === 7) {\n            x = video.width;\n            y = video.height * 3;\n        }\n\n        if (typeof video.stream.left !== 'undefined') {\n            x = video.stream.left;\n        }\n\n        if (typeof video.stream.top !== 'undefined') {\n            y = video.stream.top;\n        }\n\n        if (typeof video.stream.width !== 'undefined') {\n            width = video.stream.width;\n        }\n\n        if (typeof video.stream.height !== 'undefined') {\n            height = video.stream.height;\n        }\n\n        context.drawImage(video, x, y, width, height);\n\n        if (typeof video.stream.onRender === 'function') {\n            video.stream.onRender(context, x, y, width, height, idx);\n        }\n    }\n\n    function getMixedStream() {\n        isStopDrawingFrames = false;\n        var mixedVideoStream = getMixedVideoStream();\n\n        var mixedAudioStream = getMixedAudioStream();\n        if (mixedAudioStream) {\n            mixedAudioStream.getTracks().filter(function(t) {\n                return t.kind === 'audio';\n            }).forEach(function(track) {\n                mixedVideoStream.addTrack(track);\n            });\n        }\n\n        var fullcanvas;\n        arrayOfMediaStreams.forEach(function(stream) {\n            if (stream.fullcanvas) {\n                fullcanvas = true;\n            }\n        });\n\n        // mixedVideoStream.prototype.appendStreams = appendStreams;\n        // mixedVideoStream.prototype.resetVideoStreams = resetVideoStreams;\n        // mixedVideoStream.prototype.clearRecordedData = clearRecordedData;\n\n        return mixedVideoStream;\n    }\n\n    function getMixedVideoStream() {\n        resetVideoStreams();\n\n        var capturedStream;\n\n        if ('captureStream' in canvas) {\n            capturedStream = canvas.captureStream();\n        } else if ('mozCaptureStream' in canvas) {\n            capturedStream = canvas.mozCaptureStream();\n        } else if (!self.disableLogs) {\n            console.error('Upgrade to latest Chrome or otherwise enable this flag: chrome://flags/#enable-experimental-web-platform-features');\n        }\n\n        var videoStream = new MediaStream();\n\n        capturedStream.getTracks().filter(function(t) {\n            return t.kind === 'video';\n        }).forEach(function(track) {\n            videoStream.addTrack(track);\n        });\n\n        canvas.stream = videoStream;\n\n        return videoStream;\n    }\n\n    function getMixedAudioStream() {\n        // via: @pehrsons\n        if (!Storage.AudioContextConstructor) {\n            Storage.AudioContextConstructor = new Storage.AudioContext();\n        }\n\n        self.audioContext = Storage.AudioContextConstructor;\n\n        self.audioSources = [];\n\n        if (self.useGainNode === true) {\n            self.gainNode = self.audioContext.createGain();\n            self.gainNode.connect(self.audioContext.destination);\n            self.gainNode.gain.value = 0; // don't hear self\n        }\n\n        var audioTracksLength = 0;\n        arrayOfMediaStreams.forEach(function(stream) {\n            if (!stream.getTracks().filter(function(t) {\n                    return t.kind === 'audio';\n                }).length) {\n                return;\n            }\n\n            audioTracksLength++;\n\n            var audioSource = self.audioContext.createMediaStreamSource(stream);\n\n            if (self.useGainNode === true) {\n                audioSource.connect(self.gainNode);\n            }\n\n            self.audioSources.push(audioSource);\n        });\n\n        if (!audioTracksLength) {\n            // because \"self.audioContext\" is not initialized\n            // that's why we've to ignore rest of the code\n            return;\n        }\n\n        self.audioDestination = self.audioContext.createMediaStreamDestination();\n        self.audioSources.forEach(function(audioSource) {\n            audioSource.connect(self.audioDestination);\n        });\n        return self.audioDestination.stream;\n    }\n\n    function getVideo(stream) {\n        var video = document.createElement('video');\n\n        setSrcObject(stream, video);\n\n        video.className = elementClass;\n\n        video.muted = true;\n        video.volume = 0;\n\n        video.width = stream.width || self.width || 360;\n        video.height = stream.height || self.height || 240;\n\n        video.play();\n\n        return video;\n    }\n\n    this.appendStreams = function(streams) {\n        if (!streams) {\n            throw 'First parameter is required.';\n        }\n\n        if (!(streams instanceof Array)) {\n            streams = [streams];\n        }\n\n        streams.forEach(function(stream) {\n            var newStream = new MediaStream();\n\n            if (stream.getTracks().filter(function(t) {\n                    return t.kind === 'video';\n                }).length) {\n                var video = getVideo(stream);\n                video.stream = stream;\n                videos.push(video);\n\n                newStream.addTrack(stream.getTracks().filter(function(t) {\n                    return t.kind === 'video';\n                })[0]);\n            }\n\n            if (stream.getTracks().filter(function(t) {\n                    return t.kind === 'audio';\n                }).length) {\n                var audioSource = self.audioContext.createMediaStreamSource(stream);\n                self.audioDestination = self.audioContext.createMediaStreamDestination();\n                audioSource.connect(self.audioDestination);\n\n                newStream.addTrack(self.audioDestination.stream.getTracks().filter(function(t) {\n                    return t.kind === 'audio';\n                })[0]);\n            }\n\n            arrayOfMediaStreams.push(newStream);\n        });\n    };\n\n    this.releaseStreams = function() {\n        videos = [];\n        isStopDrawingFrames = true;\n\n        if (self.gainNode) {\n            self.gainNode.disconnect();\n            self.gainNode = null;\n        }\n\n        if (self.audioSources.length) {\n            self.audioSources.forEach(function(source) {\n                source.disconnect();\n            });\n            self.audioSources = [];\n        }\n\n        if (self.audioDestination) {\n            self.audioDestination.disconnect();\n            self.audioDestination = null;\n        }\n\n        if (self.audioContext) {\n            self.audioContext.close();\n        }\n\n        self.audioContext = null;\n\n        context.clearRect(0, 0, canvas.width, canvas.height);\n\n        if (canvas.stream) {\n            canvas.stream.stop();\n            canvas.stream = null;\n        }\n    };\n\n    this.resetVideoStreams = function(streams) {\n        if (streams && !(streams instanceof Array)) {\n            streams = [streams];\n        }\n\n        resetVideoStreams(streams);\n    };\n\n    function resetVideoStreams(streams) {\n        videos = [];\n        streams = streams || arrayOfMediaStreams;\n\n        // via: @adrian-ber\n        streams.forEach(function(stream) {\n            if (!stream.getTracks().filter(function(t) {\n                    return t.kind === 'video';\n                }).length) {\n                return;\n            }\n\n            var video = getVideo(stream);\n            video.stream = stream;\n            videos.push(video);\n        });\n    }\n\n    // for debugging\n    this.name = 'MultiStreamsMixer';\n    this.toString = function() {\n        return this.name;\n    };\n\n    this.getMixedStream = getMixedStream;\n\n}\n\nif (typeof RecordRTC === 'undefined') {\n    if (typeof module !== 'undefined' /* && !!module.exports*/ ) {\n        module.exports = MultiStreamsMixer;\n    }\n\n    if (typeof define === 'function' && define.amd) {\n        define('MultiStreamsMixer', [], function() {\n            return MultiStreamsMixer;\n        });\n    }\n}\n\n// ______________________\n// MultiStreamRecorder.js\n\n/*\n * Video conference recording, using captureStream API along with WebAudio and Canvas2D API.\n */\n\n/**\n * MultiStreamRecorder can record multiple videos in single container.\n * @summary Multi-videos recorder.\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @typedef MultiStreamRecorder\n * @class\n * @example\n * var options = {\n *     mimeType: 'video/webm'\n * }\n * var recorder = new MultiStreamRecorder(ArrayOfMediaStreams, options);\n * recorder.record();\n * recorder.stop(function(blob) {\n *     video.src = URL.createObjectURL(blob);\n *\n *     // or\n *     var blob = recorder.blob;\n * });\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n * @param {MediaStreams} mediaStreams - Array of MediaStreams.\n * @param {object} config - {disableLogs:true, frameInterval: 1, mimeType: \"video/webm\"}\n */\n\nfunction MultiStreamRecorder(arrayOfMediaStreams, options) {\n    arrayOfMediaStreams = arrayOfMediaStreams || [];\n    var self = this;\n\n    var mixer;\n    var mediaRecorder;\n\n    options = options || {\n        elementClass: 'multi-streams-mixer',\n        mimeType: 'video/webm',\n        video: {\n            width: 360,\n            height: 240\n        }\n    };\n\n    if (!options.frameInterval) {\n        options.frameInterval = 10;\n    }\n\n    if (!options.video) {\n        options.video = {};\n    }\n\n    if (!options.video.width) {\n        options.video.width = 360;\n    }\n\n    if (!options.video.height) {\n        options.video.height = 240;\n    }\n\n    /**\n     * This method records all MediaStreams.\n     * @method\n     * @memberof MultiStreamRecorder\n     * @example\n     * recorder.record();\n     */\n    this.record = function() {\n        // github/muaz-khan/MultiStreamsMixer\n        mixer = new MultiStreamsMixer(arrayOfMediaStreams, options.elementClass || 'multi-streams-mixer');\n\n        if (getAllVideoTracks().length) {\n            mixer.frameInterval = options.frameInterval || 10;\n            mixer.width = options.video.width || 360;\n            mixer.height = options.video.height || 240;\n            mixer.startDrawingFrames();\n        }\n\n        if (options.previewStream && typeof options.previewStream === 'function') {\n            options.previewStream(mixer.getMixedStream());\n        }\n\n        // record using MediaRecorder API\n        mediaRecorder = new MediaStreamRecorder(mixer.getMixedStream(), options);\n        mediaRecorder.record();\n    };\n\n    function getAllVideoTracks() {\n        var tracks = [];\n        arrayOfMediaStreams.forEach(function(stream) {\n            getTracks(stream, 'video').forEach(function(track) {\n                tracks.push(track);\n            });\n        });\n        return tracks;\n    }\n\n    /**\n     * This method stops recording MediaStream.\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\n     * @method\n     * @memberof MultiStreamRecorder\n     * @example\n     * recorder.stop(function(blob) {\n     *     video.src = URL.createObjectURL(blob);\n     * });\n     */\n    this.stop = function(callback) {\n        if (!mediaRecorder) {\n            return;\n        }\n\n        mediaRecorder.stop(function(blob) {\n            self.blob = blob;\n\n            callback(blob);\n\n            self.clearRecordedData();\n        });\n    };\n\n    /**\n     * This method pauses the recording process.\n     * @method\n     * @memberof MultiStreamRecorder\n     * @example\n     * recorder.pause();\n     */\n    this.pause = function() {\n        if (mediaRecorder) {\n            mediaRecorder.pause();\n        }\n    };\n\n    /**\n     * This method resumes the recording process.\n     * @method\n     * @memberof MultiStreamRecorder\n     * @example\n     * recorder.resume();\n     */\n    this.resume = function() {\n        if (mediaRecorder) {\n            mediaRecorder.resume();\n        }\n    };\n\n    /**\n     * This method resets currently recorded data.\n     * @method\n     * @memberof MultiStreamRecorder\n     * @example\n     * recorder.clearRecordedData();\n     */\n    this.clearRecordedData = function() {\n        if (mediaRecorder) {\n            mediaRecorder.clearRecordedData();\n            mediaRecorder = null;\n        }\n\n        if (mixer) {\n            mixer.releaseStreams();\n            mixer = null;\n        }\n    };\n\n    /**\n     * Add extra media-streams to existing recordings.\n     * @method\n     * @memberof MultiStreamRecorder\n     * @param {MediaStreams} mediaStreams - Array of MediaStreams\n     * @example\n     * recorder.addStreams([newAudioStream, newVideoStream]);\n     */\n    this.addStreams = function(streams) {\n        if (!streams) {\n            throw 'First parameter is required.';\n        }\n\n        if (!(streams instanceof Array)) {\n            streams = [streams];\n        }\n\n        arrayOfMediaStreams.concat(streams);\n\n        if (!mediaRecorder || !mixer) {\n            return;\n        }\n\n        mixer.appendStreams(streams);\n\n        if (options.previewStream && typeof options.previewStream === 'function') {\n            options.previewStream(mixer.getMixedStream());\n        }\n    };\n\n    /**\n     * Reset videos during live recording. Replace old videos e.g. replace cameras with full-screen.\n     * @method\n     * @memberof MultiStreamRecorder\n     * @param {MediaStreams} mediaStreams - Array of MediaStreams\n     * @example\n     * recorder.resetVideoStreams([newVideo1, newVideo2]);\n     */\n    this.resetVideoStreams = function(streams) {\n        if (!mixer) {\n            return;\n        }\n\n        if (streams && !(streams instanceof Array)) {\n            streams = [streams];\n        }\n\n        mixer.resetVideoStreams(streams);\n    };\n\n    /**\n     * Returns MultiStreamsMixer\n     * @method\n     * @memberof MultiStreamRecorder\n     * @example\n     * let mixer = recorder.getMixer();\n     * mixer.appendStreams([newStream]);\n     */\n    this.getMixer = function() {\n        return mixer;\n    };\n\n    // for debugging\n    this.name = 'MultiStreamRecorder';\n    this.toString = function() {\n        return this.name;\n    };\n}\n\nif (typeof RecordRTC !== 'undefined') {\n    RecordRTC.MultiStreamRecorder = MultiStreamRecorder;\n}\n\n// _____________________\n// RecordRTC.promises.js\n\n/**\n * RecordRTCPromisesHandler adds promises support in {@link RecordRTC}. Try a {@link https://github.com/muaz-khan/RecordRTC/blob/master/simple-demos/RecordRTCPromisesHandler.html|demo here}\n * @summary Promises for {@link RecordRTC}\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @typedef RecordRTCPromisesHandler\n * @class\n * @example\n * var recorder = new RecordRTCPromisesHandler(mediaStream, options);\n * recorder.startRecording()\n *         .then(successCB)\n *         .catch(errorCB);\n * // Note: You can access all RecordRTC API using \"recorder.recordRTC\" e.g. \n * recorder.recordRTC.onStateChanged = function(state) {};\n * recorder.recordRTC.setRecordingDuration(5000);\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n * @param {MediaStream} mediaStream - Single media-stream object, array of media-streams, html-canvas-element, etc.\n * @param {object} config - {type:\"video\", recorderType: MediaStreamRecorder, disableLogs: true, numberOfAudioChannels: 1, bufferSize: 0, sampleRate: 0, video: HTMLVideoElement, etc.}\n * @throws Will throw an error if \"new\" keyword is not used to initiate \"RecordRTCPromisesHandler\". Also throws error if first argument \"MediaStream\" is missing.\n * @requires {@link RecordRTC}\n */\n\nfunction RecordRTCPromisesHandler(mediaStream, options) {\n    if (!this) {\n        throw 'Use \"new RecordRTCPromisesHandler()\"';\n    }\n\n    if (typeof mediaStream === 'undefined') {\n        throw 'First argument \"MediaStream\" is required.';\n    }\n\n    var self = this;\n\n    /**\n     * @property {Blob} blob - Access/reach the native {@link RecordRTC} object.\n     * @memberof RecordRTCPromisesHandler\n     * @example\n     * let internal = recorder.recordRTC.getInternalRecorder();\n     * alert(internal instanceof MediaStreamRecorder);\n     * recorder.recordRTC.onStateChanged = function(state) {};\n     */\n    self.recordRTC = new RecordRTC(mediaStream, options);\n\n    /**\n     * This method records MediaStream.\n     * @method\n     * @memberof RecordRTCPromisesHandler\n     * @example\n     * recorder.startRecording()\n     *         .then(successCB)\n     *         .catch(errorCB);\n     */\n    this.startRecording = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                self.recordRTC.startRecording();\n                resolve();\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * This method stops the recording.\n     * @method\n     * @memberof RecordRTCPromisesHandler\n     * @example\n     * recorder.stopRecording().then(function() {\n     *     var blob = recorder.getBlob();\n     * }).catch(errorCB);\n     */\n    this.stopRecording = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                self.recordRTC.stopRecording(function(url) {\n                    self.blob = self.recordRTC.getBlob();\n\n                    if (!self.blob || !self.blob.size) {\n                        reject('Empty blob.', self.blob);\n                        return;\n                    }\n\n                    resolve(url);\n                });\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * This method pauses the recording. You can resume recording using \"resumeRecording\" method.\n     * @method\n     * @memberof RecordRTCPromisesHandler\n     * @example\n     * recorder.pauseRecording()\n     *         .then(successCB)\n     *         .catch(errorCB);\n     */\n    this.pauseRecording = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                self.recordRTC.pauseRecording();\n                resolve();\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * This method resumes the recording.\n     * @method\n     * @memberof RecordRTCPromisesHandler\n     * @example\n     * recorder.resumeRecording()\n     *         .then(successCB)\n     *         .catch(errorCB);\n     */\n    this.resumeRecording = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                self.recordRTC.resumeRecording();\n                resolve();\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * This method returns data-url for the recorded blob.\n     * @method\n     * @memberof RecordRTCPromisesHandler\n     * @example\n     * recorder.stopRecording().then(function() {\n     *     recorder.getDataURL().then(function(dataURL) {\n     *         window.open(dataURL);\n     *     }).catch(errorCB);;\n     * }).catch(errorCB);\n     */\n    this.getDataURL = function(callback) {\n        return new Promise(function(resolve, reject) {\n            try {\n                self.recordRTC.getDataURL(function(dataURL) {\n                    resolve(dataURL);\n                });\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * This method returns the recorded blob.\n     * @method\n     * @memberof RecordRTCPromisesHandler\n     * @example\n     * recorder.stopRecording().then(function() {\n     *     recorder.getBlob().then(function(blob) {})\n     * }).catch(errorCB);\n     */\n    this.getBlob = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                resolve(self.recordRTC.getBlob());\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * This method returns the internal recording object.\n     * @method\n     * @memberof RecordRTCPromisesHandler\n     * @example\n     * let internalRecorder = await recorder.getInternalRecorder();\n     * if(internalRecorder instanceof MultiStreamRecorder) {\n     *     internalRecorder.addStreams([newAudioStream]);\n     *     internalRecorder.resetVideoStreams([screenStream]);\n     * }\n     * @returns {Object} \n     */\n    this.getInternalRecorder = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                resolve(self.recordRTC.getInternalRecorder());\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * This method resets the recorder. So that you can reuse single recorder instance many times.\n     * @method\n     * @memberof RecordRTCPromisesHandler\n     * @example\n     * await recorder.reset();\n     * recorder.startRecording(); // record again\n     */\n    this.reset = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                resolve(self.recordRTC.reset());\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * Destroy RecordRTC instance. Clear all recorders and objects.\n     * @method\n     * @memberof RecordRTCPromisesHandler\n     * @example\n     * recorder.destroy().then(successCB).catch(errorCB);\n     */\n    this.destroy = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                resolve(self.recordRTC.destroy());\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * Get recorder's readonly state.\n     * @method\n     * @memberof RecordRTCPromisesHandler\n     * @example\n     * let state = await recorder.getState();\n     * // or\n     * recorder.getState().then(state => { console.log(state); })\n     * @returns {String} Returns recording state.\n     */\n    this.getState = function() {\n        return new Promise(function(resolve, reject) {\n            try {\n                resolve(self.recordRTC.getState());\n            } catch (e) {\n                reject(e);\n            }\n        });\n    };\n\n    /**\n     * @property {Blob} blob - Recorded data as \"Blob\" object.\n     * @memberof RecordRTCPromisesHandler\n     * @example\n     * await recorder.stopRecording();\n     * let blob = recorder.getBlob(); // or \"recorder.recordRTC.blob\"\n     * invokeSaveAsDialog(blob);\n     */\n    this.blob = null;\n\n    /**\n     * RecordRTC version number\n     * @property {String} version - Release version number.\n     * @memberof RecordRTCPromisesHandler\n     * @static\n     * @readonly\n     * @example\n     * alert(recorder.version);\n     */\n    this.version = '5.6.2';\n}\n\nif (typeof RecordRTC !== 'undefined') {\n    RecordRTC.RecordRTCPromisesHandler = RecordRTCPromisesHandler;\n}\n\n// ______________________\n// WebAssemblyRecorder.js\n\n/**\n * WebAssemblyRecorder lets you create webm videos in JavaScript via WebAssembly. The library consumes raw RGBA32 buffers (4 bytes per pixel) and turns them into a webm video with the given framerate and quality. This makes it compatible out-of-the-box with ImageData from a CANVAS. With realtime mode you can also use webm-wasm for streaming webm videos.\n * @summary Video recording feature in Chrome, Firefox and maybe Edge.\n * @license {@link https://github.com/muaz-khan/RecordRTC/blob/master/LICENSE|MIT}\n * @author {@link https://MuazKhan.com|Muaz Khan}\n * @typedef WebAssemblyRecorder\n * @class\n * @example\n * var recorder = new WebAssemblyRecorder(mediaStream);\n * recorder.record();\n * recorder.stop(function(blob) {\n *     video.src = URL.createObjectURL(blob);\n * });\n * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}\n * @param {MediaStream} mediaStream - MediaStream object fetched using getUserMedia API or generated using captureStreamUntilEnded or WebAudio API.\n * @param {object} config - {webAssemblyPath:'webm-wasm.wasm',workerPath: 'webm-worker.js', frameRate: 30, width: 1920, height: 1080, bitrate: 1024, realtime: true}\n */\nfunction WebAssemblyRecorder(stream, config) {\n    // based on: github.com/GoogleChromeLabs/webm-wasm\n\n    if (typeof ReadableStream === 'undefined' || typeof WritableStream === 'undefined') {\n        // because it fixes readable/writable streams issues\n        console.error('Following polyfill is strongly recommended: https://unpkg.com/@mattiasbuelens/web-streams-polyfill/dist/polyfill.min.js');\n    }\n\n    config = config || {};\n\n    config.width = config.width || 640;\n    config.height = config.height || 480;\n    config.frameRate = config.frameRate || 30;\n    config.bitrate = config.bitrate || 1200;\n    config.realtime = config.realtime || true;\n\n    function createBufferURL(buffer, type) {\n        return URL.createObjectURL(new Blob([buffer], {\n            type: type || ''\n        }));\n    }\n\n    var finished;\n\n    function cameraStream() {\n        return new ReadableStream({\n            start: function(controller) {\n                var cvs = document.createElement('canvas');\n                var video = document.createElement('video');\n                var first = true;\n                video.srcObject = stream;\n                video.muted = true;\n                video.height = config.height;\n                video.width = config.width;\n                video.volume = 0;\n                video.onplaying = function() {\n                    cvs.width = config.width;\n                    cvs.height = config.height;\n                    var ctx = cvs.getContext('2d');\n                    var frameTimeout = 1000 / config.frameRate;\n                    var cameraTimer = setInterval(function f() {\n                        if (finished) {\n                            clearInterval(cameraTimer);\n                            controller.close();\n                        }\n\n                        if (first) {\n                            first = false;\n                            if (config.onVideoProcessStarted) {\n                                config.onVideoProcessStarted();\n                            }\n                        }\n\n                        ctx.drawImage(video, 0, 0);\n                        if (controller._controlledReadableStream.state !== 'closed') {\n                            try {\n                                controller.enqueue(\n                                    ctx.getImageData(0, 0, config.width, config.height)\n                                );\n                            } catch (e) {}\n                        }\n                    }, frameTimeout);\n                };\n                video.play();\n            }\n        });\n    }\n\n    var worker;\n\n    function startRecording(stream, buffer) {\n        if (!config.workerPath && !buffer) {\n            finished = false;\n\n            // is it safe to use @latest ?\n\n            fetch(\n                'https://unpkg.com/webm-wasm@latest/dist/webm-worker.js'\n            ).then(function(r) {\n                r.arrayBuffer().then(function(buffer) {\n                    startRecording(stream, buffer);\n                });\n            });\n            return;\n        }\n\n        if (!config.workerPath && buffer instanceof ArrayBuffer) {\n            var blob = new Blob([buffer], {\n                type: 'text/javascript'\n            });\n            config.workerPath = URL.createObjectURL(blob);\n        }\n\n        if (!config.workerPath) {\n            console.error('workerPath parameter is missing.');\n        }\n\n        worker = new Worker(config.workerPath);\n\n        worker.postMessage(config.webAssemblyPath || 'https://unpkg.com/webm-wasm@latest/dist/webm-wasm.wasm');\n        worker.addEventListener('message', function(event) {\n            if (event.data === 'READY') {\n                worker.postMessage({\n                    width: config.width,\n                    height: config.height,\n                    bitrate: config.bitrate || 1200,\n                    timebaseDen: config.frameRate || 30,\n                    realtime: config.realtime\n                });\n\n                cameraStream().pipeTo(new WritableStream({\n                    write: function(image) {\n                        if (finished) {\n                            console.error('Got image, but recorder is finished!');\n                            return;\n                        }\n\n                        worker.postMessage(image.data.buffer, [image.data.buffer]);\n                    }\n                }));\n            } else if (!!event.data) {\n                if (!isPaused) {\n                    arrayOfBuffers.push(event.data);\n                }\n            }\n        });\n    }\n\n    /**\n     * This method records video.\n     * @method\n     * @memberof WebAssemblyRecorder\n     * @example\n     * recorder.record();\n     */\n    this.record = function() {\n        arrayOfBuffers = [];\n        isPaused = false;\n        this.blob = null;\n        startRecording(stream);\n\n        if (typeof config.initCallback === 'function') {\n            config.initCallback();\n        }\n    };\n\n    var isPaused;\n\n    /**\n     * This method pauses the recording process.\n     * @method\n     * @memberof WebAssemblyRecorder\n     * @example\n     * recorder.pause();\n     */\n    this.pause = function() {\n        isPaused = true;\n    };\n\n    /**\n     * This method resumes the recording process.\n     * @method\n     * @memberof WebAssemblyRecorder\n     * @example\n     * recorder.resume();\n     */\n    this.resume = function() {\n        isPaused = false;\n    };\n\n    function terminate(callback) {\n        if (!worker) {\n            if (callback) {\n                callback();\n            }\n\n            return;\n        }\n\n        // Wait for null event data to indicate that the encoding is complete\n        worker.addEventListener('message', function(event) {\n            if (event.data === null) {\n                worker.terminate();\n                worker = null;\n\n                if (callback) {\n                    callback();\n                }\n            }\n        });\n\n        worker.postMessage(null);\n    }\n\n    var arrayOfBuffers = [];\n\n    /**\n     * This method stops recording video.\n     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.\n     * @method\n     * @memberof WebAssemblyRecorder\n     * @example\n     * recorder.stop(function(blob) {\n     *     video.src = URL.createObjectURL(blob);\n     * });\n     */\n    this.stop = function(callback) {\n        finished = true;\n\n        var recorder = this;\n\n        terminate(function() {\n            recorder.blob = new Blob(arrayOfBuffers, {\n                type: 'video/webm'\n            });\n\n            callback(recorder.blob);\n        });\n    };\n\n    // for debugging\n    this.name = 'WebAssemblyRecorder';\n    this.toString = function() {\n        return this.name;\n    };\n\n    /**\n     * This method resets currently recorded data.\n     * @method\n     * @memberof WebAssemblyRecorder\n     * @example\n     * recorder.clearRecordedData();\n     */\n    this.clearRecordedData = function() {\n        arrayOfBuffers = [];\n        isPaused = false;\n        this.blob = null;\n\n        // todo: if recording-ON then STOP it first\n    };\n\n    /**\n     * @property {Blob} blob - The recorded blob object.\n     * @memberof WebAssemblyRecorder\n     * @example\n     * recorder.stop(function(){\n     *     var blob = recorder.blob;\n     * });\n     */\n    this.blob = null;\n}\n\nif (typeof RecordRTC !== 'undefined') {\n    RecordRTC.WebAssemblyRecorder = WebAssemblyRecorder;\n}\n","<script>\n    import { onMount } from 'svelte';\n    import RecordRTC from './RecordRTC.js';\n    let videoRecorder;\n    let videoRecorded;\n    let videoRecordedURL;\n    let recorder;\n\n    onMount(() => {\n        videoRecorder  = document.getElementById(\"video-recorder\");\n        videoRecorded = document.getElementById(\"video-recorded\");\n\t});\n\n    export const handleRecordVideo = () => {\n        const recordingTimeMS = 6000;\n        console.log(videoRecorder)\n        videoRecorder.style.display = \"block\"; // display video for record\n        videoRecorded.style.display = \"none\"; // hide video recorded\n        videoRecorder.style.backgroundColor = \"black\"\n        videoRecorded.style.backgroundColor = \"black\";\n\n        if (videoRecordedURL) { // check for revoke obj url\n            URL.revokeObjectURL(videoRecordedURL)\n        }\n\n        captureCamera(function(camera) {\n            videoRecorder.muted = true;\n            videoRecorder.volume = 0;\n            videoRecorder.srcObject = camera;\n\n            recorder = RecordRTC(camera, {\n                type: 'video',\n                audio: false,\n                video: true\n            });\n\n            recorder.startRecording();\n\n            // release camera on stopRecording\n            recorder.camera = camera;\n\n            setTimeout(function () {\n                recorder.stopRecording(stopRecordingCallback);\n            }, recordingTimeMS)\n        })\n    }\n\n    const captureCamera = (callback) => {\n        const constraints = { video: true };\n\n        navigator.mediaDevices.getUserMedia(constraints).then(function(camera) {\n        callback(camera);\n        }).catch(function(error) {\n        console.error(error);\n\n        if (error.name.indexOf('NotAllowedError') !== -1) {\n            onErrorGetAccessCamera()\n        }\n        });\n    }\n\n    const stopRecordingCallback = () => {\n        const recordedBlob = recorder.getBlob()\n        console.log('recordedBlob', recordedBlob)\n        videoRecordedURL = URL.createObjectURL(recordedBlob);\n        videoRecorder.muted = true;\n        videoRecorded.src = videoRecordedURL\n        recorder.camera.stop();\n        recorder.destroy();\n        recorder = null;\n\n        videoRecorder.style.display = \"none\"; // hide video recorder\n        videoRecorded.style.display = \"block\"; // display video recorded\n        // Assign video file to `input file for prepare to upload`\n    }\n\n</script>\n<link rel=\"stylesheet\" href=\"video-verify-identity.css\" />\n\n<div id=\"video-recorder-container\" class=\"video-recorder-container\">\n    <content class=\"video-recorder-content-container\">\n        <div class=\"content-wrapper\">\n            <div class=\"video-recorder-header-message\">\n                <span>Record Video</span>\n            </div>\n            <div class=\"video-recorder-wrapper\">\n                <video id=\"video-recorder\" class=\"video-recorder\" autoplay muted playsinline></video>\n                <video id=\"video-recorded\" class=\"video-recorder\" controls style=\"display: none\"></video>\n            </div>\n            <div class=\"start-verify-button-wrapper\">\n                <button class=\"start-verify-button\" on:click={handleRecordVideo}>\n                    <span>Start Recording</span>\n                </button>\n            </div>\n            <div class=\"message-wrapper\">\n                <div class=\"hint-message\">\n                    <span>Note: Recording for 5 seconds when you click start recording </span>\n                </div>\n            </div>\n            <p id=\"not-verify-message\" class=\"upload-document-error\" style=\"display: none; margin-bottom: 10px;\">กรุณายืนยันตัวตน</p>\n            <p id=\"video-verify-success-message\" class=\"upload-success\" style=\"display: none; margin-bottom: 10px;\">วิดีโอของท่านได้รับการบันทึกเรียบร้อยแล้ว</p>\n        </div>\n    </content>\n</div>","<script>\n\timport adapter from 'webrtc-adapter';\n\timport VideoRecord from './VideoRecord.svelte'\n\n\tconst userAgent = navigator.userAgent;\n\tconst detectOpenWebOnLineApp = () => {\n\t\tconst userAgentSplitToArr = userAgent.split(' ');\n\t\tconst userAgentSplitToArrLast = userAgentSplitToArr[userAgentSplitToArr.length - 1]\n\n\t\treturn userAgentSplitToArrLast.includes('Line')\n\t}\n\n\tif (detectOpenWebOnLineApp()) {\n\t\twindow.open(window.location , '_system');\n\t}\n\n\texport const getCurrentWebOpen = () => {\n\t\treturn detectOpenWebOnLineApp() ? 'Line Application' : 'Itself';\n\t}\n\n\texport let name;\n\t$: adapter\n</script>\n<link rel=\"stylesheet\" href=\"main.css\" />\n\n<header>\n\tWebRTC Experiment🧪\n</header>\n<main>\n\t<div class=\"flex-container\">\n\t\t<div class=\"row\"> \n\t\t\t<VideoRecord />\n\t\t\t<div class=\"div-table\">\n\t\t\t\t<div class=\"div-table-row\">\n\t\t\t\t\t<div class=\"div-table-col header\" align=\"center\">Browser</div>\n\t\t\t\t\t<div class=\"div-table-col header\">Version</div>\n\t\t\t\t\t<div class=\"div-table-col header\">Run On</div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"div-table-row\">\n\t\t\t\t\t<div class=\"div-table-col\">{adapter.browserDetails.browser}</div>\n\t\t\t\t\t<div class=\"div-table-col\">{adapter.browserDetails.version}</div>\n\t\t\t\t\t<div class=\"div-table-col\">{getCurrentWebOpen()}</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</main>\n\n<footer>\n\tCopyright © 2021 Nottnt. \n\t<img src=\"/sad-cat.png\" alt=\"Girl in a jacket\" width=\"25\" height=\"25\">\n</footer>","import App from './App.svelte';\n\nconst app = new App({\n\ttarget: document.body,\n\tprops: {\n\t\tname: 'nott'\n\t}\n});\n\nexport default app;"],"names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","element","name","document","createElement","space","data","createTextNode","attr","attribute","value","removeAttribute","getAttribute","setAttribute","set_style","key","important","style","setProperty","current_component","set_current_component","component","onMount","Error","get_current_component","$$","on_mount","push","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","flushing","seen_callbacks","Set","flush","i","length","update","pop","callback","has","add","clear","fragment","before_update","dirty","p","ctx","after_update","outroing","transition_in","block","local","delete","mount_component","customElement","on_destroy","m","new_on_destroy","map","filter","destroy_component","detaching","d","make_dirty","then","fill","init","options","instance","create_fragment","not_equal","props","append_styles","parent_component","bound","on_disconnect","context","Map","callbacks","skip_bound","root","ready","ret","rest","hydrate","nodes","Array","from","childNodes","children","l","c","intro","SvelteComponent","$destroy","this","$on","type","index","indexOf","splice","$set","$$props","obj","$$set","keys","logDisabled_","deprecationWarnings_","extractVersion","uastring","expr","pos","match","parseInt","wrapPeerConnectionEvent","window","eventNameToWrap","wrapper","RTCPeerConnection","proto","prototype","nativeAddEventListener","addEventListener","nativeEventName","cb","apply","arguments","wrappedCallback","e","modifiedEvent","handleEvent","_eventMap","set","nativeRemoveEventListener","removeEventListener","unwrappedCb","get","size","defineProperty","enumerable","configurable","disableLog","bool","disableWarnings","log","console","deprecated","oldMethod","newMethod","warn","isObject","val","toString","call","compactObject","reduce","accumulator","isObj","isEmptyObject","undefined","assign","walkStats","stats","base","resultSet","id","endsWith","filterStats","result","track","outbound","streamStatsType","filteredResult","trackStats","trackIdentifier","trackStat","trackId","logging","utils.log","shimGetUserMedia","browserDetails","navigator","mediaDevices","constraintsToChrome_","mandatory","optional","cc","r","ideal","exact","min","max","oldname_","prefix","charAt","toUpperCase","slice","oc","mix","advanced","concat","shimConstraints_","constraints","func","version","JSON","parse","stringify","audio","remap","video","face","facingMode","getSupportedFacingModeLies","getSupportedConstraints","matches","enumerateDevices","devices","dev","kind","find","some","label","toLowerCase","includes","deviceId","shimError_","PermissionDeniedError","PermissionDismissedError","InvalidStateError","DevicesNotFoundError","ConstraintNotSatisfiedError","TrackStartError","MediaDeviceFailedDueToShutdown","MediaDeviceKillSwitchOn","TabCaptureError","ScreenCaptureError","DeviceCaptureError","message","constraint","constraintName","getUserMedia","onSuccess","onError","webkitGetUserMedia","bind","origGetUserMedia","cs","stream","getAudioTracks","getVideoTracks","getTracks","stop","DOMException","reject","shimMediaStream","MediaStream","webkitMediaStream","shimOnTrack","_ontrack","f","origSetRemoteDescription","setRemoteDescription","_ontrackpoly","te","receiver","getReceivers","event","Event","transceiver","streams","dispatchEvent","utils.wrapPeerConnectionEvent","shimGetSendersWithDtmf","shimSenderWithDtmf","pc","dtmf","_dtmf","createDTMFSender","_pc","getSenders","_senders","origAddTrack","addTrack","sender","origRemoveTrack","removeTrack","idx","origAddStream","addStream","origRemoveStream","removeStream","s","RTCRtpSender","origGetSenders","senders","shimGetStats","origGetStats","getStats","selector","onSucc","onErr","fixChromeStats_","response","standardReport","report","standardStats","timestamp","localcandidate","remotecandidate","names","stat","makeMapStats","successCallbackWrapper_","shimSenderReceiverGetStats","RTCRtpReceiver","utils.filterStats","origGetReceivers","receivers","srcElement","MediaStreamTrack","err","shimAddTrackRemoveTrackWithNative","getLocalStreams","_shimmedLocalStreams","streamId","existingSenders","newSenders","newSender","shimAddTrackRemoveTrack","origGetLocalStreams","nativeStreams","_reverseStreams","_streams","newStream","replaceInternalStreamId","description","sdp","internalId","externalStream","internalStream","replace","RegExp","RTCSessionDescription","replaceExternalStreamId","signalingState","t","alreadyExists","oldStream","method","nativeMethod","methodObj","args","desc","origSetLocalDescription","setLocalDescription","origLocalDescription","getOwnPropertyDescriptor","streamid","shimPeerConnection","webkitRTCPeerConnection","RTCIceCandidate","fixNegotiationNeeded","getConfiguration","sdpSemantics","getSourceId","getDisplayMedia","sourceId","widthSpecified","width","heightSpecified","height","frameRateSpecified","frameRate","chromeMediaSource","chromeMediaSourceId","maxFrameRate","maxWidth","maxHeight","error","utils.deprecated","nativeGetUserMedia","getSettings","nativeGetSettings","applyConstraints","nativeApplyConstraints","RTCTrackEvent","mozRTCPeerConnection","modernStatsTypes","inboundrtp","outboundrtp","candidatepair","nativeGetStats","shimSenderGetStats","shimReceiverGetStats","shimRemoveStream","shimRTCDataChannel","DataChannel","RTCDataChannel","shimAddTransceiver","origAddTransceiver","addTransceiver","setParametersPromises","initParameters","shouldPerformCheck","sendEncodings","encodingParam","test","rid","TypeError","parseFloat","scaleResolutionDownBy","RangeError","maxFramerate","params","getParameters","encodings","setParameters","catch","shimGetParameters","origGetParameters","shimCreateOffer","origCreateOffer","createOffer","all","finally","shimCreateAnswer","origCreateAnswer","createAnswer","preferredMediaSource","code","mediaSource","shimLocalStreamsAPI","_localStreams","_addTrack","tracks","shimRemoteStreamsAPI","getRemoteStreams","_remoteStreams","_onaddstream","_onaddstreampoly","shimCallbacksAPI","addIceCandidate","successCallback","failureCallback","promise","withCallback","candidate","_getUserMedia","shimConstraints","errcb","utils.compactObject","shimRTCIceServerUrls","OrigPeerConnection","pcConfig","pcConstraints","iceServers","newIceServers","server","hasOwnProperty","urls","url","generateCertificate","shimTrackEventTransceiver","shimCreateOfferLegacy","offerOptions","offerToReceiveAudio","audioTransceiver","getTransceivers","direction","setDirection","offerToReceiveVideo","videoTransceiver","shimAudioContext","AudioContext","webkitAudioContext","SDPUtils","Math","random","substr","localCName","generateIdentifier","splitLines","blob","trim","split","line","splitSections","part","getDescription","sections","getMediaSections","shift","matchPrefix","parseCandidate","parts","substring","foundation","protocol","priority","ip","address","port","relatedAddress","relatedPort","tcpType","ufrag","usernameFragment","writeCandidate","join","parseIceOptions","parseRtpMap","parsed","payloadType","clockRate","channels","numChannels","writeRtpMap","codec","pt","preferredPayloadType","parseExtmap","uri","writeExtmap","headerExtension","preferredId","parseFmtp","kv","j","writeFmtp","parameters","param","parseRtcpFb","parameter","writeRtcpFb","lines","rtcpFeedback","fb","parseSsrcMedia","sp","ssrc","colon","parseSsrcGroup","semantics","ssrcs","getMid","mediaSection","mid","parseFingerprint","algorithm","getDtlsParameters","sessionpart","role","fingerprints","writeDtlsParameters","setupType","fp","parseCryptoLine","tag","cryptoSuite","keyParams","sessionParams","writeCryptoLine","writeCryptoKeyParams","parseCryptoKeyParams","keyMethod","keySalt","lifeTime","mkiValue","mkiLength","getCryptoParameters","getIceParameters","pwd","password","writeIceParameters","iceLite","parseRtpParameters","codecs","headerExtensions","fecMechanisms","rtcp","mline","rtpmapline","fmtps","writeRtpDescription","caps","maxptime","extension","parseRtpEncodingParameters","encodingParameters","hasRed","hasUlpfec","primarySsrc","secondarySsrc","flows","apt","encParam","codecPayloadType","rtx","fec","mechanism","bandwidth","maxBitrate","parseRtcpParameters","rtcpParameters","remoteSsrc","cname","rsize","reducedSize","compound","mux","writeRtcpParameters","parseMsid","spec","planB","msidParts","parseSctpDescription","parseMLine","maxSizeLine","maxMessageSize","isNaN","sctpPort","fmt","sctpMapLines","writeSctpDescription","media","sctp","output","generateSessionId","writeSessionBoilerplate","sessId","sessVer","sessUser","sessionId","getDirection","getKind","isRejected","parseOLine","username","sessionVersion","netType","addressType","isValidSDP","module","shimRTCIceCandidate","NativeRTCIceCandidate","nativeCandidate","parsedCandidate","augmentedCandidate","toJSON","sdpMid","sdpMLineIndex","writable","shimMaxMessageSize","_sctp","sctpInDescription","mLine","getRemoteFirefoxVersion","getCanSendMaxMessageSize","remoteIsFirefox","canSendMaxMessageSize","browser","getMaxMessageSize","isFirefox","canSendMMS","remoteMMS","Number","POSITIVE_INFINITY","shimSendThrowTypeError","wrapDcSend","dc","origDataChannelSend","send","byteLength","readyState","origCreateDataChannel","createDataChannel","dataChannel","channel","shimConnectionState","completed","checking","iceConnectionState","_onconnectionstatechange","origMethod","_connectionstatechangepoly","_lastConnectionState","connectionState","newEvent","removeExtmapAllowMixed","nativeSRD","shimAddIceCandidateNullOrEmpty","nativeAddIceCandidate","shimParameterlessSetLocalDescription","nativeSetLocalDescription","adapter","shimChrome","shimFirefox","shimSafari","mozGetUserMedia","userAgent","isSecureContext","RTCIceGatherer","supportsUnifiedPlan","RTCRtpTransceiver","utils.detectBrowser","commonShim","utils.extractVersion","utils.disableLog","utils.disableWarnings","chromeShim","chromeShim.shimPeerConnection","browserShim","commonShim.shimAddIceCandidateNullOrEmpty","commonShim.shimParameterlessSetLocalDescription","chromeShim.shimGetUserMedia","chromeShim.shimMediaStream","chromeShim.shimOnTrack","chromeShim.shimAddTrackRemoveTrack","chromeShim.shimGetSendersWithDtmf","chromeShim.shimGetStats","chromeShim.shimSenderReceiverGetStats","chromeShim.fixNegotiationNeeded","commonShim.shimRTCIceCandidate","commonShim.shimConnectionState","commonShim.shimMaxMessageSize","commonShim.shimSendThrowTypeError","commonShim.removeExtmapAllowMixed","firefoxShim","firefoxShim.shimPeerConnection","firefoxShim.shimGetUserMedia","firefoxShim.shimOnTrack","firefoxShim.shimRemoveStream","firefoxShim.shimSenderGetStats","firefoxShim.shimReceiverGetStats","firefoxShim.shimRTCDataChannel","firefoxShim.shimAddTransceiver","firefoxShim.shimGetParameters","firefoxShim.shimCreateOffer","firefoxShim.shimCreateAnswer","safariShim","safariShim.shimRTCIceServerUrls","safariShim.shimCreateOfferLegacy","safariShim.shimCallbacksAPI","safariShim.shimLocalStreamsAPI","safariShim.shimRemoteStreamsAPI","safariShim.shimTrackEventTransceiver","safariShim.shimGetUserMedia","safariShim.shimAudioContext","adapterFactory","RecordRTC","mediaStream","config","RecordRTCConfiguration","self","initRecorder","initCallback","Recorder","GetRecorderType","mediaRecorder","record","setState","disableLogs","constructor","stopRecording","state","resumeRecording","setTimeout","_callback","warningLog","__blob","bytesToSize","URL","createObjectURL","autoWriteToDisk","getDataURL","dataURL","DiskStorage","Store","readFile","_blob","postMessage","FileReaderSync","readAsDataURL","_mediaRecorder","Worker","reader","FileReader","onload","webWorker","_function","Blob","worker","revokeObjectURL","processInWebWorker","onmessage","handleRecordingDuration","counter","recordingDuration","onRecordingStopped","onStateChanged","WARNING","returnObject","startRecording","config2","clearRecordedData","pauseRecording","pause","resume","setRecordingDuration","getBlob","toURL","getInternalRecorder","save","fileName","invokeSaveAsDialog","getFromDisk","setAdvertisementArray","arrayOfWebPImages","advertisement","duration","image","bufferSize","sampleRate","buffer","reset","getState","destroy","disableLogsCache","Storage","AudioContextConstructor","close","prop","recorderType","WhammyRecorder","CanvasRecorder","WebAssemblyRecorder","GifRecorder","StereoAudioRecorder","MediaStreamRecorder","MediaRecorder","mimeType","bitsPerSecond","recorder","isChrome","isEdge","isOpera","ReadableStream","isMediaRecorderCompatible","isTypeSupported","MultiStreamRecorder","isSafari","MRecordRTC","_mediaStream","mediaType","gif","audioRecorder","numberOfAudioChannels","timeSlice","onTimeStamp","videoTrack","videoRecorder","canvas","frameInterval","workerPath","webAssemblyPath","bitrate","isSingleRecorder","gifRecorder","quality","blobURL","callback00","webkitURL","_audioDataURL","_videoDataURL","writeToDisk","Fetch","_type","audioDataURL","videoDataURL","gifDataURL","audioBlob","videoBlob","gifBlob","that","global","documentElement","captureStream","mozCaptureStream","getContext","play","drawImage","toDataURL","HTMLVideoElement","location","href","hash","screen","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","lastTime","currTime","Date","getTime","timeToCall","cancelAnimationFrame","webkitCancelAnimationFrame","mozCancelAnimationFrame","msCancelAnimationFrame","clearTimeout","mozAudioContext","msSaveBlob","msSaveOrOpenBlob","opera","isElectron","bytes","floor","pow","toPrecision","file","fileExtension","splitted","fileFullName","round","hyperlink","download","body","click","MouseEvent","view","bubbles","cancelable","process","versions","electron","setSrcObject","srcObject","mozSrcObject","getSeekableBlob","inputBlob","EBML","Reader","decoder","Decoder","tools","fileReader","decode","read","refinedMetadataBuf","makeMetadataSeekable","metadatas","cues","metadataSize","newBlob","readAsArrayBuffer","verOffset","ix","nAgt","fullVersion","appVersion","majorVersion","arrayOfBlobs","updateTimeStamp","timestamps","getMimeType","secondObject","clearRecordedDataCB","getArrayOfBlobs","allStates","recorderHints","canRecordMimeType","ondataavailable","recordingCallback","getNativeBlob","onstart","onpause","onresume","onstop","onerror","looper","manuallyStopped","timeslice","start","getAllStates","checkForInactiveTracks","active","ended","isMediaStreamActive","jsAudioNode","leftchannel","rightchannel","recording","recordingLength","desiredSampRate","mergeLeftRightBuffers","mergeAudioBuffers","interleaved","leftBuffers","rightBuffers","internalInterleavedLength","interpolateArray","newSampleRate","oldSampleRate","fitCount","newData","springFactor","tmp","before","toFixed","after","ceil","atPoint","linearInterpolate","mergeBuffers","channelBuffer","rLength","Float64Array","offset","lng","writeUTFBytes","string","setUint8","charCodeAt","leftChannel","rightChannel","inputIndex","interleave","interleavedLength","ArrayBuffer","DataView","setUint32","setUint16","setInt16","noWorker","workerURL","terminate","resetVariables","isAudioProcessStarted","isPaused","audioInput","createMediaStreamSource","legalBufferValues","createJavaScriptNode","createScriptProcessor","connect","intervalsBasedBuffers","left","right","onaudioprocess","disconnect","onAudioProcessStarted","inputBuffer","getChannelData","chLeft","Float32Array","chRight","createMediaStreamDestination","destination","htmlElement","html2canvas","isCanvasSupportsStreamCapturing","item","globalCanvas","mediaStreamRecorder","isRecording","_isChrome","chrome","chromeVersion","matchArray","useWhammyRecorder","HTMLCanvasElement","CanvasRenderingContext2D","canvasMediaStream","webkitCaptureStream","mdStream","whammy","frames","drawCanvasFrame","getWebPImages","nodeName","framesLength","frame","framesRemaining","onEncodingCallback","webp","compile","isPausedRecording","newCanvas","grabMouse","showMousePointer","onrendered","Whammy","Video","drawFrames","paused","isStopDrawing","dropBlackFrames","_frames","_framesToCheck","_pixTolerance","_frameTolerance","localCanvas","o","context2d","resultFrames","checkUntilNotBlack","endCheckFrame","sampleColor","maxColorDifference","sqrt","pixTolerance","frameTolerance","doNotCheckNext","functionToLoop","loop","matchPixCount","endPixCheck","maxPixCount","finishImage","Image","imageData","getImageData","pix","currentColor","g","src","cloneNode","onloadedmetadata","muted","_this","WhammyVideo","whammyInWebWorker","getClusterData","clusterTimecode","clusterCounter","clusterFrames","flags","keyframe","invisible","lacing","discardable","trackNum","timecode","String","fromCharCode","makeSimpleBlock","numToBuffer","num","Uint8Array","reverse","bitsToBuffer","bits","generateEBML","json","ebml","len","zeroes","sizeToString","padded","getStrLength","unpadded","parseRIFF","chunks","webm","info","checkFrames","frameNumber","clusterDuration","cluster","riff","VP8","RIFF","WEBP","frameStart","parseWebP","atob","indexedDB","open","db","dbName","request","onsuccess","setVersion","createObjectStore","putInDB","onupgradeneeded","dataBase","dataStoreName","transaction","getFromStore","portionName","objectStore","put","GIFEncoder","script","isHTMLObject","isLoadedMetaData","offsetWidth","offsetHeight","gifEncoder","setRepeat","setDelay","setQuality","onGifRecordingStarted","lastAnimationFrame","drawVideoFrame","time","clearedRecordedData","lastFrameTime","onGifPreview","addFrame","bin","autoplay","playsInline","MultiStreamsMixer","arrayOfMediaStreams","elementClass","videos","isStopDrawingFrames","opacity","position","zIndex","top","className","useGainNode","drawVideosToCanvas","videosLength","fullcanvas","remaining","x","y","onRender","getVideo","volume","resetVideoStreams","startDrawingFrames","appendStreams","audioSource","audioContext","audioDestination","releaseStreams","gainNode","audioSources","source","clearRect","getMixedStream","mixedVideoStream","capturedStream","videoStream","getMixedVideoStream","mixedAudioStream","createGain","gain","audioTracksLength","getMixedAudioStream","mixer","previewStream","addStreams","getMixer","finished","cameraStream","controller","cvs","first","onplaying","frameTimeout","cameraTimer","setInterval","clearInterval","onVideoProcessStarted","_controlledReadableStream","enqueue","fetch","arrayBuffer","timebaseDen","realtime","pipeTo","WritableStream","write","arrayOfBuffers","RecordRTCPromisesHandler","recordRTC","handler","videoRecorded","videoRecordedURL","getElementById","captureCamera","camera","onErrorGetAccessCamera","stopRecordingCallback","recordedBlob","display","backgroundColor","outros","detectOpenWebOnLineApp","userAgentSplitToArr"],"mappings":"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"}